{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"GIS-Anwendungsentwicklung Master Modul Geoinformatik Teil 2 GIS-Anwendungsentwicklung mit Open-Source Werkzeugen Hinweis Erweiterung der portable Umgebung f\u00fcr den USB-Stick: Kann hier heruntergeladen werden. aktuelles Script als Download Hier finden Sie das Skript als ZIP-Datei zum Download. Es liegt im HTML-Format vor und ben\u00f6tigt einen http-Server, um alle Funktionen zu nutzen. Ein kleiner Server ist enthalten, er startet auf localhost mit port 8888.","title":"Home"},{"location":"index.html#gis-anwendungsentwicklung","text":"","title":"GIS-Anwendungsentwicklung"},{"location":"index.html#master-modul-geoinformatik","text":"","title":"Master Modul Geoinformatik"},{"location":"index.html#teil-2","text":"","title":"Teil 2"},{"location":"index.html#gis-anwendungsentwicklung-mit-open-source-werkzeugen","text":"","title":"GIS-Anwendungsentwicklung mit Open-Source Werkzeugen"},{"location":"index.html#hinweis","text":"Erweiterung der portable Umgebung f\u00fcr den USB-Stick: Kann hier heruntergeladen werden.","title":"Hinweis"},{"location":"index.html#aktuelles-script-als-download","text":"Hier finden Sie das Skript als ZIP-Datei zum Download. Es liegt im HTML-Format vor und ben\u00f6tigt einen http-Server, um alle Funktionen zu nutzen. Ein kleiner Server ist enthalten, er startet auf localhost mit port 8888.","title":"aktuelles Script als Download"},{"location":"beyond/impressum.html","text":"Impressum Verantwortlich Andreas M\u00fcller Universit\u00e4t Trier Fachbereich VI - Kartographie E-Mail: muellea@uni-trier.de Lizenz Dieses Werk ist lizenziert unter einer Creative Commons Namensnennung - Weitergabe unter gleichen Bedingungen 4.0 International Lizenz . Haftungsausschluss 1. Inhalt des Onlineangebotes Der Autor \u00fcbernimmt keinerlei Gew\u00e4hr f\u00fcr die Aktualit\u00e4t, Korrektheit, Vollst\u00e4ndigkeit oder Qualit\u00e4t der bereitgestellten Informationen. Haftungsanspr\u00fcche gegen den Autor, welche sich auf Sch\u00e4den materieller oder ideeller Art beziehen, die durch die Nutzung oder Nichtnutzung der dargebotenen Informationen bzw. durch die Nutzung fehlerhafter und unvollst\u00e4ndiger Informationen verursacht wurden, sind grunds\u00e4tzlich ausgeschlossen, sofern seitens des Autors kein nachweislich vors\u00e4tzliches oder grob fahrl\u00e4ssiges Verschulden vorliegt. Alle Angebote sind freibleibend und unverbindlich. Der Autor beh\u00e4lt es sich ausdr\u00fccklich vor, Teile der Seiten oder das gesamte Angebot ohne gesonderte Ank\u00fcndigung zu ver\u00e4ndern, zu erg\u00e4nzen, zu l\u00f6schen oder die Ver\u00f6ffentlichung zeitweise oder endg\u00fcltig einzustellen. 2. Verweise und Links Bei direkten oder indirekten Verweisen auf fremde Webseiten (\"Hyperlinks\"), die au\u00dferhalb des Verantwortungsbereiches des Autors liegen, w\u00fcrde eine Haftungsverpflichtung ausschlie\u00dflich in dem Fall in Kraft treten, in dem der Autor von den Inhalten Kenntnis hat und es ihm technisch m\u00f6glich und zumutbar w\u00e4re, die Nutzung im Falle rechtswidriger Inhalte zu verhindern. Der Autor erkl\u00e4rt hiermit ausdr\u00fccklich, dass zum Zeitpunkt der Linksetzung keine illegalen Inhalte auf den zu verlinkenden Seiten erkennbar waren. Auf die aktuelle und zuk\u00fcnftige Gestaltung, die Inhalte oder die Urheberschaft der verlinkten/verkn\u00fcpften Seiten hat der Autor keinerlei Einfluss. Deshalb distanziert er sich hiermit ausdr\u00fccklich von allen Inhalten aller verlinkten /verkn\u00fcpften Seiten, die nach der Linksetzung ver\u00e4ndert wurden. Diese Feststellung gilt f\u00fcr alle innerhalb des eigenen Internetangebotes gesetzten Links und Verweise sowie f\u00fcr Fremdeintr\u00e4ge in vom Autor eingerichteten G\u00e4steb\u00fcchern, Diskussionsforen, Linkverzeichnissen, Mailinglisten und in allen anderen Formen von Datenbanken, auf deren Inhalt externe Schreibzugriffe m\u00f6glich sind. F\u00fcr illegale, fehlerhafte oder unvollst\u00e4ndige Inhalte und insbesondere f\u00fcr Sch\u00e4den, die aus der Nutzung oder Nichtnutzung solcherart dargebotener Informationen entstehen, haftet allein der Anbieter der Seite, auf welche verwiesen wurde, nicht derjenige, der \u00fcber Links auf die jeweilige Ver\u00f6ffentlichung lediglich verweist. 3. Urheber- und Kennzeichenrecht Der Autor ist bestrebt, in allen Publikationen die Urheberrechte der verwendeten Bilder, Grafiken, Tondokumente, Videosequenzen und Texte zu beachten, von ihm selbst erstellte Bilder, Grafiken, Tondokumente, Videosequenzen und Texte zu nutzen oder auf lizenzfreie Grafiken, Tondokumente, Videosequenzen und Texte zur\u00fcckzugreifen. Alle innerhalb des Internetangebotes genannten und ggf. durch Dritte gesch\u00fctzten Marken- und Warenzeichen unterliegen uneingeschr\u00e4nkt den Bestimmungen des jeweils g\u00fcltigen Kennzeichenrechts und den Besitzrechten der jeweiligen eingetragenen Eigent\u00fcmer. Allein aufgrund der blo\u00dfen Nennung ist nicht der Schluss zu ziehen, dass Markenzeichen nicht durch Rechte Dritter gesch\u00fctzt sind! Das Copyright f\u00fcr ver\u00f6ffentlichte, vom Autor selbst erstellte Objekte bleibt allein beim Autor der Seiten. Eine Vervielf\u00e4ltigung oder Verwendung solcher Grafiken, Tondokumente, Videosequenzen und Texte in anderen elektronischen oder gedruckten Publikationen ist ohne ausdr\u00fcckliche Zustimmung des Autors nicht gestattet. 4. Datenschutz Sofern innerhalb des Internetangebotes die M\u00f6glichkeit zur Eingabe pers\u00f6nlicher oder gesch\u00e4ftlicher Daten (Emailadressen, Namen, Anschriften) besteht, so erfolgt die Preisgabe dieser Daten seitens des Nutzers auf ausdr\u00fccklich freiwilliger Basis. Die Inanspruchnahme und Bezahlung aller angebotenen Dienste ist - soweit technisch m\u00f6glich und zumutbar - auch ohne Angabe solcher Daten bzw. unter Angabe anonymisierter Daten oder eines Pseudonyms gestattet. Die Nutzung der im Rahmen des Impressums oder vergleichbarer Angaben ver\u00f6ffentlichten Kontaktdaten wie Postanschriften, Telefon- und Faxnummern sowie Emailadressen durch Dritte zur \u00dcbersendung von nicht ausdr\u00fccklich angeforderten Informationen ist nicht gestattet. Rechtliche Schritte gegen die Versender von sogenannten Spam-Mails bei Verst\u00f6ssen gegen dieses Verbot sind ausdr\u00fccklich vorbehalten. 5. Rechtswirksamkeit dieses Haftungsausschlusses Dieser Haftungsausschluss ist als Teil des Internetangebotes zu betrachten, von dem aus auf diese Seite verwiesen wurde. Sofern Teile oder einzelne Formulierungen dieses Textes der geltenden Rechtslage nicht, nicht mehr oder nicht vollst\u00e4ndig entsprechen sollten, bleiben die \u00fcbrigen Teile des Dokumentes in ihrem Inhalt und ihrer G\u00fcltigkeit davon unber\u00fchrt.","title":"Impressum"},{"location":"beyond/impressum.html#impressum","text":"","title":"Impressum"},{"location":"beyond/impressum.html#verantwortlich","text":"Andreas M\u00fcller Universit\u00e4t Trier Fachbereich VI - Kartographie E-Mail: muellea@uni-trier.de","title":"Verantwortlich"},{"location":"beyond/impressum.html#lizenz","text":"Dieses Werk ist lizenziert unter einer Creative Commons Namensnennung - Weitergabe unter gleichen Bedingungen 4.0 International Lizenz .","title":"Lizenz"},{"location":"beyond/impressum.html#haftungsausschluss","text":"","title":"Haftungsausschluss"},{"location":"beyond/impressum.html#1-inhalt-des-onlineangebotes","text":"Der Autor \u00fcbernimmt keinerlei Gew\u00e4hr f\u00fcr die Aktualit\u00e4t, Korrektheit, Vollst\u00e4ndigkeit oder Qualit\u00e4t der bereitgestellten Informationen. Haftungsanspr\u00fcche gegen den Autor, welche sich auf Sch\u00e4den materieller oder ideeller Art beziehen, die durch die Nutzung oder Nichtnutzung der dargebotenen Informationen bzw. durch die Nutzung fehlerhafter und unvollst\u00e4ndiger Informationen verursacht wurden, sind grunds\u00e4tzlich ausgeschlossen, sofern seitens des Autors kein nachweislich vors\u00e4tzliches oder grob fahrl\u00e4ssiges Verschulden vorliegt. Alle Angebote sind freibleibend und unverbindlich. Der Autor beh\u00e4lt es sich ausdr\u00fccklich vor, Teile der Seiten oder das gesamte Angebot ohne gesonderte Ank\u00fcndigung zu ver\u00e4ndern, zu erg\u00e4nzen, zu l\u00f6schen oder die Ver\u00f6ffentlichung zeitweise oder endg\u00fcltig einzustellen.","title":"1. Inhalt des Onlineangebotes"},{"location":"beyond/impressum.html#2-verweise-und-links","text":"Bei direkten oder indirekten Verweisen auf fremde Webseiten (\"Hyperlinks\"), die au\u00dferhalb des Verantwortungsbereiches des Autors liegen, w\u00fcrde eine Haftungsverpflichtung ausschlie\u00dflich in dem Fall in Kraft treten, in dem der Autor von den Inhalten Kenntnis hat und es ihm technisch m\u00f6glich und zumutbar w\u00e4re, die Nutzung im Falle rechtswidriger Inhalte zu verhindern. Der Autor erkl\u00e4rt hiermit ausdr\u00fccklich, dass zum Zeitpunkt der Linksetzung keine illegalen Inhalte auf den zu verlinkenden Seiten erkennbar waren. Auf die aktuelle und zuk\u00fcnftige Gestaltung, die Inhalte oder die Urheberschaft der verlinkten/verkn\u00fcpften Seiten hat der Autor keinerlei Einfluss. Deshalb distanziert er sich hiermit ausdr\u00fccklich von allen Inhalten aller verlinkten /verkn\u00fcpften Seiten, die nach der Linksetzung ver\u00e4ndert wurden. Diese Feststellung gilt f\u00fcr alle innerhalb des eigenen Internetangebotes gesetzten Links und Verweise sowie f\u00fcr Fremdeintr\u00e4ge in vom Autor eingerichteten G\u00e4steb\u00fcchern, Diskussionsforen, Linkverzeichnissen, Mailinglisten und in allen anderen Formen von Datenbanken, auf deren Inhalt externe Schreibzugriffe m\u00f6glich sind. F\u00fcr illegale, fehlerhafte oder unvollst\u00e4ndige Inhalte und insbesondere f\u00fcr Sch\u00e4den, die aus der Nutzung oder Nichtnutzung solcherart dargebotener Informationen entstehen, haftet allein der Anbieter der Seite, auf welche verwiesen wurde, nicht derjenige, der \u00fcber Links auf die jeweilige Ver\u00f6ffentlichung lediglich verweist.","title":"2. Verweise und Links"},{"location":"beyond/impressum.html#3-urheber-und-kennzeichenrecht","text":"Der Autor ist bestrebt, in allen Publikationen die Urheberrechte der verwendeten Bilder, Grafiken, Tondokumente, Videosequenzen und Texte zu beachten, von ihm selbst erstellte Bilder, Grafiken, Tondokumente, Videosequenzen und Texte zu nutzen oder auf lizenzfreie Grafiken, Tondokumente, Videosequenzen und Texte zur\u00fcckzugreifen. Alle innerhalb des Internetangebotes genannten und ggf. durch Dritte gesch\u00fctzten Marken- und Warenzeichen unterliegen uneingeschr\u00e4nkt den Bestimmungen des jeweils g\u00fcltigen Kennzeichenrechts und den Besitzrechten der jeweiligen eingetragenen Eigent\u00fcmer. Allein aufgrund der blo\u00dfen Nennung ist nicht der Schluss zu ziehen, dass Markenzeichen nicht durch Rechte Dritter gesch\u00fctzt sind! Das Copyright f\u00fcr ver\u00f6ffentlichte, vom Autor selbst erstellte Objekte bleibt allein beim Autor der Seiten. Eine Vervielf\u00e4ltigung oder Verwendung solcher Grafiken, Tondokumente, Videosequenzen und Texte in anderen elektronischen oder gedruckten Publikationen ist ohne ausdr\u00fcckliche Zustimmung des Autors nicht gestattet.","title":"3. Urheber- und Kennzeichenrecht"},{"location":"beyond/impressum.html#4-datenschutz","text":"Sofern innerhalb des Internetangebotes die M\u00f6glichkeit zur Eingabe pers\u00f6nlicher oder gesch\u00e4ftlicher Daten (Emailadressen, Namen, Anschriften) besteht, so erfolgt die Preisgabe dieser Daten seitens des Nutzers auf ausdr\u00fccklich freiwilliger Basis. Die Inanspruchnahme und Bezahlung aller angebotenen Dienste ist - soweit technisch m\u00f6glich und zumutbar - auch ohne Angabe solcher Daten bzw. unter Angabe anonymisierter Daten oder eines Pseudonyms gestattet. Die Nutzung der im Rahmen des Impressums oder vergleichbarer Angaben ver\u00f6ffentlichten Kontaktdaten wie Postanschriften, Telefon- und Faxnummern sowie Emailadressen durch Dritte zur \u00dcbersendung von nicht ausdr\u00fccklich angeforderten Informationen ist nicht gestattet. Rechtliche Schritte gegen die Versender von sogenannten Spam-Mails bei Verst\u00f6ssen gegen dieses Verbot sind ausdr\u00fccklich vorbehalten.","title":"4. Datenschutz"},{"location":"beyond/impressum.html#5-rechtswirksamkeit-dieses-haftungsausschlusses","text":"Dieser Haftungsausschluss ist als Teil des Internetangebotes zu betrachten, von dem aus auf diese Seite verwiesen wurde. Sofern Teile oder einzelne Formulierungen dieses Textes der geltenden Rechtslage nicht, nicht mehr oder nicht vollst\u00e4ndig entsprechen sollten, bleiben die \u00fcbrigen Teile des Dokumentes in ihrem Inhalt und ihrer G\u00fcltigkeit davon unber\u00fchrt.","title":"5. Rechtswirksamkeit dieses Haftungsausschlusses"},{"location":"beyond/links.html","text":"Python Ressourcen (online) Die offizielle Dokumentation: python.org: https://docs.python.org/2 dort Tutorial https://docs.python.org/2/tutorial andere Tutorials: tutorialspoint: http://www.tutorialspoint.com/python/index.htm python-kurs: http://www.python-kurs.eu/kurs.php online-Python-Lehrgang Code Academy: https://www.codecademy.com/learn/python checkio.org: http://www.checkio.org/profile/login/?next=/station/home/ Foren stackoverflow: http://stackoverflow.com/ GIS: http://gis.stackexchange.com/ Python Cheat-Sheets: astro.up.pt: http://www.astro.up.pt/~sousasag/Python_For_Astronomers/Python_qr.pdf ifi.lmu https://ddi.ifi.lmu.de/probestudium/2013/ws-i-3d-programmierung/tutorials/python-referenzkarte Python-Books: Think Python: http://www.greenteapress.com/thinkpython/html Dive into Python: http://www.diveintopython.net/toc QGIS: Offizielle Dokumentation Einf\u00fchrung in QGIS Grundlagen der Programmierung mit Python in QGIS PyQGIS Cookbook PyQGIS API qgistutorials PyQGIS-Books G. Sherman: The PyQGIS Programmer's Guide. Extending QGIS 3.x with Python 3 - Locate Press","title":"Links"},{"location":"beyond/links.html#python-ressourcen-online","text":"","title":"Python Ressourcen (online)"},{"location":"beyond/links.html#die-offizielle-dokumentation","text":"python.org: https://docs.python.org/2 dort Tutorial https://docs.python.org/2/tutorial andere Tutorials: tutorialspoint: http://www.tutorialspoint.com/python/index.htm python-kurs: http://www.python-kurs.eu/kurs.php","title":"Die offizielle Dokumentation:"},{"location":"beyond/links.html#online-python-lehrgang","text":"Code Academy: https://www.codecademy.com/learn/python checkio.org: http://www.checkio.org/profile/login/?next=/station/home/","title":"online-Python-Lehrgang"},{"location":"beyond/links.html#foren","text":"stackoverflow: http://stackoverflow.com/ GIS: http://gis.stackexchange.com/","title":"Foren"},{"location":"beyond/links.html#python-cheat-sheets","text":"astro.up.pt: http://www.astro.up.pt/~sousasag/Python_For_Astronomers/Python_qr.pdf ifi.lmu https://ddi.ifi.lmu.de/probestudium/2013/ws-i-3d-programmierung/tutorials/python-referenzkarte","title":"Python Cheat-Sheets:"},{"location":"beyond/links.html#python-books","text":"Think Python: http://www.greenteapress.com/thinkpython/html Dive into Python: http://www.diveintopython.net/toc","title":"Python-Books:"},{"location":"beyond/links.html#qgis","text":"Offizielle Dokumentation Einf\u00fchrung in QGIS Grundlagen der Programmierung mit Python in QGIS PyQGIS Cookbook PyQGIS API qgistutorials","title":"QGIS:"},{"location":"beyond/links.html#pyqgis-books","text":"G. Sherman: The PyQGIS Programmer's Guide. Extending QGIS 3.x with Python 3 - Locate Press","title":"PyQGIS-Books"},{"location":"beyond/themen.html","text":"Themen Grundlagen Python-Rezepte Python-Objektorientierung Datenverarbeitung Internet-Zugriffe \"Rest\"-Server Datenverarbeitung mit XML, JSON Datenbanken Benutzeroberfl\u00e4chen QT-Widgets mit pyqt4 Formulare und Anwendungen QGIS-Python-Plugins Anwedungsentwicklung Pegelonline-Plugin Plugin-Aufbau Datenbank-Integration","title":"Themen"},{"location":"beyond/themen.html#themen","text":"","title":"Themen"},{"location":"beyond/themen.html#grundlagen","text":"Python-Rezepte Python-Objektorientierung","title":"Grundlagen"},{"location":"beyond/themen.html#datenverarbeitung","text":"Internet-Zugriffe \"Rest\"-Server Datenverarbeitung mit XML, JSON Datenbanken","title":"Datenverarbeitung"},{"location":"beyond/themen.html#benutzeroberflachen","text":"QT-Widgets mit pyqt4 Formulare und Anwendungen QGIS-Python-Plugins","title":"Benutzeroberfl\u00e4chen"},{"location":"beyond/themen.html#anwedungsentwicklung","text":"Pegelonline-Plugin Plugin-Aufbau Datenbank-Integration","title":"Anwedungsentwicklung"},{"location":"ch01/oogeom.html","text":"OO-Pythonmodule f\u00fcr eine Kartenanwendung Aufbau Zwei Module als Grundlage. Zum einen ein Modul f\u00fcr die Geometrie, zum anderen ein Modul f\u00fcr Kartendarstellung (auf Basis der Matplotlib) Schema zu DrawMap und Geometry Modul geomet class Geometry: allgemeine Geometriedefinition class Point class LineString class Polygon ... .getGeom(): wird gerufen, um Tuple f\u00fcr Geometrie zu bekommen .extent.getPoints(): wird gerufen, um den Extent eines Layers/der Karte zu bestimmen .getDim(): wird gerufen, um die Tiefe eines Tuples zu bestimmen class Extent: Klasse f\u00fcr umgebende Rechtecke R\u00fcckblick: Was ist ein Polygon? Geometry als Point: (x,y) LineString: ((x1,y1), (x2,y3), ..., (xn,yn)) Ring: ((x1,y1), (x2,y3), ..., (xn,yn), (x1,y1)) Polygon: ((ring1), (ring2), ... (ringn)) Regeln f\u00fcr Polygone: Der erste Ring ist ein outer ring , Drehrichtung \"counter clockwise\", Fl\u00e4cheninhalt < 0 Folgende Ringe sind inner rings , Drehrichtung \"clockwise\", Fl\u00e4cheninhalt > 0 Beispiele id=1 single-part without interior ring id=2 single-part with interior ring id=3 multi-part without interior rings id=4 multi-part with interior rings Ausserdem gilt: MultiGeometrien haben parts Ein MultiPolygon besteht aus mehreren Polygonen Ein MultiLine besteht aus mehreren LineStrings Modul DrawMap class Style: allgemeine Styledefinition, daraus abgeleitet: class PointStyle class LineStyle class PolyStyle findSymByName(...): -> matplotlib: Symboldefinition besorgen class MapLayer: Menge von Geometrien eines Typs, werden in DrawMap benutzt draw(): alle Geometrien eines Layers zeichnen addClass(geometries, style): eine Klasse mit Geometrien, welche dieselben Zeichenmerkmalen aufweisen, hinzuf\u00fcgen class DrawMap: Karte mit mehreren Layern addLayer(layer_object): MapLayer-Objekt hinzuf\u00fcgen, Zeichnungsreihenfolge fifo drawAll(): alle Layer zeichnen, ruft layer.draw() show(): das Kartenfenster (matplotlib) anzeigen Abh\u00e4ngigkeiten zwischen DrawMap und Geometry Abh\u00e4ngigkeiten zwischen DrawMap und Style Implementierung des Moduls geomet In diesem Modul sollen die aufgezeigten Klassen/Funktionen f\u00fcr die Geometrie implementiert werden. Jede Geometrie wird aus Tupeln aufgebaut, und auf G\u00fcltigkeit getestet Punkt-Objekte werden nicht in anderen Geometrien verwendet Hilfsfunktionen: test_dim(): Tiefe eines Tuples, die Funktion liefert f\u00fcr Punkt-Koordinaten: (x,y), Tiefe 1 Linestring-Koordinaten: ((x1,y1),(x2,y2),...(xn,yn)), Tiefe: 2 Ring-Koordinaten: wie Linestring, aber geschlossen, Tiefe: 2 Polygon-Koordinaten: (((x11,y11),(x12,y12),...(x1n,y1n),(x11,y11)),((x21,y21),(x22,y22),...(x2n,y2n),(x21,y21))), Tiefe: 3 Multi-Linestring: Tuple mit mehreren Linestrings, Tiefe: 3 Multi-Polygons: Tuple mit mehreren Polygons, Tiefe: 4 signed_area(): testet einen Ring auf Drehrichtung und gibt Fl\u00e4cheninhalt zur\u00fcck reverseLineString(): dreht die Reihenfolge der Punkte in einem Linestring oder Ring um def test_dim(testlist, dim=0): \"\"\"tests if testlist is a list and how many dimensions it has. Returns -1 if it is no list at all, 0 if list is empty and otherwise the dimensions of it\"\"\" if isinstance(testlist, (list, tuple)): if not testlist: return dim dim = dim + 1 dim = test_dim(testlist[0], dim) return dim else: if dim == 0: return -1 else: return dim def reverseLineString(linestring): \"\"\"helper-function to turn the direction of line strings ((x1,y1),...(xn, yn)), returns the reversed linestring\"\"\" temp = list(linestring) temp.reverse() return tuple(temp) def signed_area(coords): \"\"\"Return the signed area enclosed by a ring using the linear time algorithm at http://www.cgafaq.info/wiki/Polygon_Area. A value >= 0 indicates a counter-clockwise oriented ring. Gibt 0 zurueck, wenn Polygon nicht geschlossen ist!\"\"\" xs, ys = map(list, zip(*coords)) xs.append(xs[1]) ys.append(ys[1]) return sum(xs[i]*(ys[i+1]-ys[i-1]) for i in range(1, len(coords)))/2.0 Allgemeine Hilfsfunktionen Die grundlegenden Klassen des Moduls: Geometry Die Klasse Geometry ist die Basis-Klasse und definiert alle gemeinsamen Eigenschaften und Methoden. Eigenschaften Koordinatenwerte werden als _coords gespeichert Umgebendes Rechteck ist extent mit eigener Klasse, s.u. Dimension oder Tiefe der Koordinatenwerte wird als dim gespeichert Methoden setGeom() : speichert die Koordinatenwerte getGeom() : gibt die gespeicherten Koordinatenwerte zur\u00fcck _test() : testet, ob Koordinatenwerte g\u00fcltig sind class Geometry(object): \"\"\"abstract class for all geometry classes. Coordinate data is stored as a tuple. For points use (x,y), for linestrings use a tuple of points (point1, point2, ) and so on\"\"\" def __init__(self): # coordinate data self._coords = () # depth (dimension of tuple) self.dim = 0 # Minimal rectangular extent of geom self.extent = None def getGeom(self): \"\"\"get coordinate data: returns the geometry as a tuple\"\"\" return self._coords # should be overloaded def setGeom(self, coords): \"\"\"store the coordinate data: needs a tuple\"\"\" self._test(coords) if self.dim > 0: self._coords = coords self.extent = Extent(coords) def _test(self, coords): \"\"\"get depth of coordinate data\"\"\" self.dim = test_dim(coords) Extent Die Klasse Extent berechnet ein umgebendes Rechteck aus einem Linestring oder Ring Eigenschaften: left: kleinster x-Wert right: gr\u00f6\u00dfter x-Wert bottom: kleinster y-Wert top: gr\u00f6\u00dfter y-Wert width: Breite height: H\u00f6he Methoden: getPoints(): Rechteck-Tuple als Linestring _calcExtent(): Berechnung des Rechtecks class Extent(object): def __init__(self, coords=None): # self-Variablen vorbelegen self.left = 0 self.right = 0 self.bottom = 0 self.top = 0 self.width = 0 self.height = 0 # only linesstring or ring is accepted if test_dim(coords) == 2: self._calcExtent(coords) def _calcExtent(self, coords): if not coords: return x,y = zip(*coords) self.left= min(x) self.right= max(x) self.bottom = min(y) self.top = max(y) self.width = self.right - self.left self.height = self.top - self.bottom return (self.left, self.bottom, self.right, self.top) def getPoints(self): return ((self.left,self.bottom), (self.left, self.top), (self.right, self.top), (self.right, self.bottom)) Anmerkung: Die Klasse h\u00e4tte auch aus der Klasse Geometry abgeleitet werden k\u00f6nnen! Points Erbt Methoden und Eigenschaften der Klasse Geometry , \u00c4nderungen gegen\u00fcber Geometry: __init__() : akzeptiert Tupel als Argument setGeom() : \u00fcberladen, um auf punktspezifische Dinge zu testen. Erzeugt ValueError bei falschem Tuple setXY() : zus\u00e4tzliche Methode, um Punkt \u00fcber x- und y-Wert zu erzeugen class Point(Geometry): def __init__(self, point=()): Geometry.__init__(self) if point: self.setGeom(point) # overloaded def setGeom(self, point): \"\"\"store the coordinate data: needs a point tuple (x,y)\"\"\" # test is tuple contains point coordinates self._test(point) if self.dim == 1: self._coords = point # get a valid extent self.extent = Extent((point, point)) else: raise ValueError(\"ERR: Could not set coordinate data: not a Point: %s\"%point) def setXY(self, x, y): self.setGeom((x, y)) LineString Zun\u00e4chst verallgemeinern wir in der Klasse Geometry den Fehler-String, da er in unseren Klassen immer in der derselben Form benutzt werden wird. class Geometry(object): #... def __init__(self): #... # errorstring for coord test %s and %s will be class name and coord data self._errstring = \"ERR: Could not set coordinate data: not a %s: %s\" LineString erbt Methoden und Eigenschaften der Klasse Geometry , Aufbau folgt dem von Point , ValueError benutzt dann den allgemeinen Error-String class LineString(Geometry): def __init__(self, coords=()): Geometry.__init__(self) if coords: self.setGeom(coords) def setGeom(self, coords): \"\"\"store the coordinate data: needs a linestring tuple ((x1,y1), (x2,y2), ..., (xn,yn) )\"\"\" self._test(coords) if self.dim == 2: self._coords = coords # extent berechnen self.extent = Extent(coords) else: raise ValueError(self._errstring%(self.__class__.__name__,coords)) Die Fehlermeldung benutzt den Ausdruck self.__class__.__name__ , dies entspricht dem Namen der Klasse (Point, LineString etc.), diese \u00c4nderung des Error-String \u00fcbernehmen wir auch f\u00fcr die Klasse Point : class Point(Geometry): # ... def setGeom(self, point): # ... else: raise ValueError(self._errstring%(self.__class__.__name__,point)) Ring Der Ring erbt nicht von Geometry, sondern wegen der gro\u00dfen \u00c4hnlichkeit, von der Klasse LineString. Hierbei k\u00f6nnen wir uns die bereits programmierte \u00dcberpr\u00fcfung der Koordinaten zunutze machen: class Ring(LineString): def __init__(self, coords=()): LineString.__init__(self, coords) def setGeom(self, coords): # check like in LineString LineString.setGeom(self, coords) # plus: check if ring is closed: if self._coords[0] != self._coords[-1]: print(\"WARNING: Ring is not closed!\") Der Ausdruck LineString.setGeom ruft die Funktion der \u00fcbergeordneten Klasse auf. Hier muss, analog zu __init__ , auch self mit \u00fcbergeben werden! Statt eines \"warnings\" am Ende der Methode setGeom() k\u00f6nnte auch hier ein Fehler aufgerufen werden! Aber manche weitere Algorithmen und Funktionen k\u00f6nnen auch mit nicht geschlossenen Ringen umgehen... oder wir setzen die Hilfsfunktion closeRing() ein, um den Fehler zu korrigieren. Tests zum Modul geomet Testen Sie die Klassen mit verschiedenen Geometrien. # Punkt coords = (238.968,-248.829) # teste test_dim, Extent, Geometry, Point # LineString coords = ((186.86734599332530138,-330.01102525246926689),(281.02152260430347042,-334.20601331929503885),(380.16725392010351925,-233.1784919062212964)) # teste wie oben, aber mit LineString anstelle von Point # funktioniert auch mit Ring? Teste mit und ohne closeRing() An dieser Stelle beenden wir die Arbeit an dem Modul als Ein-Dateien-Modul , da der Code zur Bearbeitung sonst zu lang und \u00fcbersichtlich wird. Wir schauen uns zur weiteren Vorgehenswese den Aufbau eines Packages an, also eine Aufteilung in kleinen Modulen, die in einem Ordner organisert sind. Python Package f\u00fcr das geomet-Modul Wir erstellen einen Ordner geomet und darin eine Datei __init__.py . Die vorhandenen Klassen und Hilfsfunktionen speichern wir in gesonderten Dateien ab, z.B.: helper.py f\u00fcr die Hilfsfunktionen extent.py f\u00fcr die Klasse Extent geometry.py f\u00fcr die Klasse Geometry die anderen Klassen ebenso ... imports innerhalb des Packages \u00dcber die imports m\u00fcssen wir nun die Abh\u00e4ngkeiten zwischen den Modulen herstellen, was im Ein-Datei-Modul nicht n\u00f6tig war. Die Hilfsfunktionen helper haben keine Abh\u00e4nkeiten Extent nutzt helper , muss dort importiert werden Geometrie nutzt helper und Extent usw. Der Import dieser Submodule erfolgt relativ, d.h. immer mit dem Bezug zum Package. Hier am Beispiel der Klasse Extent in extent.py: # extent.py from geomet.helper import * import des Packages Um nun das Package in einem externen Modul zu testen, m\u00fcssen wir es dort importieren. Dies k\u00f6nnen wir erleichtern, wenn wir auf der Ebene des geomet/__init__.py bereits die Untermodule importieren: from geomet.helper import * from geomet.extent import Extent from geomet.geometry import Geometry from geomet.point import Point from geomet.linestring import LineString from geomet.ring import Ring Dann ben\u00f6tigen wir bei einem import von geomet und seinen Untermodulen nur noch zu schreiben: # Klassen stehen im Namensraum direkt zur Verf\u00fcgung from geomet import * # Beispiel: # p = Point() # oder: import geomet # Klassen und funktionn bleiben im Namensraum von geomet: # p = geomet.Point() weitere Klassen f\u00fcr geomet Polygon MultiLine MultiPolygon Hinweise zur Implementierung getGeom() soll immer die Koordinaten-Daten in Tuple-Darstellung zur\u00fcckgeben! Vermeiden Sie m\u00f6glichst doppelten Code! Polygon erbt von Geometry bekommt eigene Methode addRing() , die von setGeom() genutzt wird addRing() testet jeden Ring auf korrekte Drehrichtung, nutzt ggf. reverseLineString zur Korrektur MultiLine erbt von Geometry erh\u00e4lt eine Methode addPart() , die von setGeom() genutzt wird \u00fcberlegen Sie, ob eine MultiLine mehrere LineString-Objekte als parts speichert oder bei der Speicherung lediglich die Darstellung als Tuple beibeh\u00e4lt. Im ersteren Fall \u00e4ndert sich der Abruf der Geometrie in getGeom. MultiPolygon erbt von Geometry erh\u00e4lt ebenso addPart(), um eine Sammlung von Polygonen als parts zu bekommen. Auch hier stellt sich die Frage, in wie weit die Klasse Polygon hier eingesetzt werden kann. Gro\u00dfer Test Darstellung der Testdaten mit dem drawmap-Modul Hier finden Sie die Tuple-Darstellungen der Geometrien. Die Klassen benutzen in den Methoden immer die \u00dcbergabe von Tupeln und nicht von LineString-, Ring-, oder Polygon-Objekten def test(): # construction: a single Polygon (one ring) ring = tuple([(302.26527684595293977, -145.75348499567942895),(372.61030054263540023, -137.42315324212492555), (382.32902092178233033, -172.13286888193533741),(496.78734703239143755, -172.08424826858774281), (499.4164616800761678, -130.01841390563203049),(558.6543763720193283, -133.72078357387846381), (568.83589295969704835, -248.03144708098747628),(564.67072708291971139, -285.0551437634519516), (542.45650907344111147, -298.47623381084531502),(495.25129580329894452, -291.53429068288323833), (412.87357068481549049, -246.643058455395078),(350.85887874168747658, -199.43784518525288263), (302.26527684595293977, -145.75348499567942895)]) # add the ring to a tuple poly2 = tuple([ring]) poly2 = Polygon(poly2) # nested tuple with simple polygon, two rings: outer ring and two inner rings (hole) poly3 = (((178,-199),(294,-152),(372,-236),(278,-325),(187,-326),(178,-199)), ((252.74608253315653883,-243.40348499567934937),(253.13780082570139029,-225.44446488989345312), (210.63162755685320349,-230.44519115681680432),(213.4084048080380569,-254.0477977918878878), (228.2178834810238186,-273.94803475871253795),(282.82783608765890904,-269.32007267340446788), (252.74608253315653883,-243.40348499567934937)), ((262.37713119618894098,-219.77606105199234321),(266.10600947781182413,-239.35267203051256502), (294.07259658998356144,-261.72594172024992076),(324.36973262816962915,-247.27653837896122013), (300.59813358282360696,-225.83548825962955675),(294.53870637518645026,-203.46221856989217258), (262.37713119618894098,-219.77606105199234321))) poly3 = Polygon(poly3) # two parts, each with one outer ring poly4 = ((((287.91859438149782591,-335.03713428477897196),(378.62665125353572648,-240.62670774449458122), (485.99537163268269069,-301.71580727056095839),(510.98636689334614402,-347.06983570657990867), (538.75413940519445077,-502.56936177293061974),(484.14418679855941718,-499.79258452174576632), (457.30200670377269034,-380.39116272079792225),(370.29631949998122309,-377.61438546961306884), (402.69205409713759991,-316.52528594354674851),(365.66835741467315302,-306.34376935586897162), (320.31432897865420273,-370.20964613312020219),(287.91859438149782591,-335.03713428477897196)),), (((274.96030054263525244,-342.4418736212718386),(311.98399722509969934,-379.4655703037362855), (268.94394983173475566,-422.50561769710122917),(184.25224367059732344,-337.81391153596376853), (187.02902092178214843,-335.03713428477897196),(274.96030054263525244,-342.4418736212718386)),)) poly4 = MultiPolygon(poly4) # use the polygon method addRing(): p1 = Polygon() p1.addRing( ((321.52641810650015941,-385.52558314627935943),(357.71607808855492294,-382.53470215602692406), (450.82285978434140361,-386.87030964022920898),(473.96267021088169713,-498.86699210468418642), (380.76171029810586788,-518.12338878087757621),(285.14181713031297249,-516.45324802885477311), (218.49916310187694535,-486.83429068288319286),(209.24323893126086205,-469.24803475871260616), (216.64797826775372869,-443.33144708098745923),(240.71338111135560212,-424.81959873975523578), (275.88589295969683235,-429.44756082506330586),(321.52641810650015941,-385.52558314627935943)) ) p1.addRing( ((275.88589295969683235,-441.48026224686429941),(244.41575077960209228,-435.92670774449459259), (228.6806796895546654,-449.81059400041874596),(228.6806796895546654,-465.54566509046617284), (245.34134319666367219,-484.05751343169833945),(274.03470812557361569,-493.31343760231447959), (324.01669864690063605,-498.86699210468418642),(376.77546641941250982,-492.38784518525289968), (391.58494509239829995,-470.17362717577418607),(389.73376025827508329,-441.48026224686429941), (365.66835741467315302,-421.11722907150880246),(337.90058490282484627,-414.63808215207751573), (315.60443879742075524,-409.43564806081656116),(315.68636689334613266,-409.08452764970786575), (275.88589295969683235,-441.48026224686429941)) ) p2 = Polygon() p2.addRing( ((361.27016520072675121,-376.7665935641414876), (328.98417466974592571,-374.33894830141070997),(371.22191191704285984,-312.82291627530025835), (394.36172234358309652,-321.15324802885476174),(361.27016520072675121,-376.7665935641414876)) ) p3 = Polygon() p3.addRing( ((275.88589295969683235,-455.36414850278845279),(342.75289231998959849,-442.08747236662020441), (346.23091665637934966,-484.98310584876003304),(311.98399722509969934,-487.75988309994488645), (275.88589295969683235,-481.28073618051359972),(275.88589295969683235,-455.36414850278845279)) ) poly5 = MultiPolygon() poly5.addPart(p1.getGeom()) poly5.addPart(p2.getGeom()) poly5.addPart(p3.getGeom()) l1 = MultiLine( (((186.86734599332530138,-330.01102525246926689),(281.02152260430347042,-334.20601331929503885),(380.16725392010351925,-233.1784919062212964)),)) l2 = MultiLine( (((298.38411210311005561,-148.6943188085558063),(351.63715506253709009,-206.8415145126128607),(380.16725392010351925,-233.1784919062212964), (422.01973262816943588,-259.16233790163414596),(492.40231019380161115,-297.84945007347175761),(522.2333364467847332,-341.66376988254080516), (544.6066061365220321,-475.90338802096505333)),) ) l3 = MultiLine( (((245.16397476845918391,-416.3710923394440897),(271.43529456551368639,-425.78911264404854364),(320.83859405808800602,-377.5424121362502774)), ((320.83859405808800602,-377.5424121362502774),(367.51562451511898644,-310.29444259284662166),(397.25674126650147855,-318.88632076546821281), (365.94595446435147323,-379.69038167940567519)), ((320.83859405808800602,-377.5424121362502774),(334.22209659621012179,-379.52515325300907989),(365.94595446435147323,-379.69038167940567519)), ((365.94595446435147323,-379.69038167940567519),(454.17793416011954832,-383.82109233931993231),(478.79696969320832522,-499.06791975092721714))) ) orte = [Point((238.968,-248.829)), Point((271.353,-308.312)), Point((242.933,-363.828)), Point((320.839,-377.542)), Point((365.863,-344.001)), Point((382.386,-275.266)), Point((462.357,-347.306)), Point((310.347,-466.27)), Point((422.702,-451.73)), Point((528.448,-318.886))] return (orte, (l1,l2,l3), (poly2, poly3, poly4, poly5)) Die Funktion test() kann auch in __init__.py implementiert werden!","title":"OO-Pythonmodule f\u00fcr eine Kartenanwendung"},{"location":"ch01/oogeom.html#oo-pythonmodule-fur-eine-kartenanwendung","text":"","title":"OO-Pythonmodule f\u00fcr eine Kartenanwendung"},{"location":"ch01/oogeom.html#aufbau","text":"Zwei Module als Grundlage. Zum einen ein Modul f\u00fcr die Geometrie, zum anderen ein Modul f\u00fcr Kartendarstellung (auf Basis der Matplotlib) Schema zu DrawMap und Geometry","title":"Aufbau"},{"location":"ch01/oogeom.html#modul-geomet","text":"class Geometry: allgemeine Geometriedefinition class Point class LineString class Polygon ... .getGeom(): wird gerufen, um Tuple f\u00fcr Geometrie zu bekommen .extent.getPoints(): wird gerufen, um den Extent eines Layers/der Karte zu bestimmen .getDim(): wird gerufen, um die Tiefe eines Tuples zu bestimmen class Extent: Klasse f\u00fcr umgebende Rechtecke R\u00fcckblick: Was ist ein Polygon? Geometry als Point: (x,y) LineString: ((x1,y1), (x2,y3), ..., (xn,yn)) Ring: ((x1,y1), (x2,y3), ..., (xn,yn), (x1,y1)) Polygon: ((ring1), (ring2), ... (ringn)) Regeln f\u00fcr Polygone: Der erste Ring ist ein outer ring , Drehrichtung \"counter clockwise\", Fl\u00e4cheninhalt < 0 Folgende Ringe sind inner rings , Drehrichtung \"clockwise\", Fl\u00e4cheninhalt > 0 Beispiele id=1 single-part without interior ring id=2 single-part with interior ring id=3 multi-part without interior rings id=4 multi-part with interior rings Ausserdem gilt: MultiGeometrien haben parts Ein MultiPolygon besteht aus mehreren Polygonen Ein MultiLine besteht aus mehreren LineStrings","title":"Modul geomet"},{"location":"ch01/oogeom.html#modul-drawmap","text":"class Style: allgemeine Styledefinition, daraus abgeleitet: class PointStyle class LineStyle class PolyStyle findSymByName(...): -> matplotlib: Symboldefinition besorgen class MapLayer: Menge von Geometrien eines Typs, werden in DrawMap benutzt draw(): alle Geometrien eines Layers zeichnen addClass(geometries, style): eine Klasse mit Geometrien, welche dieselben Zeichenmerkmalen aufweisen, hinzuf\u00fcgen class DrawMap: Karte mit mehreren Layern addLayer(layer_object): MapLayer-Objekt hinzuf\u00fcgen, Zeichnungsreihenfolge fifo drawAll(): alle Layer zeichnen, ruft layer.draw() show(): das Kartenfenster (matplotlib) anzeigen Abh\u00e4ngigkeiten zwischen DrawMap und Geometry Abh\u00e4ngigkeiten zwischen DrawMap und Style","title":"Modul DrawMap"},{"location":"ch01/oogeom.html#implementierung-des-moduls-geomet","text":"In diesem Modul sollen die aufgezeigten Klassen/Funktionen f\u00fcr die Geometrie implementiert werden. Jede Geometrie wird aus Tupeln aufgebaut, und auf G\u00fcltigkeit getestet Punkt-Objekte werden nicht in anderen Geometrien verwendet Hilfsfunktionen: test_dim(): Tiefe eines Tuples, die Funktion liefert f\u00fcr Punkt-Koordinaten: (x,y), Tiefe 1 Linestring-Koordinaten: ((x1,y1),(x2,y2),...(xn,yn)), Tiefe: 2 Ring-Koordinaten: wie Linestring, aber geschlossen, Tiefe: 2 Polygon-Koordinaten: (((x11,y11),(x12,y12),...(x1n,y1n),(x11,y11)),((x21,y21),(x22,y22),...(x2n,y2n),(x21,y21))), Tiefe: 3 Multi-Linestring: Tuple mit mehreren Linestrings, Tiefe: 3 Multi-Polygons: Tuple mit mehreren Polygons, Tiefe: 4 signed_area(): testet einen Ring auf Drehrichtung und gibt Fl\u00e4cheninhalt zur\u00fcck reverseLineString(): dreht die Reihenfolge der Punkte in einem Linestring oder Ring um def test_dim(testlist, dim=0): \"\"\"tests if testlist is a list and how many dimensions it has. Returns -1 if it is no list at all, 0 if list is empty and otherwise the dimensions of it\"\"\" if isinstance(testlist, (list, tuple)): if not testlist: return dim dim = dim + 1 dim = test_dim(testlist[0], dim) return dim else: if dim == 0: return -1 else: return dim def reverseLineString(linestring): \"\"\"helper-function to turn the direction of line strings ((x1,y1),...(xn, yn)), returns the reversed linestring\"\"\" temp = list(linestring) temp.reverse() return tuple(temp) def signed_area(coords): \"\"\"Return the signed area enclosed by a ring using the linear time algorithm at http://www.cgafaq.info/wiki/Polygon_Area. A value >= 0 indicates a counter-clockwise oriented ring. Gibt 0 zurueck, wenn Polygon nicht geschlossen ist!\"\"\" xs, ys = map(list, zip(*coords)) xs.append(xs[1]) ys.append(ys[1]) return sum(xs[i]*(ys[i+1]-ys[i-1]) for i in range(1, len(coords)))/2.0 Allgemeine Hilfsfunktionen Die grundlegenden Klassen des Moduls:","title":"Implementierung des Moduls geomet"},{"location":"ch01/oogeom.html#geometry","text":"Die Klasse Geometry ist die Basis-Klasse und definiert alle gemeinsamen Eigenschaften und Methoden. Eigenschaften Koordinatenwerte werden als _coords gespeichert Umgebendes Rechteck ist extent mit eigener Klasse, s.u. Dimension oder Tiefe der Koordinatenwerte wird als dim gespeichert Methoden setGeom() : speichert die Koordinatenwerte getGeom() : gibt die gespeicherten Koordinatenwerte zur\u00fcck _test() : testet, ob Koordinatenwerte g\u00fcltig sind class Geometry(object): \"\"\"abstract class for all geometry classes. Coordinate data is stored as a tuple. For points use (x,y), for linestrings use a tuple of points (point1, point2, ) and so on\"\"\" def __init__(self): # coordinate data self._coords = () # depth (dimension of tuple) self.dim = 0 # Minimal rectangular extent of geom self.extent = None def getGeom(self): \"\"\"get coordinate data: returns the geometry as a tuple\"\"\" return self._coords # should be overloaded def setGeom(self, coords): \"\"\"store the coordinate data: needs a tuple\"\"\" self._test(coords) if self.dim > 0: self._coords = coords self.extent = Extent(coords) def _test(self, coords): \"\"\"get depth of coordinate data\"\"\" self.dim = test_dim(coords)","title":"Geometry"},{"location":"ch01/oogeom.html#extent","text":"Die Klasse Extent berechnet ein umgebendes Rechteck aus einem Linestring oder Ring Eigenschaften: left: kleinster x-Wert right: gr\u00f6\u00dfter x-Wert bottom: kleinster y-Wert top: gr\u00f6\u00dfter y-Wert width: Breite height: H\u00f6he Methoden: getPoints(): Rechteck-Tuple als Linestring _calcExtent(): Berechnung des Rechtecks class Extent(object): def __init__(self, coords=None): # self-Variablen vorbelegen self.left = 0 self.right = 0 self.bottom = 0 self.top = 0 self.width = 0 self.height = 0 # only linesstring or ring is accepted if test_dim(coords) == 2: self._calcExtent(coords) def _calcExtent(self, coords): if not coords: return x,y = zip(*coords) self.left= min(x) self.right= max(x) self.bottom = min(y) self.top = max(y) self.width = self.right - self.left self.height = self.top - self.bottom return (self.left, self.bottom, self.right, self.top) def getPoints(self): return ((self.left,self.bottom), (self.left, self.top), (self.right, self.top), (self.right, self.bottom)) Anmerkung: Die Klasse h\u00e4tte auch aus der Klasse Geometry abgeleitet werden k\u00f6nnen!","title":"Extent"},{"location":"ch01/oogeom.html#points","text":"Erbt Methoden und Eigenschaften der Klasse Geometry , \u00c4nderungen gegen\u00fcber Geometry: __init__() : akzeptiert Tupel als Argument setGeom() : \u00fcberladen, um auf punktspezifische Dinge zu testen. Erzeugt ValueError bei falschem Tuple setXY() : zus\u00e4tzliche Methode, um Punkt \u00fcber x- und y-Wert zu erzeugen class Point(Geometry): def __init__(self, point=()): Geometry.__init__(self) if point: self.setGeom(point) # overloaded def setGeom(self, point): \"\"\"store the coordinate data: needs a point tuple (x,y)\"\"\" # test is tuple contains point coordinates self._test(point) if self.dim == 1: self._coords = point # get a valid extent self.extent = Extent((point, point)) else: raise ValueError(\"ERR: Could not set coordinate data: not a Point: %s\"%point) def setXY(self, x, y): self.setGeom((x, y))","title":"Points"},{"location":"ch01/oogeom.html#linestring","text":"Zun\u00e4chst verallgemeinern wir in der Klasse Geometry den Fehler-String, da er in unseren Klassen immer in der derselben Form benutzt werden wird. class Geometry(object): #... def __init__(self): #... # errorstring for coord test %s and %s will be class name and coord data self._errstring = \"ERR: Could not set coordinate data: not a %s: %s\" LineString erbt Methoden und Eigenschaften der Klasse Geometry , Aufbau folgt dem von Point , ValueError benutzt dann den allgemeinen Error-String class LineString(Geometry): def __init__(self, coords=()): Geometry.__init__(self) if coords: self.setGeom(coords) def setGeom(self, coords): \"\"\"store the coordinate data: needs a linestring tuple ((x1,y1), (x2,y2), ..., (xn,yn) )\"\"\" self._test(coords) if self.dim == 2: self._coords = coords # extent berechnen self.extent = Extent(coords) else: raise ValueError(self._errstring%(self.__class__.__name__,coords)) Die Fehlermeldung benutzt den Ausdruck self.__class__.__name__ , dies entspricht dem Namen der Klasse (Point, LineString etc.), diese \u00c4nderung des Error-String \u00fcbernehmen wir auch f\u00fcr die Klasse Point : class Point(Geometry): # ... def setGeom(self, point): # ... else: raise ValueError(self._errstring%(self.__class__.__name__,point))","title":"LineString"},{"location":"ch01/oogeom.html#ring","text":"Der Ring erbt nicht von Geometry, sondern wegen der gro\u00dfen \u00c4hnlichkeit, von der Klasse LineString. Hierbei k\u00f6nnen wir uns die bereits programmierte \u00dcberpr\u00fcfung der Koordinaten zunutze machen: class Ring(LineString): def __init__(self, coords=()): LineString.__init__(self, coords) def setGeom(self, coords): # check like in LineString LineString.setGeom(self, coords) # plus: check if ring is closed: if self._coords[0] != self._coords[-1]: print(\"WARNING: Ring is not closed!\") Der Ausdruck LineString.setGeom ruft die Funktion der \u00fcbergeordneten Klasse auf. Hier muss, analog zu __init__ , auch self mit \u00fcbergeben werden! Statt eines \"warnings\" am Ende der Methode setGeom() k\u00f6nnte auch hier ein Fehler aufgerufen werden! Aber manche weitere Algorithmen und Funktionen k\u00f6nnen auch mit nicht geschlossenen Ringen umgehen... oder wir setzen die Hilfsfunktion closeRing() ein, um den Fehler zu korrigieren.","title":"Ring"},{"location":"ch01/oogeom.html#tests-zum-modul-geomet","text":"Testen Sie die Klassen mit verschiedenen Geometrien. # Punkt coords = (238.968,-248.829) # teste test_dim, Extent, Geometry, Point # LineString coords = ((186.86734599332530138,-330.01102525246926689),(281.02152260430347042,-334.20601331929503885),(380.16725392010351925,-233.1784919062212964)) # teste wie oben, aber mit LineString anstelle von Point # funktioniert auch mit Ring? Teste mit und ohne closeRing() An dieser Stelle beenden wir die Arbeit an dem Modul als Ein-Dateien-Modul , da der Code zur Bearbeitung sonst zu lang und \u00fcbersichtlich wird. Wir schauen uns zur weiteren Vorgehenswese den Aufbau eines Packages an, also eine Aufteilung in kleinen Modulen, die in einem Ordner organisert sind.","title":"Tests zum Modul geomet"},{"location":"ch01/oogeom.html#python-package-fur-das-geomet-modul","text":"Wir erstellen einen Ordner geomet und darin eine Datei __init__.py . Die vorhandenen Klassen und Hilfsfunktionen speichern wir in gesonderten Dateien ab, z.B.: helper.py f\u00fcr die Hilfsfunktionen extent.py f\u00fcr die Klasse Extent geometry.py f\u00fcr die Klasse Geometry die anderen Klassen ebenso ...","title":"Python Package f\u00fcr das geomet-Modul"},{"location":"ch01/oogeom.html#imports-innerhalb-des-packages","text":"\u00dcber die imports m\u00fcssen wir nun die Abh\u00e4ngkeiten zwischen den Modulen herstellen, was im Ein-Datei-Modul nicht n\u00f6tig war. Die Hilfsfunktionen helper haben keine Abh\u00e4nkeiten Extent nutzt helper , muss dort importiert werden Geometrie nutzt helper und Extent usw. Der Import dieser Submodule erfolgt relativ, d.h. immer mit dem Bezug zum Package. Hier am Beispiel der Klasse Extent in extent.py: # extent.py from geomet.helper import *","title":"imports innerhalb des Packages"},{"location":"ch01/oogeom.html#import-des-packages","text":"Um nun das Package in einem externen Modul zu testen, m\u00fcssen wir es dort importieren. Dies k\u00f6nnen wir erleichtern, wenn wir auf der Ebene des geomet/__init__.py bereits die Untermodule importieren: from geomet.helper import * from geomet.extent import Extent from geomet.geometry import Geometry from geomet.point import Point from geomet.linestring import LineString from geomet.ring import Ring Dann ben\u00f6tigen wir bei einem import von geomet und seinen Untermodulen nur noch zu schreiben: # Klassen stehen im Namensraum direkt zur Verf\u00fcgung from geomet import * # Beispiel: # p = Point() # oder: import geomet # Klassen und funktionn bleiben im Namensraum von geomet: # p = geomet.Point()","title":"import des Packages"},{"location":"ch01/oogeom.html#weitere-klassen-fur-geomet","text":"Polygon MultiLine MultiPolygon Hinweise zur Implementierung getGeom() soll immer die Koordinaten-Daten in Tuple-Darstellung zur\u00fcckgeben! Vermeiden Sie m\u00f6glichst doppelten Code!","title":"weitere Klassen f\u00fcr geomet"},{"location":"ch01/oogeom.html#polygon","text":"erbt von Geometry bekommt eigene Methode addRing() , die von setGeom() genutzt wird addRing() testet jeden Ring auf korrekte Drehrichtung, nutzt ggf. reverseLineString zur Korrektur","title":"Polygon"},{"location":"ch01/oogeom.html#multiline","text":"erbt von Geometry erh\u00e4lt eine Methode addPart() , die von setGeom() genutzt wird \u00fcberlegen Sie, ob eine MultiLine mehrere LineString-Objekte als parts speichert oder bei der Speicherung lediglich die Darstellung als Tuple beibeh\u00e4lt. Im ersteren Fall \u00e4ndert sich der Abruf der Geometrie in getGeom.","title":"MultiLine"},{"location":"ch01/oogeom.html#multipolygon","text":"erbt von Geometry erh\u00e4lt ebenso addPart(), um eine Sammlung von Polygonen als parts zu bekommen. Auch hier stellt sich die Frage, in wie weit die Klasse Polygon hier eingesetzt werden kann.","title":"MultiPolygon"},{"location":"ch01/oogeom.html#groer-test","text":"Darstellung der Testdaten mit dem drawmap-Modul Hier finden Sie die Tuple-Darstellungen der Geometrien. Die Klassen benutzen in den Methoden immer die \u00dcbergabe von Tupeln und nicht von LineString-, Ring-, oder Polygon-Objekten def test(): # construction: a single Polygon (one ring) ring = tuple([(302.26527684595293977, -145.75348499567942895),(372.61030054263540023, -137.42315324212492555), (382.32902092178233033, -172.13286888193533741),(496.78734703239143755, -172.08424826858774281), (499.4164616800761678, -130.01841390563203049),(558.6543763720193283, -133.72078357387846381), (568.83589295969704835, -248.03144708098747628),(564.67072708291971139, -285.0551437634519516), (542.45650907344111147, -298.47623381084531502),(495.25129580329894452, -291.53429068288323833), (412.87357068481549049, -246.643058455395078),(350.85887874168747658, -199.43784518525288263), (302.26527684595293977, -145.75348499567942895)]) # add the ring to a tuple poly2 = tuple([ring]) poly2 = Polygon(poly2) # nested tuple with simple polygon, two rings: outer ring and two inner rings (hole) poly3 = (((178,-199),(294,-152),(372,-236),(278,-325),(187,-326),(178,-199)), ((252.74608253315653883,-243.40348499567934937),(253.13780082570139029,-225.44446488989345312), (210.63162755685320349,-230.44519115681680432),(213.4084048080380569,-254.0477977918878878), (228.2178834810238186,-273.94803475871253795),(282.82783608765890904,-269.32007267340446788), (252.74608253315653883,-243.40348499567934937)), ((262.37713119618894098,-219.77606105199234321),(266.10600947781182413,-239.35267203051256502), (294.07259658998356144,-261.72594172024992076),(324.36973262816962915,-247.27653837896122013), (300.59813358282360696,-225.83548825962955675),(294.53870637518645026,-203.46221856989217258), (262.37713119618894098,-219.77606105199234321))) poly3 = Polygon(poly3) # two parts, each with one outer ring poly4 = ((((287.91859438149782591,-335.03713428477897196),(378.62665125353572648,-240.62670774449458122), (485.99537163268269069,-301.71580727056095839),(510.98636689334614402,-347.06983570657990867), (538.75413940519445077,-502.56936177293061974),(484.14418679855941718,-499.79258452174576632), (457.30200670377269034,-380.39116272079792225),(370.29631949998122309,-377.61438546961306884), (402.69205409713759991,-316.52528594354674851),(365.66835741467315302,-306.34376935586897162), (320.31432897865420273,-370.20964613312020219),(287.91859438149782591,-335.03713428477897196)),), (((274.96030054263525244,-342.4418736212718386),(311.98399722509969934,-379.4655703037362855), (268.94394983173475566,-422.50561769710122917),(184.25224367059732344,-337.81391153596376853), (187.02902092178214843,-335.03713428477897196),(274.96030054263525244,-342.4418736212718386)),)) poly4 = MultiPolygon(poly4) # use the polygon method addRing(): p1 = Polygon() p1.addRing( ((321.52641810650015941,-385.52558314627935943),(357.71607808855492294,-382.53470215602692406), (450.82285978434140361,-386.87030964022920898),(473.96267021088169713,-498.86699210468418642), (380.76171029810586788,-518.12338878087757621),(285.14181713031297249,-516.45324802885477311), (218.49916310187694535,-486.83429068288319286),(209.24323893126086205,-469.24803475871260616), (216.64797826775372869,-443.33144708098745923),(240.71338111135560212,-424.81959873975523578), (275.88589295969683235,-429.44756082506330586),(321.52641810650015941,-385.52558314627935943)) ) p1.addRing( ((275.88589295969683235,-441.48026224686429941),(244.41575077960209228,-435.92670774449459259), (228.6806796895546654,-449.81059400041874596),(228.6806796895546654,-465.54566509046617284), (245.34134319666367219,-484.05751343169833945),(274.03470812557361569,-493.31343760231447959), (324.01669864690063605,-498.86699210468418642),(376.77546641941250982,-492.38784518525289968), (391.58494509239829995,-470.17362717577418607),(389.73376025827508329,-441.48026224686429941), (365.66835741467315302,-421.11722907150880246),(337.90058490282484627,-414.63808215207751573), (315.60443879742075524,-409.43564806081656116),(315.68636689334613266,-409.08452764970786575), (275.88589295969683235,-441.48026224686429941)) ) p2 = Polygon() p2.addRing( ((361.27016520072675121,-376.7665935641414876), (328.98417466974592571,-374.33894830141070997),(371.22191191704285984,-312.82291627530025835), (394.36172234358309652,-321.15324802885476174),(361.27016520072675121,-376.7665935641414876)) ) p3 = Polygon() p3.addRing( ((275.88589295969683235,-455.36414850278845279),(342.75289231998959849,-442.08747236662020441), (346.23091665637934966,-484.98310584876003304),(311.98399722509969934,-487.75988309994488645), (275.88589295969683235,-481.28073618051359972),(275.88589295969683235,-455.36414850278845279)) ) poly5 = MultiPolygon() poly5.addPart(p1.getGeom()) poly5.addPart(p2.getGeom()) poly5.addPart(p3.getGeom()) l1 = MultiLine( (((186.86734599332530138,-330.01102525246926689),(281.02152260430347042,-334.20601331929503885),(380.16725392010351925,-233.1784919062212964)),)) l2 = MultiLine( (((298.38411210311005561,-148.6943188085558063),(351.63715506253709009,-206.8415145126128607),(380.16725392010351925,-233.1784919062212964), (422.01973262816943588,-259.16233790163414596),(492.40231019380161115,-297.84945007347175761),(522.2333364467847332,-341.66376988254080516), (544.6066061365220321,-475.90338802096505333)),) ) l3 = MultiLine( (((245.16397476845918391,-416.3710923394440897),(271.43529456551368639,-425.78911264404854364),(320.83859405808800602,-377.5424121362502774)), ((320.83859405808800602,-377.5424121362502774),(367.51562451511898644,-310.29444259284662166),(397.25674126650147855,-318.88632076546821281), (365.94595446435147323,-379.69038167940567519)), ((320.83859405808800602,-377.5424121362502774),(334.22209659621012179,-379.52515325300907989),(365.94595446435147323,-379.69038167940567519)), ((365.94595446435147323,-379.69038167940567519),(454.17793416011954832,-383.82109233931993231),(478.79696969320832522,-499.06791975092721714))) ) orte = [Point((238.968,-248.829)), Point((271.353,-308.312)), Point((242.933,-363.828)), Point((320.839,-377.542)), Point((365.863,-344.001)), Point((382.386,-275.266)), Point((462.357,-347.306)), Point((310.347,-466.27)), Point((422.702,-451.73)), Point((528.448,-318.886))] return (orte, (l1,l2,l3), (poly2, poly3, poly4, poly5)) Die Funktion test() kann auch in __init__.py implementiert werden!","title":"Gro\u00dfer Test"},{"location":"ch01/oomaps.html","text":"Das Modul DrawMap Aufbau des Moduls DrawMap als Ein-Dateien-Modul Darstellung von Raster-Layern fehlt Vektordarstellung mit Layern f\u00fcr Point-, Line- und Polygon-Layer benutzt Gemetriemodul geomet(2) akzeptiert auch Multipart-Geometrien f\u00fcr Linien und Polygone Python imports im Modul: import matplotlib.path as mpath import matplotlib.patches as mpatches import matplotlib.pyplot as plt import matplotlib.markers as mplmarkers import matplotlib.colors as mplcolors Path = mpath.Path # geometry Modul import geomet Achten Sie beim import von geomet auf die richtige Version, sie k\u00f6nnen als auch schreiben import geomet2 as geomet .Der Name geomet muss allerdings erhalten bleiben, da er im Mudul verwendet wird. Die Klasse Style: Style speichern die Signaturen f\u00fcr Punkte, Linien und Fl\u00e4chen. Die allgemeine Klasse Style wird anschlie\u00dfend um die Klassen PointStyle, LineStyle und PolyStyle erweitert. Da die Zeichenfunktionen auf der matplotlib basieren, finden wir in Style die wichtigsten Graphik-Definitionen aus dieser Zeichenbibliothek: class Style(object): \"\"\"a style class matching style attribute for matplotlib, root class for PointStyle, LineStyle and PolyStyle. MapLayer use them to draw with matplotlib.\"\"\" def __init__(self): # Markers for Point Symbols, as defined in the matplotlib module self.markers = {'tickleft' : 0, 'tickright' : 1, 'tickup' : 2, 'tickdown' : 3, ...} # Colors for Point and Line Symbols, as defined in the matplotlib module self.colors = { \"blue\": \"b\" , \"green\": \"g\", \"red\": \"r\", \"cyan\": \"c\", \"magenta\": \"m\", \"yellow\": \"y\", \"black\": \"k\", \"white\": \"w\"} # Line types for Line Symbols, as defined in the matplotlib module self.lines = { \"solid line style\" : '-', \"dashed line style\" : '--', \"dash-dot line style\" : '-.', \"dotted line style\" : ':', \"point marker\" : '.', \"pixel marker\" : ',', \"circle marker\" : 'o', ...} def findSymByName(self, name, symdict, default): \"\"\"used to indenfy a style in the internal dictionary\"\"\" if name in symdict.keys(): return symdict[name] elif name in symdict.values(): return name else: return default def findColorChar(self, value): \"\"\"used to indenfy a color style, returns a color letter as defined in matplotlib\"\"\" return self.findSymByName(value, self.colors, \"k\") def findMarkerChar(self, value): \"\"\"used to identify a marker style, returns a marker letter as defined in matplotlib\"\"\" return self.findSymByName(value, self.markers, \"o\") def findLineChar(self, value): \"\"\"used to identify a line style, returns a line type letter as defined in matplotlib\"\"\" return self.findSymByName(value, self.lines, \"-\") def rgb256Hex(self, r, g, b): \"\"\"use this to define new colors for polygon fills, r,g,b should be int in range 0..255, returns the hex-coded color like '#a0bc0f'\"\"\" col = (1.0*xrange/255 for xrange in (r, g, b)) return mplcolors.rgb2hex(col) def rgb2Hex(self, r, g, b): \"\"\"use this to define new polygon fills, r,g,b should be float in range 0.0..1.0, returns the hex-coded color like '#a0bc0f'\"\"\" col = (r, g, b) return mplcolors.rgb2hex(col) Die abgeleiteten Style-Klassen: class PointStyle(Style): \"\"\"create a PointStyle with marker and color. See attributes markers and colors, retrieve with getStyle for drawing.\"\"\" def __init__(self, marker='circle', color='red'): super(PointStyle, self).__init__() self.marker = self.findMarkerChar(marker) self.color = self.findColorChar(color) def __str__(self): return self.color + self.marker def getStyle(self): return self.__str__() class LineStyle(Style): \"\"\"create a line style with line type and color, See attributes lines and colors, retrieve with getStyle for drawing.\"\"\" def __init__(self, linetype='-', color='k'): super(LineStyle, self).__init__() self.linetype = self.findLineChar(linetype) self.color = self.findColorChar(color) def __str__(self): return self.color + self.linetype def getStyle(self): return self.__str__() class PolyStyle(Style): \"\"\"create a polygon style withh fill color and outline color. You can use both colors by name as defined in attribute colors or give a hex value like '#ff9900'. May use rgb2hex or rgb256hex to create a color hex string. Retrieve with getStyle for drawing.\"\"\" def __init__(self, linecolor='blue', fillcolor=\"#ff9900\"): super(PolyStyle, self).__init__() self.linecolor = self.checkColor(linecolor) self.fillcolor = self.checkColor(fillcolor) def checkColor(self, color): if isinstance(color, basestring) and color[0] == '#': return color elif isinstance(color, tuple): return self.rgb256Hex(*color) else: return self.findColorChar(color) def getStyle(self): return (self.fillcolor, self.linecolor) Die Klasse MapLayer In einem MapLayer werden die Geomtrien zusammen mit ihren Signaturen verwaltet. Die Geometrien eines Layers werden in Klassen eingeteilt und f\u00fcr jede Klasse wird genau eine Signatur genutzt. class MapLayer(object): \"\"\"manage a collection of objects into classes. Each class can have a seperate style (PointStyle etc.). Provides a method 'draw()' which is associated with the MapDrawer class and uses the matplotlib drawing capabilities.\"\"\" def __init__(self, map, geomtype = \"Points\", name = \"\"): self.layertypes = (\"Points\", \"Lines\", \"Polygons\") self.map = map self.name = name self.geomtype = geomtype # a list of geometries self.classes = [] # a list of styles, corresponding to classes self.styles = [] self.extent = None def addClass(self, objects, style): \"\"\"adds a class to the map layer. Each class holds a collection of geometry objects and a style, so all objects in that class are displayed in the same way\"\"\" self.classes.append(objects) self.styles.append(style) def calcExtent(self): \"\"\"helper function to get the layer's extent\"\"\" flatcoords = [] for cl in self.classes: for o in cl: if self.geomtype == \"Points\": flatcoords.append(o.getGeom()) else: flatcoords.extend(o.extent.getPoints()) self.extent = geomet.Extent(flatcoords) def draw(self): \"\"\"draw a layer. This method is called from a DrawMap instance.\"\"\" for icl in range(len(self.classes)): style = self.styles[icl] pstyle = style.getStyle() for o in self.classes[icl]: if self.geomtype == \"Points\": x,y = o.getGeom() self.map.plot.plot(x, y, pstyle) elif self.geomtype == \"Lines\": if isinstance(o, geomet.LineString): line = o.getGeom() x, y = zip(*line) self.map.plot.plot(x, y, pstyle) elif isinstance(o, geomet.MultiLine): for line in o.getGeom(): x, y = zip(*line) self.map.plot.plot(x, y, pstyle) elif self.geomtype == \"Polygons\": if isinstance(o, (geomet.Polygon, geomet.MultiPolygon)): if o.dim == 3: geom = ((o.getGeom()),) elif o.dim == 4: geom = o.getGeom() else: print \"error in polygon geometry!\" continue for part in geom: #### HERE WE STAND #### path = self.PolygonAsPath(part) patch = mpatches.PathPatch(path, facecolor=pstyle[0], edgecolor=pstyle[1]) self.map.plot.add_patch(patch) def PolygonAsPath(self, polygon): \"\"\"helper function for matplotlib's path construction. It is used for polygon drawing.\"\"\" pathdata = [] # each ring is a single polygon in matplotlib for ring in polygon: # indexes of points in ring go = range(len(ring)) # pop and store the first first = go.pop() # store the last last = go[-1] # a path consists of a drawing command and a (x,y) # start with a MoveTo pathdata.append((Path.MOVETO,ring[first])) for p in go: # all folling points will draw with line to pathdata.append((Path.LINETO, ring[p])) # close with the last point pathdata.append((Path.CLOSEPOLY,ring[last])) # all rings define one path codes, verts = zip(*pathdata) # build the path object and return return mpath.Path(verts, codes) Die Klasse DrawMap Mit DrawMap wird eine Karte repr\u00e4sentiert. Es ist so m\u00f6glich, die zuvor erstellten Layer zu zeichnen, einen Ausschnitt festzulegen oder eine \u00dcberschrift anzugeben. Mit addSingleSymbolLayer kann auf einfache Weise ein Layer angelegt werden, der nur aus einer Klasse besteht und demnach alle Geometrien mit der derselben Signatur darstellt. class DrawMap(object): \"\"\"a map drawing class, based on matplotlib (pyplot). Use MapLayers to populate the map with addLayer(). Call drawAll() and show() to display the map!\"\"\" def __init__(self): self.pyplot = plt self.figure = plt.figure() self.plot = self.figure.add_subplot(111) self.title = \"Draw Map\" self.frame = None self.margin = 0.02 self.layer = [] self.extent = None def getLayersExtent(self): \"\"\"calculate the extent of all layers. This is called by addLayer\"\"\" flatcoords = [] for lay in self.layer: flatcoords.extend(lay.extent.getPoints()) self.extent = geomet.Extent(flatcoords) def setFrame(self, extent): self.frame = (extent.left, extent.bottom, extent.right, extent.top) def addLayer(self, layer): \"\"\"add a Layer object to the map\"\"\" self.layer.append(layer) layer.calcExtent() self.getLayersExtent() def addSingleSymbolLayer(self, geomtype, objects, style): ssl = MapLayer(self, geomtype) ssl.addClass(objects, style) self.layer.append(ssl) return ssl def drawAll(self): for lay in self.layer: lay.draw() def show(self): \"\"\"open the matplotlib window, sets some litte layout and calls imported object method: plt.show()\"\"\" self.plot.grid() if not self.frame: xmarg = self.extent.width * self.margin / 2 ymarg = self.extent.height * self.margin / 2 self.frame = (self.extent.left - xmarg, self.extent.bottom - ymarg, self.extent.right+xmarg, self.extent.top+ymarg) self.plot.set_xlim(self.frame[0], self.frame[2]) self.plot.set_ylim(self.frame[1], self.frame[3]) self.plot.set_title(self.title) # self.drawAll() plt.show() Test von DrawMap Der Test zeigt die Verwendung der Klassen. Benutzt wird die Funktion test() im geomet-Modul, um die dort zur\u00fcckgegebenen Beispielgeometrien nutzen zu k\u00f6nnen. def main(): geo = geomet.test() # ## drawing map = DrawMap() polys = geo[2] lay = MapLayer(map, \"Polygons\") style = PolyStyle(linecolor=\"#FF4444\") lay.addClass(polys,style) map.addLayer(lay) lines = geo[1] lay = MapLayer(map, \"Lines\") style = LineStyle(color=\"blue\") lay.addClass(lines, style) map.addLayer(lay) orte = geo[0] lay = MapLayer(map, \"Points\") style = PointStyle(marker=\"*\", color=\"blue\") lay.addClass(orte, style) map.addLayer(lay) map.drawAll() map.show()","title":"Oomaps"},{"location":"ch01/oomaps.html#das-modul-drawmap","text":"","title":"Das Modul DrawMap"},{"location":"ch01/oomaps.html#aufbau-des-moduls","text":"DrawMap als Ein-Dateien-Modul Darstellung von Raster-Layern fehlt Vektordarstellung mit Layern f\u00fcr Point-, Line- und Polygon-Layer benutzt Gemetriemodul geomet(2) akzeptiert auch Multipart-Geometrien f\u00fcr Linien und Polygone Python imports im Modul: import matplotlib.path as mpath import matplotlib.patches as mpatches import matplotlib.pyplot as plt import matplotlib.markers as mplmarkers import matplotlib.colors as mplcolors Path = mpath.Path # geometry Modul import geomet Achten Sie beim import von geomet auf die richtige Version, sie k\u00f6nnen als auch schreiben import geomet2 as geomet .Der Name geomet muss allerdings erhalten bleiben, da er im Mudul verwendet wird.","title":"Aufbau des Moduls"},{"location":"ch01/oomaps.html#die-klasse-style","text":"Style speichern die Signaturen f\u00fcr Punkte, Linien und Fl\u00e4chen. Die allgemeine Klasse Style wird anschlie\u00dfend um die Klassen PointStyle, LineStyle und PolyStyle erweitert. Da die Zeichenfunktionen auf der matplotlib basieren, finden wir in Style die wichtigsten Graphik-Definitionen aus dieser Zeichenbibliothek: class Style(object): \"\"\"a style class matching style attribute for matplotlib, root class for PointStyle, LineStyle and PolyStyle. MapLayer use them to draw with matplotlib.\"\"\" def __init__(self): # Markers for Point Symbols, as defined in the matplotlib module self.markers = {'tickleft' : 0, 'tickright' : 1, 'tickup' : 2, 'tickdown' : 3, ...} # Colors for Point and Line Symbols, as defined in the matplotlib module self.colors = { \"blue\": \"b\" , \"green\": \"g\", \"red\": \"r\", \"cyan\": \"c\", \"magenta\": \"m\", \"yellow\": \"y\", \"black\": \"k\", \"white\": \"w\"} # Line types for Line Symbols, as defined in the matplotlib module self.lines = { \"solid line style\" : '-', \"dashed line style\" : '--', \"dash-dot line style\" : '-.', \"dotted line style\" : ':', \"point marker\" : '.', \"pixel marker\" : ',', \"circle marker\" : 'o', ...} def findSymByName(self, name, symdict, default): \"\"\"used to indenfy a style in the internal dictionary\"\"\" if name in symdict.keys(): return symdict[name] elif name in symdict.values(): return name else: return default def findColorChar(self, value): \"\"\"used to indenfy a color style, returns a color letter as defined in matplotlib\"\"\" return self.findSymByName(value, self.colors, \"k\") def findMarkerChar(self, value): \"\"\"used to identify a marker style, returns a marker letter as defined in matplotlib\"\"\" return self.findSymByName(value, self.markers, \"o\") def findLineChar(self, value): \"\"\"used to identify a line style, returns a line type letter as defined in matplotlib\"\"\" return self.findSymByName(value, self.lines, \"-\") def rgb256Hex(self, r, g, b): \"\"\"use this to define new colors for polygon fills, r,g,b should be int in range 0..255, returns the hex-coded color like '#a0bc0f'\"\"\" col = (1.0*xrange/255 for xrange in (r, g, b)) return mplcolors.rgb2hex(col) def rgb2Hex(self, r, g, b): \"\"\"use this to define new polygon fills, r,g,b should be float in range 0.0..1.0, returns the hex-coded color like '#a0bc0f'\"\"\" col = (r, g, b) return mplcolors.rgb2hex(col) Die abgeleiteten Style-Klassen: class PointStyle(Style): \"\"\"create a PointStyle with marker and color. See attributes markers and colors, retrieve with getStyle for drawing.\"\"\" def __init__(self, marker='circle', color='red'): super(PointStyle, self).__init__() self.marker = self.findMarkerChar(marker) self.color = self.findColorChar(color) def __str__(self): return self.color + self.marker def getStyle(self): return self.__str__() class LineStyle(Style): \"\"\"create a line style with line type and color, See attributes lines and colors, retrieve with getStyle for drawing.\"\"\" def __init__(self, linetype='-', color='k'): super(LineStyle, self).__init__() self.linetype = self.findLineChar(linetype) self.color = self.findColorChar(color) def __str__(self): return self.color + self.linetype def getStyle(self): return self.__str__() class PolyStyle(Style): \"\"\"create a polygon style withh fill color and outline color. You can use both colors by name as defined in attribute colors or give a hex value like '#ff9900'. May use rgb2hex or rgb256hex to create a color hex string. Retrieve with getStyle for drawing.\"\"\" def __init__(self, linecolor='blue', fillcolor=\"#ff9900\"): super(PolyStyle, self).__init__() self.linecolor = self.checkColor(linecolor) self.fillcolor = self.checkColor(fillcolor) def checkColor(self, color): if isinstance(color, basestring) and color[0] == '#': return color elif isinstance(color, tuple): return self.rgb256Hex(*color) else: return self.findColorChar(color) def getStyle(self): return (self.fillcolor, self.linecolor)","title":"Die Klasse Style:"},{"location":"ch01/oomaps.html#die-klasse-maplayer","text":"In einem MapLayer werden die Geomtrien zusammen mit ihren Signaturen verwaltet. Die Geometrien eines Layers werden in Klassen eingeteilt und f\u00fcr jede Klasse wird genau eine Signatur genutzt. class MapLayer(object): \"\"\"manage a collection of objects into classes. Each class can have a seperate style (PointStyle etc.). Provides a method 'draw()' which is associated with the MapDrawer class and uses the matplotlib drawing capabilities.\"\"\" def __init__(self, map, geomtype = \"Points\", name = \"\"): self.layertypes = (\"Points\", \"Lines\", \"Polygons\") self.map = map self.name = name self.geomtype = geomtype # a list of geometries self.classes = [] # a list of styles, corresponding to classes self.styles = [] self.extent = None def addClass(self, objects, style): \"\"\"adds a class to the map layer. Each class holds a collection of geometry objects and a style, so all objects in that class are displayed in the same way\"\"\" self.classes.append(objects) self.styles.append(style) def calcExtent(self): \"\"\"helper function to get the layer's extent\"\"\" flatcoords = [] for cl in self.classes: for o in cl: if self.geomtype == \"Points\": flatcoords.append(o.getGeom()) else: flatcoords.extend(o.extent.getPoints()) self.extent = geomet.Extent(flatcoords) def draw(self): \"\"\"draw a layer. This method is called from a DrawMap instance.\"\"\" for icl in range(len(self.classes)): style = self.styles[icl] pstyle = style.getStyle() for o in self.classes[icl]: if self.geomtype == \"Points\": x,y = o.getGeom() self.map.plot.plot(x, y, pstyle) elif self.geomtype == \"Lines\": if isinstance(o, geomet.LineString): line = o.getGeom() x, y = zip(*line) self.map.plot.plot(x, y, pstyle) elif isinstance(o, geomet.MultiLine): for line in o.getGeom(): x, y = zip(*line) self.map.plot.plot(x, y, pstyle) elif self.geomtype == \"Polygons\": if isinstance(o, (geomet.Polygon, geomet.MultiPolygon)): if o.dim == 3: geom = ((o.getGeom()),) elif o.dim == 4: geom = o.getGeom() else: print \"error in polygon geometry!\" continue for part in geom: #### HERE WE STAND #### path = self.PolygonAsPath(part) patch = mpatches.PathPatch(path, facecolor=pstyle[0], edgecolor=pstyle[1]) self.map.plot.add_patch(patch) def PolygonAsPath(self, polygon): \"\"\"helper function for matplotlib's path construction. It is used for polygon drawing.\"\"\" pathdata = [] # each ring is a single polygon in matplotlib for ring in polygon: # indexes of points in ring go = range(len(ring)) # pop and store the first first = go.pop() # store the last last = go[-1] # a path consists of a drawing command and a (x,y) # start with a MoveTo pathdata.append((Path.MOVETO,ring[first])) for p in go: # all folling points will draw with line to pathdata.append((Path.LINETO, ring[p])) # close with the last point pathdata.append((Path.CLOSEPOLY,ring[last])) # all rings define one path codes, verts = zip(*pathdata) # build the path object and return return mpath.Path(verts, codes)","title":"Die Klasse MapLayer"},{"location":"ch01/oomaps.html#die-klasse-drawmap","text":"Mit DrawMap wird eine Karte repr\u00e4sentiert. Es ist so m\u00f6glich, die zuvor erstellten Layer zu zeichnen, einen Ausschnitt festzulegen oder eine \u00dcberschrift anzugeben. Mit addSingleSymbolLayer kann auf einfache Weise ein Layer angelegt werden, der nur aus einer Klasse besteht und demnach alle Geometrien mit der derselben Signatur darstellt. class DrawMap(object): \"\"\"a map drawing class, based on matplotlib (pyplot). Use MapLayers to populate the map with addLayer(). Call drawAll() and show() to display the map!\"\"\" def __init__(self): self.pyplot = plt self.figure = plt.figure() self.plot = self.figure.add_subplot(111) self.title = \"Draw Map\" self.frame = None self.margin = 0.02 self.layer = [] self.extent = None def getLayersExtent(self): \"\"\"calculate the extent of all layers. This is called by addLayer\"\"\" flatcoords = [] for lay in self.layer: flatcoords.extend(lay.extent.getPoints()) self.extent = geomet.Extent(flatcoords) def setFrame(self, extent): self.frame = (extent.left, extent.bottom, extent.right, extent.top) def addLayer(self, layer): \"\"\"add a Layer object to the map\"\"\" self.layer.append(layer) layer.calcExtent() self.getLayersExtent() def addSingleSymbolLayer(self, geomtype, objects, style): ssl = MapLayer(self, geomtype) ssl.addClass(objects, style) self.layer.append(ssl) return ssl def drawAll(self): for lay in self.layer: lay.draw() def show(self): \"\"\"open the matplotlib window, sets some litte layout and calls imported object method: plt.show()\"\"\" self.plot.grid() if not self.frame: xmarg = self.extent.width * self.margin / 2 ymarg = self.extent.height * self.margin / 2 self.frame = (self.extent.left - xmarg, self.extent.bottom - ymarg, self.extent.right+xmarg, self.extent.top+ymarg) self.plot.set_xlim(self.frame[0], self.frame[2]) self.plot.set_ylim(self.frame[1], self.frame[3]) self.plot.set_title(self.title) # self.drawAll() plt.show()","title":"Die Klasse DrawMap"},{"location":"ch01/oomaps.html#test-von-drawmap","text":"Der Test zeigt die Verwendung der Klassen. Benutzt wird die Funktion test() im geomet-Modul, um die dort zur\u00fcckgegebenen Beispielgeometrien nutzen zu k\u00f6nnen. def main(): geo = geomet.test() # ## drawing map = DrawMap() polys = geo[2] lay = MapLayer(map, \"Polygons\") style = PolyStyle(linecolor=\"#FF4444\") lay.addClass(polys,style) map.addLayer(lay) lines = geo[1] lay = MapLayer(map, \"Lines\") style = LineStyle(color=\"blue\") lay.addClass(lines, style) map.addLayer(lay) orte = geo[0] lay = MapLayer(map, \"Points\") style = PointStyle(marker=\"*\", color=\"blue\") lay.addClass(orte, style) map.addLayer(lay) map.drawAll() map.show()","title":"Test von DrawMap"},{"location":"ch01/oop.html","text":"Objektorientierte Programmierung Ansatz der OOP Encapsulation: Daten und Funktionen werden zusammen verwaltet, Data Abstraction: interne Datenstrukturen werden \u00fcber eine Schnittstelle weitergegeben Polymorphism: Klassenstrukturen helfen, die Schnittstelle \u00fcber verschiedene Klassen konsistenz zu halten Inheritance: Vererbung meint die Weitergabe von Daten und Methoden von allgemeineren Klassen zu spezielleren Die Begriffe Objekt und Klasse bezeichnen dabei jeweils die Form (Klasse) und die Instanz (Objekt), die aus dieser Form hervorgeht. Sucht man in Programmiersprachen nach einem \u00e4hnlichen Kontrukt, so kann vielleicht eine Funktion als Vergleich gelten: Die Funktion besitzt eine Funktionsdefinition (Form), die im Programm aufgerufen werden muss (Instanz), um aktiv zu sein. In einer Klasse werden Eigenschaften (Daten) und Methoden (Funktionen) definiert. Diese legen Art und Verhalten von Objekt fest. Wir kennen das Prinzip schon: einObjekt.eigenschaft einObjekt.methode() Beispiel: Entwurf einer Klassenstruktur f\u00fcr \"Datenobjekte\" Diese Datenobjekte sollen den Zugriff auf Dateien oder auf Datenbanken erm\u00f6glichen. Klassendiagramm f\u00fcr Datenobjekte class Datenquelle , definiert Methoden: open, read, insert, delete, close definiert Eigenschaften: location class Datei , abgeleitet aus Datenquelle , erbt Methoden und Eigenschaften von Datenquelle spezifiziert aber f\u00fcr den speziellen Typ einer Datenquelle wie die Methoden auf eine Datei zugreifen benutzt als location einen lokalen Pfad class Database , abgeleitet aus Datenquelle , erbt auch von Datenquelle implementiert einen Zugriff auf eine Datenbank benutzt location als Connect-String des Datenbank-Management-Systems class CSV , abgeleitet aus Datei erbt die Methoden der Klasse Datei implementiert den Zugriff f\u00fcr tabellenartige Daten im csv-Format sieht speziell f\u00fcr das CSV-Format weitere Methoden vor, z.B. zum Zugriff auf Spalten class SQLDB , abgeleitet aus Database erbt die Database-Methoden implementiert alle Zugriffe auf die Datenbank \u00fcber SQL-Befehle benutzt f\u00fcr tabellenartige Daten dieselbe oder \u00e4hnliche Zugriffe wie die CSV-Klasse class Table , neue Klasse f\u00fcr tabellenartige Daten wird erstellt, um doppelten Code in CSV- und SQLDB zu vermeiden Python Klassendefinition Minimal class Point(object): X = 0 Y = 0 p1 = Point() p1.X = 1.2 p1.Y = 2.3 Initialisierung eines Objekts class Point(object): def __init__(self, x=0.0, y=0.0): self.X = x self.Y = y p1 = Point(1.2,2.3) print p1.X # gibt 1.2 p2 = Point(2.1,2.5) print p2.Y # gibt 2.5 try it weitere vordefinierte Methoden Umwandlung in einen String: class Point(object): def __init__(self, x=0.0, y=0.0): self.X = x self.Y = y def __str__(self): return \"POINT: %s, %s\" % (self.X, self.Y) p1 = Point(1.2,2.3) print p1 try it eine kurze Liste einiger magischer Methoden: __new__ : gibt an, wie das Objekt erzeugt wird __init__ : gibt an, wie das zuvor erzeugte Objekt initialisiert wird __del__ : gibt an, was passiert, wenn das Objekt gel\u00f6scht wird __str__ : gibt an, was passiert, wenn das Objekt in einen String umgewandelt wird: z.B. mit print! __add__ : gibt an, wie eine Addition durchgef\u00fchrt wird Weitere Informationen: tutorialspoint Der Lebenslauf eines Objekts: class Point(object): count = 0 def __new__(cls, x=0.0, y=0.0): print \"NEW\" cls.count += 1 return super(Point, cls).__new__(cls) def __init__(self, x=0.0, y=0.0): print \"INIT\", self.count self.X = x self.Y = y def __str__(self): print \"STR\" return \"POINT: %s, %s\" % (self.X, self.Y) def __del__(self): print \"DEL\" self.__class__.count -= 1 print \"Point %s deleted. Count is %s\"%(id(self), self.count) p1 = Point(1.2,2.3) print p1 del p1 p1 = Point(4.5,4.6) p2 = Point(3.4,3.5) del p1 Dieses Beispiel funktioniert nicht mit skulpt! Eigene Methoden import math class Point(object): def __init__(self, x=0.0, y=0.0): self.X = x self.Y = y def __str__(self): return \"POINT: %s, %s\" % (self.X, self.Y) def distance(self, second): return math.sqrt((self.X - second.X)**2 + (self.Y - second.Y) **2) p1 = Point(1.2,2.3) p2 = Point(3.4,3.5) p1.distance(p2) try it Getter, Setter, Properties Ziel: Werte sch\u00fctzen! Zuweisungen kontrolliert ablaufen lassen. value_too_small = 0.001 p1 = Point(1.2,2.3) p2.X = value_to_small Beispiel: Zuweisung von zu kleinen Werten verbieten class Point(object): def __init__(self, x=0.0, y=0.0): self.setX(x) self.setY(y) def __str__(self): return \"POINT: %s, %s\" % (self.X, self.Y) def setX(self, x): if x >= 0: self.__x = x def setY(self, y): if y >= 0: self.__y = y def getX(self): return self.__x def getY(self): return self.__y X = property(getX, setX) Y = property(getY, setY) p1 = Point() p1.X = -0.5 p1.Y = 1.0 print p1 try it Python Objekte alles in Python ist ein Objekt: \"Objects are Python\u2019s abstraction for data. All data in a Python program is represented by objects or by relations between objects. (In a sense, and in conformance to Von Neumann\u2019s model of a \u201cstored program computer,\u201d code is also represented by objects.)\" Dokumentation Der Datentyp Datentypen und Klassen sind identisch: a = \"Ich bin ein String\" print type(a) print a.__class__ print str print type(a) == str Dieses Beispiel funktioniert nicht mit skulpt! \"Nichts\" ist ein Objekt: None ist ein Objekt vom Typ NoneType >>> print None.__class__ <type 'NoneType'> Dieses Beispiel funktioniert nicht mit skulpt! Konstanten und Funktionen: auch Objekte... >>> print \"abc\".__class__ <type 'str'> >>> 5.__class__ SyntaxError: invalid syntax >>> (5).__class__ <type 'int'> >>> def h(a,b): return a**b >>> h.__class__ <type 'function'> Dieses Beispiel funktioniert nicht mit skulpt! Typen \u00fcberpr\u00fcfen isinstance(obj, cls): \u00fcberpr\u00fcft, ob das Objekt obj eine Instanz der Klasse cls ist das Funktioniert auch mit Vererbungen, s.u. Annahme: str und unicode haben eine gemeinsame \u00fcbergeordnete Klasse >>> a = \"A String!\" >>> isinstance(a, str) True >>> b = u\"\u00e4h, string?\" >>> print type(b) <type 'unicode'> >>> print isinstance(b, basestring) True >>> print isinstance(a, basestring) True Dieses Beispiel funktioniert nicht mit skulpt! Vererbung Parent und Child Entwurf einer Klassenstruktur, Vererbung von Eigenschaften und Methoden, Spezialisierung von Klassendefinitionen class Geometry(object): # geometry class is derived from object (object indeed is empty...) # http://stackoverflow.com/questions/4015417/python-class-inherits-object pass class Point(Geometry): # point class is derived from geometry # all definitions from Geometry will be with points too pass p = Point() print isinstance(p, Geometry) try it Bei der Vererbung muss anders initialisiert werden: class Geometry(object): def __init__(self, geom=None, gtype=\"\"): self.geom = geom # Geometry data is stored in tuples self.gtype = gtype # Geometry Type: Name from ('Point', 'Line', 'Polygon' etc.) class Point(Geometry): def __init__(self, geom=(0.0, 0.0)): # call super super(Point, self).__init__(self, geom, \"Point\") p = Point() print p.geom, p.gtype Dieses Beispiel funktioniert nicht mit skulpt! Alternativ, ohne super(), aber mit weiteren Methoden: class Geometry(object): def __init__(self, geom=None, gtype=\"\"): self.geom = geom # Geometry data is stored in tuples self.gtype = gtype # Geometry Type: Name from ('Point', 'Line', 'Polygon' etc.) def test(self): \"\"\"check Geometry, needs to be overloaded \"\"\" pass def setGeom(self, geom): \"\"\"set Geometry, needs to be overloaded \"\"\" # test and set geometry value pass def __str__(self): return \"%s: %s\"%(self.gtype, self.geom) class Point(Geometry): def __init__(self, geom=(0.0, 0.0)): # call super Geometry.__init__(self, geom, \"Point\") def test(self): \"\"\"test for two-value-tuple\"\"\" if isinstance(self.geom, tuple) and len(self.geom) == 2: return True return False def setGeom(self, geom): \"\"\"set Geometry, needs to be overloaded \"\"\" # test and set geometry value self.geom = geom if not self.test(): self.geom = (0.0, 0.0) p = Point() p.setGeom((5.5,1.1)) print p.gtype, p.geom print p try it Aufgabenstellung zu Klassen Erg\u00e4nzen Sie eine Klasse f\u00fcr Linien (class Line) implementieren Sie die Methoden init , test und setGeom testen Sie die neue Klasse \u00dcberlegen Sie, was zu tun ist, um Fehler zu vermeiden Wo k\u00f6nnen wir Fehler erwarten? Wie gehen wir mit ihnen um? Gro\u00dfe Module Ein Python-Script ist immer auch ein Modul. Wird in der Entwicklung ein Modul zu gro\u00df, so kann es auf mehrere Dateien aufgeteilt werden und kann per import wieder zusammengef\u00fchrt werden. Gro\u00dfe Module in Python k\u00f6nnen sich auch \u00fcber Ordner und Unterodner erstrecken, in denen jeweils wieder kleinere Module als Python-Scripte gespeichert sind. Diese werden auch als Packages bezeichnet. Ein Odner an sich speichert allerdings keinen Code und kann somit nicht importiert werden. Damit sich ein Ordner auch wie ein Modul verh\u00e4lt, wird in einem Python-Package eine spezielle Datei angelegt, die dem Pythoninterpreter deutlich macht, das dieser Ordner wie ein Modul zu behandeln ist, sie hei\u00dft __init__.py . Eine kompakte Darstellung finden wir hier Beispiel eines Python Packages auf programiz.com Import Module lassen sich in Python \u00fcber import in anderen Modules nutzen. Module und Packages werden normalerweise unter dem Ordner site-packages installiert. Weitere M\u00f6glichkeiten zum Import ist Speicherung von Modulen/Packages im selben Ordner, in dem auch das Python-Script gespeichert wurde oder ein Pfad, der im Environment der Shell (des Rechners) angegeben ist (Variablenname ist PYTHONPATH). Dieser kann auch in einem Script bearbeitet werden. Hierzu bietet das Standardmodul sys die Eigenschaft path an: sys.path ist eine Python-Liste mit den entsprechenden Pfadangaben. Beispiel Modul-Shapely Shapely ist ein Geometrie-Package f\u00fcr Python, welches sich durch sehr umfangreiche analytische Funktionen auszeichnet. Wir werden Shapely in diesem Kurs zwar nicht verwenden, k\u00f6nnen es aber studieren, um mehr \u00fcber gro\u00dfe Python-Module zu erfahren. Der Quell-Code liegt im site-package-Verzeichnis des GIS-Sticks unter osgeo4w/apps/Python27/Lib/site-packages, kann aber auch auf der Entwicklerplatform github eingesehen werden ( Shapely auf github ). Ein paar Ausz\u00fcge: __init__.py enth\u00e4lt lediglich eine Angabe zur Version __version__ = \"1.6.4.post1\" Welche Version liegt auf dem GIS-Stick? import shapely print shapely.__version__ Mit dem Shapely-Modul k\u00f6nnen Geometrien als WKT ausgegeben werden, hierzu existiert das Modul wkt.py, welches wiederum das Modul geos importiert: \"\"\"Load/dump geometries using the well-known text (WKT) format \"\"\" from shapely import geos # Pickle-like convenience functions def loads(data): \"\"\"Load a geometry from a WKT string.\"\"\" return geos.WKTReader(geos.lgeos).read(data) def load(fp): \"\"\"Load a geometry from an open file.\"\"\" data = fp.read() return loads(data) def dumps(ob, trim=False, **kw): \"\"\"Dump a WKT representation of a geometry to a string. See available keyword output settings in ``shapely.geos.WKTWriter``. \"\"\" return geos.WKTWriter(geos.lgeos, trim=trim, **kw).write(ob) def dump(ob, fp, **settings): \"\"\"Dump a geometry to an open file.\"\"\" fp.write(dumps(ob, **settings)) Unter algorithms/cga.py finden wi \u00fcbrigens einen alten Bekannten: Die Funktion signed_area(), sie l\u00e4sst sich folgenderma\u00dfen importieren: from shapely.algorithms.cga import signed_area","title":"Objektorientierte Programmierung"},{"location":"ch01/oop.html#objektorientierte-programmierung","text":"","title":"Objektorientierte Programmierung"},{"location":"ch01/oop.html#ansatz-der-oop","text":"Encapsulation: Daten und Funktionen werden zusammen verwaltet, Data Abstraction: interne Datenstrukturen werden \u00fcber eine Schnittstelle weitergegeben Polymorphism: Klassenstrukturen helfen, die Schnittstelle \u00fcber verschiedene Klassen konsistenz zu halten Inheritance: Vererbung meint die Weitergabe von Daten und Methoden von allgemeineren Klassen zu spezielleren Die Begriffe Objekt und Klasse bezeichnen dabei jeweils die Form (Klasse) und die Instanz (Objekt), die aus dieser Form hervorgeht. Sucht man in Programmiersprachen nach einem \u00e4hnlichen Kontrukt, so kann vielleicht eine Funktion als Vergleich gelten: Die Funktion besitzt eine Funktionsdefinition (Form), die im Programm aufgerufen werden muss (Instanz), um aktiv zu sein. In einer Klasse werden Eigenschaften (Daten) und Methoden (Funktionen) definiert. Diese legen Art und Verhalten von Objekt fest. Wir kennen das Prinzip schon: einObjekt.eigenschaft einObjekt.methode() Beispiel: Entwurf einer Klassenstruktur f\u00fcr \"Datenobjekte\" Diese Datenobjekte sollen den Zugriff auf Dateien oder auf Datenbanken erm\u00f6glichen. Klassendiagramm f\u00fcr Datenobjekte class Datenquelle , definiert Methoden: open, read, insert, delete, close definiert Eigenschaften: location class Datei , abgeleitet aus Datenquelle , erbt Methoden und Eigenschaften von Datenquelle spezifiziert aber f\u00fcr den speziellen Typ einer Datenquelle wie die Methoden auf eine Datei zugreifen benutzt als location einen lokalen Pfad class Database , abgeleitet aus Datenquelle , erbt auch von Datenquelle implementiert einen Zugriff auf eine Datenbank benutzt location als Connect-String des Datenbank-Management-Systems class CSV , abgeleitet aus Datei erbt die Methoden der Klasse Datei implementiert den Zugriff f\u00fcr tabellenartige Daten im csv-Format sieht speziell f\u00fcr das CSV-Format weitere Methoden vor, z.B. zum Zugriff auf Spalten class SQLDB , abgeleitet aus Database erbt die Database-Methoden implementiert alle Zugriffe auf die Datenbank \u00fcber SQL-Befehle benutzt f\u00fcr tabellenartige Daten dieselbe oder \u00e4hnliche Zugriffe wie die CSV-Klasse class Table , neue Klasse f\u00fcr tabellenartige Daten wird erstellt, um doppelten Code in CSV- und SQLDB zu vermeiden","title":"Ansatz der OOP"},{"location":"ch01/oop.html#python-klassendefinition","text":"","title":"Python Klassendefinition"},{"location":"ch01/oop.html#minimal","text":"class Point(object): X = 0 Y = 0 p1 = Point() p1.X = 1.2 p1.Y = 2.3","title":"Minimal"},{"location":"ch01/oop.html#initialisierung-eines-objekts","text":"class Point(object): def __init__(self, x=0.0, y=0.0): self.X = x self.Y = y p1 = Point(1.2,2.3) print p1.X # gibt 1.2 p2 = Point(2.1,2.5) print p2.Y # gibt 2.5 try it","title":"Initialisierung eines Objekts"},{"location":"ch01/oop.html#weitere-vordefinierte-methoden","text":"Umwandlung in einen String: class Point(object): def __init__(self, x=0.0, y=0.0): self.X = x self.Y = y def __str__(self): return \"POINT: %s, %s\" % (self.X, self.Y) p1 = Point(1.2,2.3) print p1 try it eine kurze Liste einiger magischer Methoden: __new__ : gibt an, wie das Objekt erzeugt wird __init__ : gibt an, wie das zuvor erzeugte Objekt initialisiert wird __del__ : gibt an, was passiert, wenn das Objekt gel\u00f6scht wird __str__ : gibt an, was passiert, wenn das Objekt in einen String umgewandelt wird: z.B. mit print! __add__ : gibt an, wie eine Addition durchgef\u00fchrt wird Weitere Informationen: tutorialspoint Der Lebenslauf eines Objekts: class Point(object): count = 0 def __new__(cls, x=0.0, y=0.0): print \"NEW\" cls.count += 1 return super(Point, cls).__new__(cls) def __init__(self, x=0.0, y=0.0): print \"INIT\", self.count self.X = x self.Y = y def __str__(self): print \"STR\" return \"POINT: %s, %s\" % (self.X, self.Y) def __del__(self): print \"DEL\" self.__class__.count -= 1 print \"Point %s deleted. Count is %s\"%(id(self), self.count) p1 = Point(1.2,2.3) print p1 del p1 p1 = Point(4.5,4.6) p2 = Point(3.4,3.5) del p1 Dieses Beispiel funktioniert nicht mit skulpt!","title":"weitere vordefinierte Methoden"},{"location":"ch01/oop.html#eigene-methoden","text":"import math class Point(object): def __init__(self, x=0.0, y=0.0): self.X = x self.Y = y def __str__(self): return \"POINT: %s, %s\" % (self.X, self.Y) def distance(self, second): return math.sqrt((self.X - second.X)**2 + (self.Y - second.Y) **2) p1 = Point(1.2,2.3) p2 = Point(3.4,3.5) p1.distance(p2) try it","title":"Eigene Methoden"},{"location":"ch01/oop.html#getter-setter-properties","text":"Ziel: Werte sch\u00fctzen! Zuweisungen kontrolliert ablaufen lassen. value_too_small = 0.001 p1 = Point(1.2,2.3) p2.X = value_to_small Beispiel: Zuweisung von zu kleinen Werten verbieten class Point(object): def __init__(self, x=0.0, y=0.0): self.setX(x) self.setY(y) def __str__(self): return \"POINT: %s, %s\" % (self.X, self.Y) def setX(self, x): if x >= 0: self.__x = x def setY(self, y): if y >= 0: self.__y = y def getX(self): return self.__x def getY(self): return self.__y X = property(getX, setX) Y = property(getY, setY) p1 = Point() p1.X = -0.5 p1.Y = 1.0 print p1 try it","title":"Getter, Setter, Properties"},{"location":"ch01/oop.html#python-objekte","text":"alles in Python ist ein Objekt: \"Objects are Python\u2019s abstraction for data. All data in a Python program is represented by objects or by relations between objects. (In a sense, and in conformance to Von Neumann\u2019s model of a \u201cstored program computer,\u201d code is also represented by objects.)\" Dokumentation","title":"Python Objekte"},{"location":"ch01/oop.html#der-datentyp","text":"Datentypen und Klassen sind identisch: a = \"Ich bin ein String\" print type(a) print a.__class__ print str print type(a) == str Dieses Beispiel funktioniert nicht mit skulpt! \"Nichts\" ist ein Objekt: None ist ein Objekt vom Typ NoneType >>> print None.__class__ <type 'NoneType'> Dieses Beispiel funktioniert nicht mit skulpt! Konstanten und Funktionen: auch Objekte... >>> print \"abc\".__class__ <type 'str'> >>> 5.__class__ SyntaxError: invalid syntax >>> (5).__class__ <type 'int'> >>> def h(a,b): return a**b >>> h.__class__ <type 'function'> Dieses Beispiel funktioniert nicht mit skulpt! Typen \u00fcberpr\u00fcfen isinstance(obj, cls): \u00fcberpr\u00fcft, ob das Objekt obj eine Instanz der Klasse cls ist das Funktioniert auch mit Vererbungen, s.u. Annahme: str und unicode haben eine gemeinsame \u00fcbergeordnete Klasse >>> a = \"A String!\" >>> isinstance(a, str) True >>> b = u\"\u00e4h, string?\" >>> print type(b) <type 'unicode'> >>> print isinstance(b, basestring) True >>> print isinstance(a, basestring) True Dieses Beispiel funktioniert nicht mit skulpt!","title":"Der Datentyp"},{"location":"ch01/oop.html#vererbung","text":"","title":"Vererbung"},{"location":"ch01/oop.html#parent-und-child","text":"Entwurf einer Klassenstruktur, Vererbung von Eigenschaften und Methoden, Spezialisierung von Klassendefinitionen class Geometry(object): # geometry class is derived from object (object indeed is empty...) # http://stackoverflow.com/questions/4015417/python-class-inherits-object pass class Point(Geometry): # point class is derived from geometry # all definitions from Geometry will be with points too pass p = Point() print isinstance(p, Geometry) try it Bei der Vererbung muss anders initialisiert werden: class Geometry(object): def __init__(self, geom=None, gtype=\"\"): self.geom = geom # Geometry data is stored in tuples self.gtype = gtype # Geometry Type: Name from ('Point', 'Line', 'Polygon' etc.) class Point(Geometry): def __init__(self, geom=(0.0, 0.0)): # call super super(Point, self).__init__(self, geom, \"Point\") p = Point() print p.geom, p.gtype Dieses Beispiel funktioniert nicht mit skulpt! Alternativ, ohne super(), aber mit weiteren Methoden: class Geometry(object): def __init__(self, geom=None, gtype=\"\"): self.geom = geom # Geometry data is stored in tuples self.gtype = gtype # Geometry Type: Name from ('Point', 'Line', 'Polygon' etc.) def test(self): \"\"\"check Geometry, needs to be overloaded \"\"\" pass def setGeom(self, geom): \"\"\"set Geometry, needs to be overloaded \"\"\" # test and set geometry value pass def __str__(self): return \"%s: %s\"%(self.gtype, self.geom) class Point(Geometry): def __init__(self, geom=(0.0, 0.0)): # call super Geometry.__init__(self, geom, \"Point\") def test(self): \"\"\"test for two-value-tuple\"\"\" if isinstance(self.geom, tuple) and len(self.geom) == 2: return True return False def setGeom(self, geom): \"\"\"set Geometry, needs to be overloaded \"\"\" # test and set geometry value self.geom = geom if not self.test(): self.geom = (0.0, 0.0) p = Point() p.setGeom((5.5,1.1)) print p.gtype, p.geom print p try it","title":"Parent und Child"},{"location":"ch01/oop.html#aufgabenstellung-zu-klassen","text":"Erg\u00e4nzen Sie eine Klasse f\u00fcr Linien (class Line) implementieren Sie die Methoden init , test und setGeom testen Sie die neue Klasse \u00dcberlegen Sie, was zu tun ist, um Fehler zu vermeiden Wo k\u00f6nnen wir Fehler erwarten? Wie gehen wir mit ihnen um?","title":"Aufgabenstellung zu Klassen"},{"location":"ch01/oop.html#groe-module","text":"Ein Python-Script ist immer auch ein Modul. Wird in der Entwicklung ein Modul zu gro\u00df, so kann es auf mehrere Dateien aufgeteilt werden und kann per import wieder zusammengef\u00fchrt werden. Gro\u00dfe Module in Python k\u00f6nnen sich auch \u00fcber Ordner und Unterodner erstrecken, in denen jeweils wieder kleinere Module als Python-Scripte gespeichert sind. Diese werden auch als Packages bezeichnet. Ein Odner an sich speichert allerdings keinen Code und kann somit nicht importiert werden. Damit sich ein Ordner auch wie ein Modul verh\u00e4lt, wird in einem Python-Package eine spezielle Datei angelegt, die dem Pythoninterpreter deutlich macht, das dieser Ordner wie ein Modul zu behandeln ist, sie hei\u00dft __init__.py . Eine kompakte Darstellung finden wir hier Beispiel eines Python Packages auf programiz.com","title":"Gro\u00dfe Module"},{"location":"ch01/oop.html#import","text":"Module lassen sich in Python \u00fcber import in anderen Modules nutzen. Module und Packages werden normalerweise unter dem Ordner site-packages installiert. Weitere M\u00f6glichkeiten zum Import ist Speicherung von Modulen/Packages im selben Ordner, in dem auch das Python-Script gespeichert wurde oder ein Pfad, der im Environment der Shell (des Rechners) angegeben ist (Variablenname ist PYTHONPATH). Dieser kann auch in einem Script bearbeitet werden. Hierzu bietet das Standardmodul sys die Eigenschaft path an: sys.path ist eine Python-Liste mit den entsprechenden Pfadangaben.","title":"Import"},{"location":"ch01/oop.html#beispiel-modul-shapely","text":"Shapely ist ein Geometrie-Package f\u00fcr Python, welches sich durch sehr umfangreiche analytische Funktionen auszeichnet. Wir werden Shapely in diesem Kurs zwar nicht verwenden, k\u00f6nnen es aber studieren, um mehr \u00fcber gro\u00dfe Python-Module zu erfahren. Der Quell-Code liegt im site-package-Verzeichnis des GIS-Sticks unter osgeo4w/apps/Python27/Lib/site-packages, kann aber auch auf der Entwicklerplatform github eingesehen werden ( Shapely auf github ). Ein paar Ausz\u00fcge: __init__.py enth\u00e4lt lediglich eine Angabe zur Version __version__ = \"1.6.4.post1\" Welche Version liegt auf dem GIS-Stick? import shapely print shapely.__version__ Mit dem Shapely-Modul k\u00f6nnen Geometrien als WKT ausgegeben werden, hierzu existiert das Modul wkt.py, welches wiederum das Modul geos importiert: \"\"\"Load/dump geometries using the well-known text (WKT) format \"\"\" from shapely import geos # Pickle-like convenience functions def loads(data): \"\"\"Load a geometry from a WKT string.\"\"\" return geos.WKTReader(geos.lgeos).read(data) def load(fp): \"\"\"Load a geometry from an open file.\"\"\" data = fp.read() return loads(data) def dumps(ob, trim=False, **kw): \"\"\"Dump a WKT representation of a geometry to a string. See available keyword output settings in ``shapely.geos.WKTWriter``. \"\"\" return geos.WKTWriter(geos.lgeos, trim=trim, **kw).write(ob) def dump(ob, fp, **settings): \"\"\"Dump a geometry to an open file.\"\"\" fp.write(dumps(ob, **settings)) Unter algorithms/cga.py finden wi \u00fcbrigens einen alten Bekannten: Die Funktion signed_area(), sie l\u00e4sst sich folgenderma\u00dfen importieren: from shapely.algorithms.cga import signed_area","title":"Beispiel Modul-Shapely"},{"location":"ch01/p01_py_qgis.html","text":"Ziel der Veranstaltung Im Rahmen des zweiten Teils des Moduls GIS-Anwendungsentwicklung, geht es, wie am Ende des ersten Teils, um die Erweiterung von GIS-Systemen und deren Anpassung an neue Aufgaben. Wir haben mit der Scriptsprache Python bereits die grundlegenden Ans\u00e4tze kennengelernt, um solche Erweiterungen f\u00fcr das GIS ArcGIS zu programmieren, in diesem Semester wenden wir uns der wichtigen Gruppe der Open-Source-GIS zu. Am Bespiel von QGIS werden wir die notwendigen Grundlagen und Verfahren kennenlernen, um eine eigene Erweiterung in Form eines Plugins zu erstellen. St\u00e4rker als im letzten Semester werden informatischen Themen behandelt, wie: Systementwicklung/Projektmanagement Objektorientierung Internetkommunikation Benutzeroberfl\u00e4chen Datenbanken Diese zentralen Ans\u00e4tze bilden die Grundlage f\u00fcr viele GIS-Entwicklungen, sei es auf Basis eines Desktop- oder Web-GIS. Mit QGIS3 verwenden wir im Vergleich zu ArcGIS ein weiteres Desktop-System, dass eine viel gr\u00f6\u00dfere Integration der Sprache Python aufweist, als dies in ArcGIS gegeben ist. Entwicklungsbasis Python3 In K\u00fcrze wird die Entwicklung von Python2 eingestellt. Viele Entwickler haben deshalb bereits reagiert und ihre Nutzung von Python auf der Version 3 umgestellt. Dies trifft auch auf die in dieser Veranstaltung benutzte Software QGIS zu, die Python3 mit QGIS3 eingef\u00fchrt hat. Zu den Veranstaltungen der letzten Semester ergeben sich durch die ver\u00e4nderten Bedingungen einige \u00c4nderungen, die zu einer \u00fcberarbeiteten neuen Gliederung f\u00fchren. QGIS3 Die neue Version des GIS QGIS enth\u00e4lt einige Neuerungen, die neben der Umstellung auf Python3 auch die verwendete Bibliothek f\u00fcr Benutzeroberfl\u00e4chen betreffen: Qt. QGIS basiert sehr stark auf dieser Bibiothek, die nun in der Version Qt5 eingebunden ist. GIS-Stick: Gis2Go Die aktuelle Installation der verwendeten Programme wird als Portable Software angeboten. Dies bedeutet, dass sie auf einem USB-Stick gespeichert und an einem beliebigen Rechner mit Windows-Betriebssystem genutzt werden kann. Der aktuelle GIS-Stick ist zum Download nur innerhalb des Campus-Netzes verf\u00fcgbar. Die Adresse lautet: http://endor.uni-trier.de/karto/dl/gp/index.html Mein Tipp ist es, die komplette Installation zu verwenden. Benutzen Sie bereits eine Version des GIS-Sticks, ist es evtl. auch m\u00f6glich, die betroffenen Pakete zu aktualisieren. Eine Anleitung finden Sie jeweils auf der angegebenen Webseite. Python unter QGIS nutzen Hier wollen wir uns anschauen, wie die Python-Version, die mit QGIS ausgeliefert wurde, gestartet werden kann. Zun\u00e4chst in der Kommandozeile, dann in QGIS selbst: Wir starten die OSGEO4W-Shell (oder auch OSGEO4W Kommando-Konsole) und erhalten dieses Eingabefenster: Kommandozeile f\u00fcr OSGEO4W Um Python zu starten ben\u00f6tigen wir zwei Befehle: mit py3_env setzen wir die Umgebung f\u00fcr das installierte Python3 mit python3 starten wir den Interpreter Python 3.7.0 (v3.7.0:1bf9cc5093, Jun 27 2018, 04:06:47) [MSC v.1914 32 bit (Inte l)] on win32 Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> _ In diese Shell k\u00f6nnen nun Python-Anweisungen eingegeben werden. Mit der Tastenkombination oder dem Befehl quit() wird die Python-Shell wieder geschlossen. Idealerweise benutzen wir aber besser eine IDE, wie Idle oder PyScripter f\u00fcr solche Programmierarbeiten. Hinweis: Auf den Rechnern des CIP-Pools sind QGIS und Python in einer 64-bit Version installiert, es gibt jedoch keine installierte IDE. Wenn Sie den GIS-Stick verwenden, k\u00f6nnen Sie direkt den PyScripter aus dem PStart-Men\u00fc aufrufen. Andernfalls k\u00f6nnen sie sich den PyScripter in einem ihrer Ordner installieren und mit einem Batch-File starten. Die Batchdatei ist notwendig, damit PyScripter die korrekte Python-Version findet und benutzt. Eine ZIP-Datei stelle ich in der Veranstaltung zur Verf\u00fcgung. Eine weitere M\u00f6glichkeit besteht in der Verwendung von QGIS, das \u00fcber eine intergrierte Pythonshell verf\u00fcgt und einen einfachen Editor anbietet. Dies gibt uns zudem eine Gelegenheit, die Benutzeroberfl\u00e4che von QGIS anzuschauen.","title":"Python3 und QGIS"},{"location":"ch01/p01_py_qgis.html#ziel-der-veranstaltung","text":"Im Rahmen des zweiten Teils des Moduls GIS-Anwendungsentwicklung, geht es, wie am Ende des ersten Teils, um die Erweiterung von GIS-Systemen und deren Anpassung an neue Aufgaben. Wir haben mit der Scriptsprache Python bereits die grundlegenden Ans\u00e4tze kennengelernt, um solche Erweiterungen f\u00fcr das GIS ArcGIS zu programmieren, in diesem Semester wenden wir uns der wichtigen Gruppe der Open-Source-GIS zu. Am Bespiel von QGIS werden wir die notwendigen Grundlagen und Verfahren kennenlernen, um eine eigene Erweiterung in Form eines Plugins zu erstellen. St\u00e4rker als im letzten Semester werden informatischen Themen behandelt, wie: Systementwicklung/Projektmanagement Objektorientierung Internetkommunikation Benutzeroberfl\u00e4chen Datenbanken Diese zentralen Ans\u00e4tze bilden die Grundlage f\u00fcr viele GIS-Entwicklungen, sei es auf Basis eines Desktop- oder Web-GIS. Mit QGIS3 verwenden wir im Vergleich zu ArcGIS ein weiteres Desktop-System, dass eine viel gr\u00f6\u00dfere Integration der Sprache Python aufweist, als dies in ArcGIS gegeben ist.","title":"Ziel der Veranstaltung"},{"location":"ch01/p01_py_qgis.html#entwicklungsbasis","text":"","title":"Entwicklungsbasis"},{"location":"ch01/p01_py_qgis.html#python3","text":"In K\u00fcrze wird die Entwicklung von Python2 eingestellt. Viele Entwickler haben deshalb bereits reagiert und ihre Nutzung von Python auf der Version 3 umgestellt. Dies trifft auch auf die in dieser Veranstaltung benutzte Software QGIS zu, die Python3 mit QGIS3 eingef\u00fchrt hat. Zu den Veranstaltungen der letzten Semester ergeben sich durch die ver\u00e4nderten Bedingungen einige \u00c4nderungen, die zu einer \u00fcberarbeiteten neuen Gliederung f\u00fchren.","title":"Python3"},{"location":"ch01/p01_py_qgis.html#qgis3","text":"Die neue Version des GIS QGIS enth\u00e4lt einige Neuerungen, die neben der Umstellung auf Python3 auch die verwendete Bibliothek f\u00fcr Benutzeroberfl\u00e4chen betreffen: Qt. QGIS basiert sehr stark auf dieser Bibiothek, die nun in der Version Qt5 eingebunden ist.","title":"QGIS3"},{"location":"ch01/p01_py_qgis.html#gis-stick-gis2go","text":"Die aktuelle Installation der verwendeten Programme wird als Portable Software angeboten. Dies bedeutet, dass sie auf einem USB-Stick gespeichert und an einem beliebigen Rechner mit Windows-Betriebssystem genutzt werden kann. Der aktuelle GIS-Stick ist zum Download nur innerhalb des Campus-Netzes verf\u00fcgbar. Die Adresse lautet: http://endor.uni-trier.de/karto/dl/gp/index.html Mein Tipp ist es, die komplette Installation zu verwenden. Benutzen Sie bereits eine Version des GIS-Sticks, ist es evtl. auch m\u00f6glich, die betroffenen Pakete zu aktualisieren. Eine Anleitung finden Sie jeweils auf der angegebenen Webseite.","title":"GIS-Stick: Gis2Go"},{"location":"ch01/p01_py_qgis.html#python-unter-qgis-nutzen","text":"Hier wollen wir uns anschauen, wie die Python-Version, die mit QGIS ausgeliefert wurde, gestartet werden kann. Zun\u00e4chst in der Kommandozeile, dann in QGIS selbst: Wir starten die OSGEO4W-Shell (oder auch OSGEO4W Kommando-Konsole) und erhalten dieses Eingabefenster: Kommandozeile f\u00fcr OSGEO4W Um Python zu starten ben\u00f6tigen wir zwei Befehle: mit py3_env setzen wir die Umgebung f\u00fcr das installierte Python3 mit python3 starten wir den Interpreter Python 3.7.0 (v3.7.0:1bf9cc5093, Jun 27 2018, 04:06:47) [MSC v.1914 32 bit (Inte l)] on win32 Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> _ In diese Shell k\u00f6nnen nun Python-Anweisungen eingegeben werden. Mit der Tastenkombination oder dem Befehl quit() wird die Python-Shell wieder geschlossen. Idealerweise benutzen wir aber besser eine IDE, wie Idle oder PyScripter f\u00fcr solche Programmierarbeiten. Hinweis: Auf den Rechnern des CIP-Pools sind QGIS und Python in einer 64-bit Version installiert, es gibt jedoch keine installierte IDE. Wenn Sie den GIS-Stick verwenden, k\u00f6nnen Sie direkt den PyScripter aus dem PStart-Men\u00fc aufrufen. Andernfalls k\u00f6nnen sie sich den PyScripter in einem ihrer Ordner installieren und mit einem Batch-File starten. Die Batchdatei ist notwendig, damit PyScripter die korrekte Python-Version findet und benutzt. Eine ZIP-Datei stelle ich in der Veranstaltung zur Verf\u00fcgung. Eine weitere M\u00f6glichkeit besteht in der Verwendung von QGIS, das \u00fcber eine intergrierte Pythonshell verf\u00fcgt und einen einfachen Editor anbietet. Dies gibt uns zudem eine Gelegenheit, die Benutzeroberfl\u00e4che von QGIS anzuschauen.","title":"Python unter QGIS nutzen"},{"location":"ch01/p02_entwicklung.html","text":"Grundlagen der Systementwicklung Im Grunde ist die Systementwicklung ein Spezialfall f\u00fcr das Projektmanagement. Allerdings wurden in der Informatik Modelle und Methoden sowie spezielle Werkzeuge entwickelt, die bei der Durchf\u00fchrung von Softwareprojekten zum Einsatz kommen. Wir haben es beim Projektmanagement mit einem Prozess zu tun, in dessen Verlauf mehrere Phasen durchlaufen werden. Ein bekanntes Modell zum Ablauf einer Softwareentwicklung ist das Wasserfallmodell: -> Idee/Inital -> Entwurf -> Umsetzung -> Test -> Ver\u00f6ffentlichung Beginn: die Idee oder Aufgabenstellung. Projektinitialisierung. Phase des Entwurf: Planung, Konkretiserung und detaillierte Beschreibung. Phase der Umsetzung: auf Grundlage des Entwurfs, Realisierung und Programmierung. Phase des Testens: \u00dcberpr\u00fcfung der Software auf Fehler letzte Phase: Ver\u00f6ffentlichung: Software wird Anwendern zur Verf\u00fcgung gestellt Andere Modelle gehen mehr in Zyklen vor oder stellen das Prototyping in den Vordergrund, beides sinnvolle Erweiterungen des starren Wasserfallmodells. Der Entwurf Wie gut ist ein Entwurf? Darf man den Entwurf ver\u00e4ndern? Was macht man, wenn neue Rahmenbedinghungen auftreten? Beispiel: Flughafen BER Lexikon des Wahnsinns Die Umsetzung Welche Tools werden eingesetzt? Wie wird Code geschrieben und dokumentiert? Beherrscht das Team alle notwendigen Tools? Welche Tests sind w\u00e4hrend der Entwicklung angedacht? Gibt es einen festen Ablauf? Wie sieht die tool chain aus, welche Code-Verwaltung wird verwendet? Tests Tests dienen der Gew\u00e4hrleistung von Stabilit\u00e4t, der Vermeidung von Fehlern! Welche M\u00f6glichkeitendes Debugging sind m\u00f6glich? Problematisch sind Web-Projekte, Plugins oder Benutzeroberfl\u00e4chen... Welche Tests werden durchgef\u00fchrt? Praktikabel ist das sog. unit testing (Modultest), also das Testen m\u00f6glichst aller Systemelemente unter denkbaren fehlerhaften Bedingungen. Ver\u00f6ffentlichung Release: eine gepr\u00fcfte und getestete Version einer Software Wie und wo wird ver\u00f6fentlicht? z.B. auf einer Homepage, in einem Repository Was hat sich zum letzten Realease ge\u00e4ndert? Versionsnummer, change log Wie wird die Software dokumentiert und begleitet? Dokumentation, Support Entwicklung unter Python Grundbegriffe: Package - A folder/directory that contains __init__.py file. Module - A valid python file with .py extension. Distribution - How one package relates to other packages and modules. Application - Has a fuzzy meaning: simple: an executable software, more specific: an software executable (Windows: .exe) user oriented: a software with a user interface Python und der Entwurf Objektorientierung: Klassenstruktur anlegen mit Eigenschaften und Methoden, Fr\u00fche Hinterfragung aus Sicht der Umsetzung Benutzeroberf\u00e4chen: Prototyping, um mit Nutzern den Entwurf diskutieren zu k\u00f6nnen Pflichtenheft: Anforderungsdefinition und Plan zur Umsetzung, Start einer Dokumentation Beispiel: Eine Entwicklung von meinProjekt als Python-Package: Erstellen eines Ordners meinProjekt , darin: Anlegen der Datei __init__.py Anlegen des Moduls meinModul.py Python und die Umsetzung Werkzeuge Editoren, IDE's Debugger, Logger Tests -> unittest, assert Code Regeln: Python Enhancement Proposals: PEP, vor allem PEP8: Style Guide for Python Code \"code is read much more often than it is written\" PEP8 ist sehr vollst\u00e4ndig, aber es kann auch \u00fcbertrieben werden... Kommentare, die erl\u00e4utern, was im Code passiert, auch documentation strings (\"docstrings\") Benennung von Modulen, Klassen, Funktionen, Variablen, etc. Beispiele f\u00fcr Namen: Beispiel Erl\u00e4uterung b single lowercase letter B single uppercase letter lowercase lower_case_with_underscores UPPERCASE UPPER_CASE_WITH_UNDERSCORES CapitalizedWords CapWords, or CamelCase acronyms capitalize: HTTPServerError better than HttpServerError mixedCase Capitalized_Words_With_Underscores Wichtig: Konsistenz in der Verwendung! Werkzeug: pylint -> python modul, \u00fcberwacht pep8, in IDE's integriert oder standalone, pylint Homepage Aufbau einer Ordnerstruktur innerhalb des Projekts f\u00fcr hierarchischen Aufbau von Modulen, nach Abh\u00e4ngigkeiten Kollaboration und Versionsverwaltung Codeverwaltung, gemeinsames Arbeiten an Code, Versionsverwaltung Beispiel: git git , ein \"distributed revision control system\" (System zur verteilten Versionsverwaltung). Bekannt geworden durch die github-Platform, l\u00e4uft aber vor allem auch lokal. Wir m\u00fcssen uns daf\u00fcr vorstellen, dass wir eine Entwicklung so durchf\u00fchren, dass jede \u00c4nderung an einem Projekt als Version gespeichert und kommentiert wird. Es gibt immer einen aktuellen Stand des Projekts, aber alle zuvor bearbeiteten Versionen bleiben erhalten. Git arbeitet zun\u00e4chst auf der Ebene von Ordnern, der Hauptordner ist dann das Repository (git Befehl init ). Bearbeitet und dokumentiert werden haupts\u00e4chlich Textdateien (also z.B. die Phython-Module in eine Package, html-Dateien einer website etc.), wobei jede zu \u00fcberwachende Datei mit add zu einem git-Repository hinzugef\u00fcgt wird. Um erfolgreich mit git zu arbeiten, m\u00fcssen die Beteiligten die eigene Arbeitsweise \u00e4ndern, sie gewinnen aber daf\u00fcr eine gewisse Sicherheit, Fehler nachvollziehbar zur\u00fcckzuverfolgen. Jeder Arbeitsschritt wird von den Beteiligten \u00fcber git kommentiert, in git hei\u00dft dies commit . Dadurch entsteht in git eine Kette von dokumentierten \u00c4nderungen, der letzte Stand ist der head . Mit status l\u00e4sst sich u.a. pr\u00fcfen, ob noch \u00c4nderungen mit commit eingepflegt werden m\u00fcssen. Ein wesentlicher Vorteil ist es jedoch, den Code auch in der Cloud zu speichern, um ihn zwischen Personen teilen zu k\u00f6nnen. Hierf\u00fcr sieht git den remote vor, ein z.B. auf github gespeichertes Repository. Um diesen Remote zu bearbeiten, verwendet git die Befehle pull , um den entfernten Code herunterzuladen, push , um den eigenen lokalen Stand auf github abzulegen. Damit die \u00c4nderung nicht unkontrolliert \u00fcbernommen wird, muss ein merge ausgef\u00fchrt werden. Ein Merge ist so etwas wie ein Vorschlag zur \u00dcbernahme, d.h. er kann von anderen eingesehen, diskutiert und bewertet werden, bevor die \u00c4nderungen dann schlie\u00dflich zum aktuellen head werden. Eine lockere Einf\u00fchrung in git bietet Neil Kakkar auf medium oder die Einf\u00fchrung von Daniel Miessler . Um git zu installieren, k\u00f6nnen wir die letzte Version von git-scm beziehen. F\u00fcr eine portable Nutzung schlage ich die Version 32-bit Git for Windows Portable vor. Git for Windows baut auf der bekannten Unix-Shell f\u00fcr windows msys auf, die, neben git, viele Unix-Shell-Befehle mit bringt. Beispiel Um PortableGit nutzen zu k\u00f6nnen, staren wir zun\u00e4chst die Kommandozeile mit git-cmd.exe . Wir wechseln dann in einen Ordner, indem wir ein git-Repository erstellen m\u00f6chten: > c: > cd c:\\temp > mkdir gittest > cd gittest Jetzt gehts erst richtig los. Wir erstellen ein git-Repository und f\u00fcgen eine Datei hinzu: > git init Initialized empty Git repository in c:/temp/gittest/.git/ > echo print(\"Hello GIT!\") > hello.py > git add hello.py Schauen wir mal nach, was hier passiert ist. Wir \u00f6ffnen hierzu den Windows-Explorer und wechseln in den Pfad unseres Repositories. Evtl. \u00e4ndern wir die Windows Ordner- und Suchoptionen , sodass wir auch versteckte Dateien und Ordner angezeigt bekommen: - .git Dateiordner - hello.py Python File Zus\u00e4tzlich k\u00f6nnen wir in der git-Shell mit status eben diesen abfragen: > git status On branch master No commits yet Changes to be committed: (use \"git rm --cached <file>...\" to unstage) new file: hello.py Der Aufforderung unsere Aktion zu kommentieren kommen wir gerne nach: git commit dies \u00f6ffnet den Unix-Editor vi. Die Bedienung ist sehr speziell! Wir gehen mit den Pfeiltasten in die letzte angzeigte Zeile und tippen ein o , um eine neue Zeile einzuf\u00fcgen. Dachnach d\u00fcrfen wir die Pfeiltasten nicht meher verwenden, wir sind nun im Schreibmodus! Wir schreiben: First Module added und dr\u00fccken die Taste <Esc> . Wir haben den Schreibmodus verlassen. Im vi wechseln wir mit : in den Kommandomodus und tippen wq f\u00fcr write and quit . Vi speichert den commit und wir kehren zum Prompt zur\u00fcck: > git status On branch master nothing to commit, working tree clean Alternativ gibt es auch eine GUI-Version: git-gui.exe, mit der die meisten Dinge auch erlidigt werden k\u00f6nnen! > git-gui Git-Gui Benutzeroberfl\u00e4che Da dies nur einen kleinen Einblick geben soll, beenden wir unsere Experimente mit git! Die n\u00e4chsten Schritte w\u00e4ren: die Dokumentaion zu git lesen einen git-cloud Dienst verwenden (z.B. durch eine Anlmeldung bei github) die Benutzerdaten in git hinterlegen einen push ausf\u00fchren, um das Repository hochzuladen 3rd party Module Anstelle von Standardmodulen sinnvoll, wenn Funktionalit\u00e4t fehlt, aber: Python-Entwicklung mit Modulen, die ihrerseits beim Kunden installiert werden m\u00fcssen Manche Module haben Abh\u00e4ngigkeiten zu DLL's, die aus C/C++-Entwicklung stammen, m\u00fcssen in der jeweilgen Version auch beim Kunden installiert sein oder sie werden bei der Installation zus\u00e4tzlich \u00fcbersetzt (pip macht das, setzt aber bspw. Compiler auf dem Rechner voraus): z.B.: Fiona f\u00fcr GDAL/OGR virtual environments: eine von einer Hauptinstallation abgeleitete \"virtuelle\" Pythoninstallation. Im Wesentlichen, um Module zu testen/benutzen, ohne dass diese die Hauptinstallation ver\u00e4ndern. VirtualEnv kann als python module installiert werden. Achtung: IDE's unterst\u00fctzen nicht alle virtual environments! Unter OSGEO4W h\u00e4ngen viele Module von anderen Installationen ab und bed\u00fcrfen einer speziellen Umgebung (environment variables). A non-magical introduction ... Um virtualenv unter OSGEO4W zu nutzen, gehen wir wie folgt vor: Wir starten eine OSGEO4W-Kommandofenster und installieren virtualenv mit pip > py3_env > pip install virtualenv Collecting virtualenv Downloading https://files.pythonhosted.org/packages/33/5d/314c760d4204f64e4a96 8275182b7751bd5c3249094757b39ba987dcfb5a/virtualenv-16.4.3-py2.py3-none-any.whl (2.0MB) 100% |--------------------------------| 2.0MB 4.3MB/s Installing collected packages: virtualenv Successfully installed virtualenv-16.4.3 You are using pip version 18.1, however version 19.0.3 is available. You should consider upgrading via the 'python -m pip install --upgrade pip' comm and. Dann wechseln wir in einen Ordner, in dem wir die virtuelle Umgebung einrichten m\u00f6chten: > c: > cd c:\\temp > mkdir vpytest > python -m venv Folgendes wird im Windows-Explorer angezeigt: + vpy + Include + Lib + Scripts - pyenv.cfg Im Unterordner Scripts finden wir u.a. activate.bat und deactivate.bat, mit denen wir die virtuelle Umgebung starten und wieder schlie\u00dfen k\u00f6nnen: > vpy\\Scripts\\activate.bat (vpy) c:\\temp\\vpytest> > vpy\\Scripts\\deactivate.bat Der ver\u00e4nderte Prompt (vpy) c:\\temp\\vpytest> zeigt an, dass die virtuelle Umgebung gestartet wurde. Um in diesem Ordner die OSGEO4W-Shell zusammen mit vpy verwenden zu k\u00f6nnen, nutze ich eine kleine Batch-Datei shell.bat im Verzeichnis c:\\temp\\vpytest , die auch \u00fcber den Explorer ausgef\u00fchrt werden kann: set pyhome=g:\\gp190225\\osgeo4w call %pyhome%\\bin\\o4w_env.bat call %pyhome%\\bin\\py3_env.bat call %~dp0\\vpy\\scripts\\activate.bat cls cmd.exe /k Sie m\u00fcssen pyhome so setzen, das der dort angegebene Pfad auf ihren GIS-Stick verweist! Das Problem mit virtualenv ist, dass es nicht portable ist. \u00c4ndert sich der Laufwerksbuchstabe des GIS-Sticks, so m\u00fcssten wir an verschiedenen Stellen Ver\u00e4nderungen vornehmen. Nur zum \u00dcberblick: shell.bat: Verwendet Laufwerksbuchstaben. L\u00f6sung: Virtuelle Umgebung auf dem Stick anlegen, und anstelle der Laufwerksangabe g: den Parameter %~d0 verwenden, sodass es hei\u00dft set pyhome=%~d0\\gp190225\\osgeo4w orig_prefix: Datei: vpy\\Lib\\orig_prefix.txt enth\u00e4lt eine absolute Pfadangabe und muss ge\u00e4ndert werden. Befindet sich die virtuelle Umgebung auf dem Stick, so dann die Laufwerksangabe weggelassen werden. Scripts: Exe-Dateien in vpy\\Scripts enthalten einen absoluten Pfad zu python.exe imselben Verzeichnis. Kann zu !python.exe verk\u00fcrzt werden. Im Falle von pip sollte ohne Anpassung der Befehl python -m pip verwendet werden. Nun k\u00f6nnen wir innerhalb der virtuellen Umgebung Module installieren und testen, ohne dass die \u00fcbergeordnete Python-Installation dadurch ver\u00e4ndert wird. Fiona ist ein Modul, dass \u00fcber pip \"nachinstalliert\" werden kann. Fiona vereinfacht den Umgang mit den Funktionen aus der gdal-Vektor-Bibliothek ogr und gilt als more pythonic als die OSGEO python-Schnittstelle. Hier eine kurze Anleitung zur Installation: Zun\u00e4chst ist Fiona von der installierten GDAL-Version abh\u00e4ngig, unter Windows z.B. die aktuelle in OSGEO4W neben dem offiziellen Repositorium f\u00fcr pip existiert eine Sammlung von Python-Modulen f\u00fcr Windows Christoph Grohlke , hier finden wir etvtl. die passende Version. > gdalinfo --version GDAL 2.4.1, released 2019/03/15 Abfrage der GDAL-Version in unserer Virtuellen Umgebung . Auf der Webseite von Herrn Grohlke suchen wir nach Fiona und finden Fiona-1.8.6-cp37-cp37m-win32.whl. Leider erfahren wir nicht, welche GDAL-Version hier benutzt wurde... Wir laden die Datei herunter, speichern sie im vpytest-Ordner um sie mit pip zu installieren: > python -m pip install Fiona-1.8.6-cp37-cp37m-win32.whl Die Prozedur erzeugt eine Menge von Meldungen, installiert aber Fiona unter vpy\\Lib\\site-packages Wir testen, ob fiona mit python importiert werden kann: python -c \"import fiona\" Wenn dort keine Fehler gemeldet werden, haben wir fiona erfolgreich installiert! Um das Modul evtl. wieder zu entfernen, k\u00f6nnen wir pip mit dem Parameter uninstall aufrufen: python -m pip uninstall fiona Wollen wir bspw. PyScripter als IDE in der virtuellen Umgebung nutzen, m\u00fcssen wir auch hier eine Batchdatei verwenden: @echo off set mystick=J:\\gp190225 set pyhome=%mystick%\\osgeo4w set scripter=%mystick%\\Pyscripter call %pyhome%\\bin\\o4w_env.bat call %pyhome%\\bin\\py3_env.bat call %~dp0\\vpy\\scripts\\activate.bat set PYTHONPATH=%VIRTUAL_ENV%\\Lib\\site-packages pushd %scripter% start \"PyScripter\" PyScripter.exe --PYTHON37 --pythondllpath=%pyhome%\\apps\\python37 popd call %~dp0\\vpy\\scripts\\deactivate.bat Tool chain Python scripte ben\u00f6tigen selten eine tool chain Umfangreiche Projekte hingegen schon In der IDE integrierte Tools: z.B.: wird in mehreren Dateien editiert, so m\u00fcssen diese beim Start des main scripts auch in der aktuelle Version import werden. auch eine Codeverwaltung wie git ist Teil einer tool chain Beispiel: make -> in msys package from osgeo4w Abarbeitung eines makefiles (kommt von unix, C-Compiler): - alle Schritte/Befehle die zur Erstellung der Software n\u00f6tig sind - definiert Regeln, z.B. Abh\u00e4ngigkeiten, die gegeben sein m\u00fcssen, bestimmte Aufgaben, die durchgef\u00fchrt werden sollen (make test, make install, make clean, etc.) Makefiles in python projects \u00e4hnlich: setup.py wird f\u00fcr python packages benutzt, die von einem Entwickler/Nutzer in die eigene Python-Installation integriert werden soll. Innerhalb des setup scripts k\u00f6nnen Anforderungen \u00fcberpr\u00fcft und die Installation des packages ausgef\u00fchrt werden. -> passt auch zu \"Ver\u00f6ffentlichung\", vgl. auch \"pip\" stackoverflow: What is setup.py? Python und Tests Einfache Module, die nicht ausf\u00fchrbar sind, also nur zum import bestimmt sind, k\u00f6nnen innerhalb des Moduls Tests vorsehen, indem sie die Abfrage if __name__ == '__main__': den Tests voranstellen. Beispiel: F\u00fcr unser Projekt benutzen wir das Package mit den Unterordnern und Modulen meinProjekt - `__init__.py` - `meinModul.py` __init__.py # -*- coding: utf-8 -*- from .meinModul import MeineClass meinModul.py class MeineClass(object): def beispiel(self, string=\"\"): print(string) return True print (__name__) if __name__ == \"__main__\": m = MeineClass() m.beispiel(\"u see\") Somit kann jede Funktion der Klasse getestet werden. Der Code-Block unterhalb des if statements wird nur ausgef\u00fchrt, wenn wir das zugeh\u00f6rige Modul ausf\u00fchren (Run in IDE, phython meinModul.py in der shell ), nicht wenn es importiert wird ( __name__ ist der Modulename, er wird im Falle einer Ausf\u00fchrung in __main__ ge\u00e4ndert). Test eines Imports aus einem Package, wir legen eine neue Datei an: useMeinProjekt.py meinProjekt - `__init__.py` - `meinModul.py` useMeinProjekt.py: # -*- coding: utf-8 -*- from meinProjekt.meinModul import MeineClass m = MeineClass() m.beispiel(\"Tada!\") Testing Beispiel Ein f\u00fcr Python vorgesehener Weg ist die Verwendnung von unit tests : \"Beim Schreiben von Unit-Tests mit Hilfe des unittest-Pakets wird zu jedem Modul modulname.py ein entsprechendes Test-Modul test_modulname.py, mit dessen Hilfe die im Hauptmodul enthaltenen Funktionen getestet werden k\u00f6nnen. Alle diese so genannten Unit Tests sollten voneinander unabh\u00e4ngig sein.\" debugging, logging, testing Sinnvoll ist zudem die Arbeit mit der assert-Anweisung, welche einen Ausdruck testet, indem sie ihn mit einem erwarteten Ergebnis vergleicht. Beispiel: F\u00fcr unser Projekt erweitern wir das Package mit diesen zus\u00e4tzlichen Ordnern und Modulen meinProjekt - `__init__.py` - `meinModul.py` + tests - `__init__.py` - test_init.py - test_meinModul.py Innerhalb des Unterordners test werden nun die \u00dcberpr\u00fcfungen eingerichtet: In unserem Fall werden wir verschiedene Techniken einsetzen: Python-Modul logging , um Meldungen in einer Txtdatei zu speichern Python-Anweisung assert , um die R\u00fcckgabe von Methoden zu testen/benutzen Python-Modul unittest , um den Testablauf zu automatisieren Nat\u00fcrlich ist der Einsatz dieser Tools kein Muss , sondern soll aufzeigen, welche Testm\u00f6glichkeiten, und es sind l\u00e4ngst nicht alle, dem Python-Entwickler zur Verf\u00fcgung stehen. test/__init__.py # ich bleibe leer test/test_meinModul.py import unittest import logging # Basis-Einstellungen festlegen: logging.basicConfig(filename='meintest_log.txt', format='%(levelname)s: %(message)s', level=logging.INFO) LOG = logging.getLogger(\"mein_test\") from meinProjekt import MeineClass class MeineClassTest(unittest.TestCase): def setUp(self): \"\"\"runs before each test\"\"\" # create an object self.theClass = MeineClass() def test_beispiel(self): try: assert self.theClass.beispiel() == True except AssertionError as e: LOG.error(\"test_beispiel scheiterte: %s\"%str(e)) else: LOG.info(\"test_beispiel bestanden!\") def tearDown(self): \"\"\"runs after each test\"\"\" self.theClass = None if __name__ == '__main__': unittest.main() Unser Test startet mit unittest.main() und erzeugt eine Log-Datei test/meintest_log.txt . Bevor unser einziger Test startet, wird setUp() ausgef\u00fchrt, nach dem Test noch tearDown() . Meldungen werden nicht mit print ausgegeben, sondern immer in die log-Datei geschrieben. Nur die Meldungen des Unittest-Moduls erscheinen auf der Konsole. Getestet wird mit die Methode beispiel in test_beispiel, assert pr\u00fcft, ob die Methode True oder False zur\u00fcckgibt und erzeugt einen Fehler, falls das Ergebnis False ist wir verwenden try...except, um diesen Fehler abzufangen Ver\u00f6ffentlichung von Python-Projekten Ziel einer Entwicklung mit Python w\u00e4re eine Ver\u00f6ffentlichung als Python-Package, so dass es \u00fcber ein setup.py installiert werden kann es in einem package format vorliegt, z.B. als whl-Datei (eine Art ZIP-Datei) f\u00fcr die Installation mit pip, genutzt werden kann es auf einer Plattform, wie github oder dem Python Package Index (PyPI) gespeichert wird und von wo es herutergeladen und installiert werden kann. Anzumerken sei, dass es auch m\u00f6glich ist auch ausf\u00fchrbare Programme aus Python-Modulen oder -Packages zu bekommen. Hierf\u00fcr stehen verschiedene Optionen zur Verf\u00fcgung, bekannte M\u00f6glichkeiten sind: Verwendung von __main__.py in einem Package, so dass bei der Ausf\u00fchrung mit python -m packagename __main__ als Startpunkt ausgew\u00e4hlt wird. Idle kann z.B. auf diese Weise gestartet werden. Erstellung einer ausf\u00fchrbaren Datei, unter Windows als .exe, so dass das Programm auch ohne installiertes Python auf einem Rechner ausgef\u00fchrt werden kann. Dies leistet etwa pyinstaller . Fazit Schlie\u00dflich k\u00f6nnen die dargestellten Phasen auch auf die Entwicklung mit Python und QGIS \u00fcbertragen werden. Die GIS-spezifischen Anforderungen werden wir im Laufe der Lehrveranstaltung kennenlernen. # QGIS-Entwicklung ## debugging ## processing scripts ## plugins ### plugin builder ### plugin reloader ## standalone applications","title":"Anwendungsentwicklung"},{"location":"ch01/p02_entwicklung.html#grundlagen-der-systementwicklung","text":"Im Grunde ist die Systementwicklung ein Spezialfall f\u00fcr das Projektmanagement. Allerdings wurden in der Informatik Modelle und Methoden sowie spezielle Werkzeuge entwickelt, die bei der Durchf\u00fchrung von Softwareprojekten zum Einsatz kommen. Wir haben es beim Projektmanagement mit einem Prozess zu tun, in dessen Verlauf mehrere Phasen durchlaufen werden. Ein bekanntes Modell zum Ablauf einer Softwareentwicklung ist das Wasserfallmodell: -> Idee/Inital -> Entwurf -> Umsetzung -> Test -> Ver\u00f6ffentlichung Beginn: die Idee oder Aufgabenstellung. Projektinitialisierung. Phase des Entwurf: Planung, Konkretiserung und detaillierte Beschreibung. Phase der Umsetzung: auf Grundlage des Entwurfs, Realisierung und Programmierung. Phase des Testens: \u00dcberpr\u00fcfung der Software auf Fehler letzte Phase: Ver\u00f6ffentlichung: Software wird Anwendern zur Verf\u00fcgung gestellt Andere Modelle gehen mehr in Zyklen vor oder stellen das Prototyping in den Vordergrund, beides sinnvolle Erweiterungen des starren Wasserfallmodells.","title":"Grundlagen der Systementwicklung"},{"location":"ch01/p02_entwicklung.html#der-entwurf","text":"Wie gut ist ein Entwurf? Darf man den Entwurf ver\u00e4ndern? Was macht man, wenn neue Rahmenbedinghungen auftreten? Beispiel: Flughafen BER Lexikon des Wahnsinns","title":"Der Entwurf"},{"location":"ch01/p02_entwicklung.html#die-umsetzung","text":"Welche Tools werden eingesetzt? Wie wird Code geschrieben und dokumentiert? Beherrscht das Team alle notwendigen Tools? Welche Tests sind w\u00e4hrend der Entwicklung angedacht? Gibt es einen festen Ablauf? Wie sieht die tool chain aus, welche Code-Verwaltung wird verwendet?","title":"Die Umsetzung"},{"location":"ch01/p02_entwicklung.html#tests","text":"Tests dienen der Gew\u00e4hrleistung von Stabilit\u00e4t, der Vermeidung von Fehlern! Welche M\u00f6glichkeitendes Debugging sind m\u00f6glich? Problematisch sind Web-Projekte, Plugins oder Benutzeroberfl\u00e4chen... Welche Tests werden durchgef\u00fchrt? Praktikabel ist das sog. unit testing (Modultest), also das Testen m\u00f6glichst aller Systemelemente unter denkbaren fehlerhaften Bedingungen.","title":"Tests"},{"location":"ch01/p02_entwicklung.html#veroffentlichung","text":"Release: eine gepr\u00fcfte und getestete Version einer Software Wie und wo wird ver\u00f6fentlicht? z.B. auf einer Homepage, in einem Repository Was hat sich zum letzten Realease ge\u00e4ndert? Versionsnummer, change log Wie wird die Software dokumentiert und begleitet? Dokumentation, Support","title":"Ver\u00f6ffentlichung"},{"location":"ch01/p02_entwicklung.html#entwicklung-unter-python","text":"Grundbegriffe: Package - A folder/directory that contains __init__.py file. Module - A valid python file with .py extension. Distribution - How one package relates to other packages and modules. Application - Has a fuzzy meaning: simple: an executable software, more specific: an software executable (Windows: .exe) user oriented: a software with a user interface","title":"Entwicklung unter Python"},{"location":"ch01/p02_entwicklung.html#python-und-der-entwurf","text":"Objektorientierung: Klassenstruktur anlegen mit Eigenschaften und Methoden, Fr\u00fche Hinterfragung aus Sicht der Umsetzung Benutzeroberf\u00e4chen: Prototyping, um mit Nutzern den Entwurf diskutieren zu k\u00f6nnen Pflichtenheft: Anforderungsdefinition und Plan zur Umsetzung, Start einer Dokumentation Beispiel: Eine Entwicklung von meinProjekt als Python-Package: Erstellen eines Ordners meinProjekt , darin: Anlegen der Datei __init__.py Anlegen des Moduls meinModul.py","title":"Python und der Entwurf"},{"location":"ch01/p02_entwicklung.html#python-und-die-umsetzung","text":"","title":"Python und die Umsetzung"},{"location":"ch01/p02_entwicklung.html#werkzeuge","text":"Editoren, IDE's Debugger, Logger Tests -> unittest, assert","title":"Werkzeuge"},{"location":"ch01/p02_entwicklung.html#code","text":"Regeln: Python Enhancement Proposals: PEP, vor allem PEP8: Style Guide for Python Code \"code is read much more often than it is written\" PEP8 ist sehr vollst\u00e4ndig, aber es kann auch \u00fcbertrieben werden... Kommentare, die erl\u00e4utern, was im Code passiert, auch documentation strings (\"docstrings\") Benennung von Modulen, Klassen, Funktionen, Variablen, etc. Beispiele f\u00fcr Namen: Beispiel Erl\u00e4uterung b single lowercase letter B single uppercase letter lowercase lower_case_with_underscores UPPERCASE UPPER_CASE_WITH_UNDERSCORES CapitalizedWords CapWords, or CamelCase acronyms capitalize: HTTPServerError better than HttpServerError mixedCase Capitalized_Words_With_Underscores Wichtig: Konsistenz in der Verwendung! Werkzeug: pylint -> python modul, \u00fcberwacht pep8, in IDE's integriert oder standalone, pylint Homepage Aufbau einer Ordnerstruktur innerhalb des Projekts f\u00fcr hierarchischen Aufbau von Modulen, nach Abh\u00e4ngigkeiten","title":"Code"},{"location":"ch01/p02_entwicklung.html#kollaboration-und-versionsverwaltung","text":"Codeverwaltung, gemeinsames Arbeiten an Code, Versionsverwaltung Beispiel: git git , ein \"distributed revision control system\" (System zur verteilten Versionsverwaltung). Bekannt geworden durch die github-Platform, l\u00e4uft aber vor allem auch lokal. Wir m\u00fcssen uns daf\u00fcr vorstellen, dass wir eine Entwicklung so durchf\u00fchren, dass jede \u00c4nderung an einem Projekt als Version gespeichert und kommentiert wird. Es gibt immer einen aktuellen Stand des Projekts, aber alle zuvor bearbeiteten Versionen bleiben erhalten. Git arbeitet zun\u00e4chst auf der Ebene von Ordnern, der Hauptordner ist dann das Repository (git Befehl init ). Bearbeitet und dokumentiert werden haupts\u00e4chlich Textdateien (also z.B. die Phython-Module in eine Package, html-Dateien einer website etc.), wobei jede zu \u00fcberwachende Datei mit add zu einem git-Repository hinzugef\u00fcgt wird. Um erfolgreich mit git zu arbeiten, m\u00fcssen die Beteiligten die eigene Arbeitsweise \u00e4ndern, sie gewinnen aber daf\u00fcr eine gewisse Sicherheit, Fehler nachvollziehbar zur\u00fcckzuverfolgen. Jeder Arbeitsschritt wird von den Beteiligten \u00fcber git kommentiert, in git hei\u00dft dies commit . Dadurch entsteht in git eine Kette von dokumentierten \u00c4nderungen, der letzte Stand ist der head . Mit status l\u00e4sst sich u.a. pr\u00fcfen, ob noch \u00c4nderungen mit commit eingepflegt werden m\u00fcssen. Ein wesentlicher Vorteil ist es jedoch, den Code auch in der Cloud zu speichern, um ihn zwischen Personen teilen zu k\u00f6nnen. Hierf\u00fcr sieht git den remote vor, ein z.B. auf github gespeichertes Repository. Um diesen Remote zu bearbeiten, verwendet git die Befehle pull , um den entfernten Code herunterzuladen, push , um den eigenen lokalen Stand auf github abzulegen. Damit die \u00c4nderung nicht unkontrolliert \u00fcbernommen wird, muss ein merge ausgef\u00fchrt werden. Ein Merge ist so etwas wie ein Vorschlag zur \u00dcbernahme, d.h. er kann von anderen eingesehen, diskutiert und bewertet werden, bevor die \u00c4nderungen dann schlie\u00dflich zum aktuellen head werden. Eine lockere Einf\u00fchrung in git bietet Neil Kakkar auf medium oder die Einf\u00fchrung von Daniel Miessler . Um git zu installieren, k\u00f6nnen wir die letzte Version von git-scm beziehen. F\u00fcr eine portable Nutzung schlage ich die Version 32-bit Git for Windows Portable vor. Git for Windows baut auf der bekannten Unix-Shell f\u00fcr windows msys auf, die, neben git, viele Unix-Shell-Befehle mit bringt.","title":"Kollaboration und Versionsverwaltung"},{"location":"ch01/p02_entwicklung.html#beispiel","text":"Um PortableGit nutzen zu k\u00f6nnen, staren wir zun\u00e4chst die Kommandozeile mit git-cmd.exe . Wir wechseln dann in einen Ordner, indem wir ein git-Repository erstellen m\u00f6chten: > c: > cd c:\\temp > mkdir gittest > cd gittest Jetzt gehts erst richtig los. Wir erstellen ein git-Repository und f\u00fcgen eine Datei hinzu: > git init Initialized empty Git repository in c:/temp/gittest/.git/ > echo print(\"Hello GIT!\") > hello.py > git add hello.py Schauen wir mal nach, was hier passiert ist. Wir \u00f6ffnen hierzu den Windows-Explorer und wechseln in den Pfad unseres Repositories. Evtl. \u00e4ndern wir die Windows Ordner- und Suchoptionen , sodass wir auch versteckte Dateien und Ordner angezeigt bekommen: - .git Dateiordner - hello.py Python File Zus\u00e4tzlich k\u00f6nnen wir in der git-Shell mit status eben diesen abfragen: > git status On branch master No commits yet Changes to be committed: (use \"git rm --cached <file>...\" to unstage) new file: hello.py Der Aufforderung unsere Aktion zu kommentieren kommen wir gerne nach: git commit dies \u00f6ffnet den Unix-Editor vi. Die Bedienung ist sehr speziell! Wir gehen mit den Pfeiltasten in die letzte angzeigte Zeile und tippen ein o , um eine neue Zeile einzuf\u00fcgen. Dachnach d\u00fcrfen wir die Pfeiltasten nicht meher verwenden, wir sind nun im Schreibmodus! Wir schreiben: First Module added und dr\u00fccken die Taste <Esc> . Wir haben den Schreibmodus verlassen. Im vi wechseln wir mit : in den Kommandomodus und tippen wq f\u00fcr write and quit . Vi speichert den commit und wir kehren zum Prompt zur\u00fcck: > git status On branch master nothing to commit, working tree clean Alternativ gibt es auch eine GUI-Version: git-gui.exe, mit der die meisten Dinge auch erlidigt werden k\u00f6nnen! > git-gui Git-Gui Benutzeroberfl\u00e4che Da dies nur einen kleinen Einblick geben soll, beenden wir unsere Experimente mit git! Die n\u00e4chsten Schritte w\u00e4ren: die Dokumentaion zu git lesen einen git-cloud Dienst verwenden (z.B. durch eine Anlmeldung bei github) die Benutzerdaten in git hinterlegen einen push ausf\u00fchren, um das Repository hochzuladen","title":"Beispiel"},{"location":"ch01/p02_entwicklung.html#3rd-party-module","text":"Anstelle von Standardmodulen sinnvoll, wenn Funktionalit\u00e4t fehlt, aber: Python-Entwicklung mit Modulen, die ihrerseits beim Kunden installiert werden m\u00fcssen Manche Module haben Abh\u00e4ngigkeiten zu DLL's, die aus C/C++-Entwicklung stammen, m\u00fcssen in der jeweilgen Version auch beim Kunden installiert sein oder sie werden bei der Installation zus\u00e4tzlich \u00fcbersetzt (pip macht das, setzt aber bspw. Compiler auf dem Rechner voraus): z.B.: Fiona f\u00fcr GDAL/OGR virtual environments: eine von einer Hauptinstallation abgeleitete \"virtuelle\" Pythoninstallation. Im Wesentlichen, um Module zu testen/benutzen, ohne dass diese die Hauptinstallation ver\u00e4ndern. VirtualEnv kann als python module installiert werden. Achtung: IDE's unterst\u00fctzen nicht alle virtual environments! Unter OSGEO4W h\u00e4ngen viele Module von anderen Installationen ab und bed\u00fcrfen einer speziellen Umgebung (environment variables). A non-magical introduction ... Um virtualenv unter OSGEO4W zu nutzen, gehen wir wie folgt vor: Wir starten eine OSGEO4W-Kommandofenster und installieren virtualenv mit pip > py3_env > pip install virtualenv Collecting virtualenv Downloading https://files.pythonhosted.org/packages/33/5d/314c760d4204f64e4a96 8275182b7751bd5c3249094757b39ba987dcfb5a/virtualenv-16.4.3-py2.py3-none-any.whl (2.0MB) 100% |--------------------------------| 2.0MB 4.3MB/s Installing collected packages: virtualenv Successfully installed virtualenv-16.4.3 You are using pip version 18.1, however version 19.0.3 is available. You should consider upgrading via the 'python -m pip install --upgrade pip' comm and. Dann wechseln wir in einen Ordner, in dem wir die virtuelle Umgebung einrichten m\u00f6chten: > c: > cd c:\\temp > mkdir vpytest > python -m venv Folgendes wird im Windows-Explorer angezeigt: + vpy + Include + Lib + Scripts - pyenv.cfg Im Unterordner Scripts finden wir u.a. activate.bat und deactivate.bat, mit denen wir die virtuelle Umgebung starten und wieder schlie\u00dfen k\u00f6nnen: > vpy\\Scripts\\activate.bat (vpy) c:\\temp\\vpytest> > vpy\\Scripts\\deactivate.bat Der ver\u00e4nderte Prompt (vpy) c:\\temp\\vpytest> zeigt an, dass die virtuelle Umgebung gestartet wurde. Um in diesem Ordner die OSGEO4W-Shell zusammen mit vpy verwenden zu k\u00f6nnen, nutze ich eine kleine Batch-Datei shell.bat im Verzeichnis c:\\temp\\vpytest , die auch \u00fcber den Explorer ausgef\u00fchrt werden kann: set pyhome=g:\\gp190225\\osgeo4w call %pyhome%\\bin\\o4w_env.bat call %pyhome%\\bin\\py3_env.bat call %~dp0\\vpy\\scripts\\activate.bat cls cmd.exe /k Sie m\u00fcssen pyhome so setzen, das der dort angegebene Pfad auf ihren GIS-Stick verweist! Das Problem mit virtualenv ist, dass es nicht portable ist. \u00c4ndert sich der Laufwerksbuchstabe des GIS-Sticks, so m\u00fcssten wir an verschiedenen Stellen Ver\u00e4nderungen vornehmen. Nur zum \u00dcberblick: shell.bat: Verwendet Laufwerksbuchstaben. L\u00f6sung: Virtuelle Umgebung auf dem Stick anlegen, und anstelle der Laufwerksangabe g: den Parameter %~d0 verwenden, sodass es hei\u00dft set pyhome=%~d0\\gp190225\\osgeo4w orig_prefix: Datei: vpy\\Lib\\orig_prefix.txt enth\u00e4lt eine absolute Pfadangabe und muss ge\u00e4ndert werden. Befindet sich die virtuelle Umgebung auf dem Stick, so dann die Laufwerksangabe weggelassen werden. Scripts: Exe-Dateien in vpy\\Scripts enthalten einen absoluten Pfad zu python.exe imselben Verzeichnis. Kann zu !python.exe verk\u00fcrzt werden. Im Falle von pip sollte ohne Anpassung der Befehl python -m pip verwendet werden. Nun k\u00f6nnen wir innerhalb der virtuellen Umgebung Module installieren und testen, ohne dass die \u00fcbergeordnete Python-Installation dadurch ver\u00e4ndert wird. Fiona ist ein Modul, dass \u00fcber pip \"nachinstalliert\" werden kann. Fiona vereinfacht den Umgang mit den Funktionen aus der gdal-Vektor-Bibliothek ogr und gilt als more pythonic als die OSGEO python-Schnittstelle. Hier eine kurze Anleitung zur Installation: Zun\u00e4chst ist Fiona von der installierten GDAL-Version abh\u00e4ngig, unter Windows z.B. die aktuelle in OSGEO4W neben dem offiziellen Repositorium f\u00fcr pip existiert eine Sammlung von Python-Modulen f\u00fcr Windows Christoph Grohlke , hier finden wir etvtl. die passende Version. > gdalinfo --version GDAL 2.4.1, released 2019/03/15 Abfrage der GDAL-Version in unserer Virtuellen Umgebung . Auf der Webseite von Herrn Grohlke suchen wir nach Fiona und finden Fiona-1.8.6-cp37-cp37m-win32.whl. Leider erfahren wir nicht, welche GDAL-Version hier benutzt wurde... Wir laden die Datei herunter, speichern sie im vpytest-Ordner um sie mit pip zu installieren: > python -m pip install Fiona-1.8.6-cp37-cp37m-win32.whl Die Prozedur erzeugt eine Menge von Meldungen, installiert aber Fiona unter vpy\\Lib\\site-packages Wir testen, ob fiona mit python importiert werden kann: python -c \"import fiona\" Wenn dort keine Fehler gemeldet werden, haben wir fiona erfolgreich installiert! Um das Modul evtl. wieder zu entfernen, k\u00f6nnen wir pip mit dem Parameter uninstall aufrufen: python -m pip uninstall fiona Wollen wir bspw. PyScripter als IDE in der virtuellen Umgebung nutzen, m\u00fcssen wir auch hier eine Batchdatei verwenden: @echo off set mystick=J:\\gp190225 set pyhome=%mystick%\\osgeo4w set scripter=%mystick%\\Pyscripter call %pyhome%\\bin\\o4w_env.bat call %pyhome%\\bin\\py3_env.bat call %~dp0\\vpy\\scripts\\activate.bat set PYTHONPATH=%VIRTUAL_ENV%\\Lib\\site-packages pushd %scripter% start \"PyScripter\" PyScripter.exe --PYTHON37 --pythondllpath=%pyhome%\\apps\\python37 popd call %~dp0\\vpy\\scripts\\deactivate.bat","title":"3rd party Module"},{"location":"ch01/p02_entwicklung.html#tool-chain","text":"Python scripte ben\u00f6tigen selten eine tool chain Umfangreiche Projekte hingegen schon In der IDE integrierte Tools: z.B.: wird in mehreren Dateien editiert, so m\u00fcssen diese beim Start des main scripts auch in der aktuelle Version import werden. auch eine Codeverwaltung wie git ist Teil einer tool chain Beispiel: make -> in msys package from osgeo4w Abarbeitung eines makefiles (kommt von unix, C-Compiler): - alle Schritte/Befehle die zur Erstellung der Software n\u00f6tig sind - definiert Regeln, z.B. Abh\u00e4ngigkeiten, die gegeben sein m\u00fcssen, bestimmte Aufgaben, die durchgef\u00fchrt werden sollen (make test, make install, make clean, etc.) Makefiles in python projects \u00e4hnlich: setup.py wird f\u00fcr python packages benutzt, die von einem Entwickler/Nutzer in die eigene Python-Installation integriert werden soll. Innerhalb des setup scripts k\u00f6nnen Anforderungen \u00fcberpr\u00fcft und die Installation des packages ausgef\u00fchrt werden. -> passt auch zu \"Ver\u00f6ffentlichung\", vgl. auch \"pip\" stackoverflow: What is setup.py?","title":"Tool chain"},{"location":"ch01/p02_entwicklung.html#python-und-tests","text":"Einfache Module, die nicht ausf\u00fchrbar sind, also nur zum import bestimmt sind, k\u00f6nnen innerhalb des Moduls Tests vorsehen, indem sie die Abfrage if __name__ == '__main__': den Tests voranstellen. Beispiel: F\u00fcr unser Projekt benutzen wir das Package mit den Unterordnern und Modulen meinProjekt - `__init__.py` - `meinModul.py` __init__.py # -*- coding: utf-8 -*- from .meinModul import MeineClass meinModul.py class MeineClass(object): def beispiel(self, string=\"\"): print(string) return True print (__name__) if __name__ == \"__main__\": m = MeineClass() m.beispiel(\"u see\") Somit kann jede Funktion der Klasse getestet werden. Der Code-Block unterhalb des if statements wird nur ausgef\u00fchrt, wenn wir das zugeh\u00f6rige Modul ausf\u00fchren (Run in IDE, phython meinModul.py in der shell ), nicht wenn es importiert wird ( __name__ ist der Modulename, er wird im Falle einer Ausf\u00fchrung in __main__ ge\u00e4ndert). Test eines Imports aus einem Package, wir legen eine neue Datei an: useMeinProjekt.py meinProjekt - `__init__.py` - `meinModul.py` useMeinProjekt.py: # -*- coding: utf-8 -*- from meinProjekt.meinModul import MeineClass m = MeineClass() m.beispiel(\"Tada!\")","title":"Python und Tests"},{"location":"ch01/p02_entwicklung.html#testing-beispiel","text":"Ein f\u00fcr Python vorgesehener Weg ist die Verwendnung von unit tests : \"Beim Schreiben von Unit-Tests mit Hilfe des unittest-Pakets wird zu jedem Modul modulname.py ein entsprechendes Test-Modul test_modulname.py, mit dessen Hilfe die im Hauptmodul enthaltenen Funktionen getestet werden k\u00f6nnen. Alle diese so genannten Unit Tests sollten voneinander unabh\u00e4ngig sein.\" debugging, logging, testing Sinnvoll ist zudem die Arbeit mit der assert-Anweisung, welche einen Ausdruck testet, indem sie ihn mit einem erwarteten Ergebnis vergleicht. Beispiel: F\u00fcr unser Projekt erweitern wir das Package mit diesen zus\u00e4tzlichen Ordnern und Modulen meinProjekt - `__init__.py` - `meinModul.py` + tests - `__init__.py` - test_init.py - test_meinModul.py Innerhalb des Unterordners test werden nun die \u00dcberpr\u00fcfungen eingerichtet: In unserem Fall werden wir verschiedene Techniken einsetzen: Python-Modul logging , um Meldungen in einer Txtdatei zu speichern Python-Anweisung assert , um die R\u00fcckgabe von Methoden zu testen/benutzen Python-Modul unittest , um den Testablauf zu automatisieren Nat\u00fcrlich ist der Einsatz dieser Tools kein Muss , sondern soll aufzeigen, welche Testm\u00f6glichkeiten, und es sind l\u00e4ngst nicht alle, dem Python-Entwickler zur Verf\u00fcgung stehen. test/__init__.py # ich bleibe leer test/test_meinModul.py import unittest import logging # Basis-Einstellungen festlegen: logging.basicConfig(filename='meintest_log.txt', format='%(levelname)s: %(message)s', level=logging.INFO) LOG = logging.getLogger(\"mein_test\") from meinProjekt import MeineClass class MeineClassTest(unittest.TestCase): def setUp(self): \"\"\"runs before each test\"\"\" # create an object self.theClass = MeineClass() def test_beispiel(self): try: assert self.theClass.beispiel() == True except AssertionError as e: LOG.error(\"test_beispiel scheiterte: %s\"%str(e)) else: LOG.info(\"test_beispiel bestanden!\") def tearDown(self): \"\"\"runs after each test\"\"\" self.theClass = None if __name__ == '__main__': unittest.main() Unser Test startet mit unittest.main() und erzeugt eine Log-Datei test/meintest_log.txt . Bevor unser einziger Test startet, wird setUp() ausgef\u00fchrt, nach dem Test noch tearDown() . Meldungen werden nicht mit print ausgegeben, sondern immer in die log-Datei geschrieben. Nur die Meldungen des Unittest-Moduls erscheinen auf der Konsole. Getestet wird mit die Methode beispiel in test_beispiel, assert pr\u00fcft, ob die Methode True oder False zur\u00fcckgibt und erzeugt einen Fehler, falls das Ergebnis False ist wir verwenden try...except, um diesen Fehler abzufangen","title":"Testing Beispiel"},{"location":"ch01/p02_entwicklung.html#veroffentlichung-von-python-projekten","text":"Ziel einer Entwicklung mit Python w\u00e4re eine Ver\u00f6ffentlichung als Python-Package, so dass es \u00fcber ein setup.py installiert werden kann es in einem package format vorliegt, z.B. als whl-Datei (eine Art ZIP-Datei) f\u00fcr die Installation mit pip, genutzt werden kann es auf einer Plattform, wie github oder dem Python Package Index (PyPI) gespeichert wird und von wo es herutergeladen und installiert werden kann. Anzumerken sei, dass es auch m\u00f6glich ist auch ausf\u00fchrbare Programme aus Python-Modulen oder -Packages zu bekommen. Hierf\u00fcr stehen verschiedene Optionen zur Verf\u00fcgung, bekannte M\u00f6glichkeiten sind: Verwendung von __main__.py in einem Package, so dass bei der Ausf\u00fchrung mit python -m packagename __main__ als Startpunkt ausgew\u00e4hlt wird. Idle kann z.B. auf diese Weise gestartet werden. Erstellung einer ausf\u00fchrbaren Datei, unter Windows als .exe, so dass das Programm auch ohne installiertes Python auf einem Rechner ausgef\u00fchrt werden kann. Dies leistet etwa pyinstaller .","title":"Ver\u00f6ffentlichung von Python-Projekten"},{"location":"ch01/p02_entwicklung.html#fazit","text":"Schlie\u00dflich k\u00f6nnen die dargestellten Phasen auch auf die Entwicklung mit Python und QGIS \u00fcbertragen werden. Die GIS-spezifischen Anforderungen werden wir im Laufe der Lehrveranstaltung kennenlernen. # QGIS-Entwicklung ## debugging ## processing scripts ## plugins ### plugin builder ### plugin reloader ## standalone applications","title":"Fazit"},{"location":"ch01/p03_ooprog.html","text":"Objektorientierte Programmierung Alles in Python ist ein Objekt: \"Objects are Python\u2019s abstraction for data. All data in a Python program is represented by objects or by relations between objects. (In a sense, and in conformance to Von Neumann\u2019s model of a stored program computer, code is also represented by objects.)\" Dokumentation Zu den M\u00f6glichkeiten der Objektorientierten Programmierung haben wir in Python bislang nur elementare Dinge zum Aufbau eigener Klassen kennengelernt. Dazu geh\u00f6ren: die Verwendung des Schl\u00fcsselworts class der Einsatz von __init__ als Methode die Bedeutung von self als Objektvariable der allgemeine Einsatz von Methoden class Point(object): def __init__(self, x=0.0, y=0.0): self.X = x self.Y = y def __str__(self): return \"POINT (%s %s)\" % (self.X, self.Y) def distance(self, point): dx = abs(self.X - point.X) dy = abs(self.Y - point.Y) return math.sqrt(dx**2 + dy**2) Daran k\u00f6nnen wir bereits wesentliche Eigenschaften (Vorteile) der OO-Programmierung erkennen: Encapsulation: Daten und Funktionen werden zusammen verwaltet, Data Abstraction: interne Datenstrukturen werden nicht direkt zugegriffen, sondern \u00fcber eine Schnittstelle weitergegeben (wir erlauben hier den Zugriff auf X und Y, besser w\u00e4ren Methoden, s.u.), Polymorphism: Klassenstrukturen helfen, die Schnittstelle \u00fcber verschiedene Klassen konsistenz zu halten: z.B: Methodennamen lauten in allen Klassen gleich, Inheritance: Vererbung meint die Weitergabe von Daten und Methoden von allgemeineren Klassen zu spezielleren, hier nur Vererbung aus der Klasse object . In Python3 kann dies weggelassen werden! Diskussion auf stackoverflow Variante mit Zugriff auf Daten mit Properties: class Point(object): def __init__(self, x=0.0, y=0.0): print(\"init\") self.X = x self.Y = y def __str__(self): print(\"str\") return \"POINT: %s, %s\" % (self.X, self.Y) def setX(self, x): print(\"setX\") if x >= 0: self._x = x def setY(self, y): print(\"setY\") if y >= 0: self._y = y def getX(self): print(\"getX\") return self._x def getY(self): print(\"getY\") return self._y X = property(getX, setX) Y = property(getY, setY) Properties sind Objekte, die es erm\u00f6glichen, Daten auch in Zuweisungen zu nutzen, au\u00dferdem ist der direkte Zugriff auf die Daten nicht m\u00f6glich. Hier wurden _x und _y durch den Unterstrich explizit gesch\u00fctzt. Was war nochmal der underscore? Diese Seite erl\u00e4utert dies ziemlich umfassend, zugleich kurz und \u00fcbersichtlich. Properties k\u00f6nnen auch mit decorators erzeugt werden: Python @property p1 = Point() print(p1) print(p1.getX(), p1.getY()) print(p1.X, p1.Y) p1.X = -0.5 p1.Y = 1.0 print(p1) Objektorientierter Entwurf Klassenstrukturen sind Teil des Entwurfs, sie werden zun\u00e4chst aufgeschrieben: Klassendiagramm f\u00fcr Datenobjekte Hier der Entwurf zu einer Klassenstruktur zum Einlesen von Daten (Datenquelle), entweder aus Dateien oder aus Datenbanken. Beide \"Zweige\" des Entwurfs benutzen eine Klasse Table , mit der die Daten verbunden werden. Die oberste Klasse Datenquelle ist im Idealfall eine abstrakte Klasse, aus der sich keine Objekte ableiten lassen, sondern die die gemeinsamen Strukturen der anderen Klasse vorschreibt. class DataSource(object): def __init__(self): pass def open(self, location): pass def read(self): pass class DataFile(DataSource): def open(self, location): pass class CSVFile(DataFile): def read(self, delim): pass Ein erster Entwurf f\u00fcr die Klasse CSVFile , sie erbt Methoden und Eigenschaften von DataFile , die Wiederum aus der Klasse DataSource abgeleitet ist. Diese abstrakte Klasse gibt bereits die Namen der Methoden vor. Angedeutet ist ebenfalls, dass Methoden von einer spezialisierten Klasse \u00fcberschrieben werden k\u00f6nnen: In DataFile definieren wir die Methode open() neu, da zum \u00d6ffnen einer Datei eine andere Vorgehensweise gew\u00e4hlt werden muss, als beispielsweise zum \u00d6ffnen einer Datenbank. In CSVFile trifft dies auf die Methode read() zu. Wir gehen davon aus, dass eine CSV-Datei genau wie eine beliebige Datei ge\u00f6ffnet wird, aber bedingt durch das Format, eine andere Form des Lesens der Inhalte gew\u00e4hlt werden muss. Objektorientierte Anwendungen Viele Anwendungen (im Sinne von Software/Programmen) werden durch den Einsatz von Klassen aufgebaut. Typisch f\u00fcr die Vorgehensweise ist es, eine eigene Klasse f\u00fcr die Software sebst zu definieren. Python-Scripte basieren immer auf Modulen und diese Module k\u00f6nnen entweder importiert oder ausgef\u00fchrt werden: def main(): pass if __name__ == '__main__': main() Zwar ist in Python ein Modul ein Objekt, das Programm selbst ist in diesem Beispiel aber keine Klasse! Hier schon: class App(object): def main(): print(\"Hello World!\") if __name__ == '__main__': app = App() app.main() Doch lohnt dieser Aufwand nat\u00fcrlich nur, wenn die Klasse zur Applikation (App) Teil einer umfangreicheren Software ist und spezielle Aufgaben \u00fcbernimmt. Dies ist z.B. bei Benutzeroberfl\u00e4chen der Fall. Die Klasse App dient dann der Verarbeitung von Benutzereingaben und die konkreten auszuf\u00fchrenden Funktionen werden in einer abgeleiteten Klasse verarbeitet. Als Beispiel schauen wir uns das Python-Modul cmd an. Mit cmd k\u00f6nnen CLI-Programme realisiert werden. d.h. hier l\u00e4uft die Benutzersteuerung \u00fcber eine Kommandozeile und die ANwendung definiert ihre eigenen Befehle. Das Modul cmd enth\u00e4lt eine Klasse Cmd, welche die Funktionalit\u00e4t bereitstellt, um es dem Benutzer zu erm\u00f6glichen, Befehle als Eingabe zu verwenden. Eine kurze Beschreibung des Moduls finden wir hier . Hier unser eigenes Beispiel f\u00fcr eine minimale cmd-Shell : from cmd import Cmd class MyPrompt(Cmd): def do_hello(self, args): \"\"\"Says hello. If you provide a name, it will greet you with it.\"\"\" if len(args) == 0: name = 'stranger' else: name = args print (\"Hello, %s\" % name) def do_quit(self, args): \"\"\"Quits the program.\"\"\" print (\"Quitting.\") raise SystemExit def main(): prompt = MyPrompt() prompt.prompt = '> ' prompt.cmdloop('Starting prompt...') if __name__ == '__main__': main() Wir importieren zun\u00e4chst die Klasse Cmd, und erstellen eine eigene, vom Cmd abgeleitete Klasse 'MyPrompt'. Cmd sieht vor, dass Befehle durch Methoden definiert werden, deren Name mit do_ beginnt und mit dem Befehlswort endet: do_hello legt also das Kommando hello an. do_hello hat zudem zwei Parameter: neben der obligatorischen Objektvariable self den Parameter args . Wenn wir nun den Befehl hello mit einem zus\u00e4tzliche Parameter eingeben, wird user dieser als Name wieder ausgegeben. Fehlt der Parameter, wird \"stranger\" ausgegeben. do_quit schlie\u00dft das Programm. Au\u00dferdem gibt es per default ein Kommando \"help\", das die Befehle auflistet oder zu einem bestimmten Befehl den doc-String der Methode ausgibt. Das Python-typische main() in Verbindung mit if __name__ == '__main__' wurde hier beibehalten. Die Verwendung von raise SystemExit aus dem Originalcode wurde beibehalten, in der Dokumentation zum cmd-Modul ist angegeben, ein return True zu verwenden. Beispiel: Package mit __main__.py In Python kann ein Package direkt ausf\u00fchrbar gemacht werden, indem ein Modul __main__.py hinzugef\u00fcgt wird. Die enth\u00e4lt dann den Code zur Ausf\u00fchrung und wird gestartet wenn der Python-Interpreter mit -m gestartet wird: Dazu f\u00fcgen wir eine Datei __main__.py dem Package hinzu. meinProjekt - `__init__.py` - `__main__.py` - `meinModul.py` __main__.py: # -*- coding: utf-8 -*- from meinProjekt.meinModul import MeineClass m = MeineClass() m.beispiel(\"Tada!\") Dies ist \u00fcbrigens derselbe Code wie in useMainProjekt.py , __main__.py ist also nur eine von mehreren M\u00f6glichkeiten. Beispiel: PyQGIS Auch QGIS kann unter Python als objektorientiertes Programm ausgef\u00fchrt werden. Im Folgenden werden wir ein standalone script schreiben, das QGIS-Funktionen ohne GUI ausf\u00fchren kann. # -*- coding: utf-8 -*- from qgis.core import * import os # supply path to qgis install location env_prefix_path = os.environ['QGIS_PREFIX_PATH'] QgsApplication.setPrefixPath(env_prefix_path, True) # create a reference to the QgsApplication, setting the # second argument to False disables the GUI qgs = QgsApplication([], False) # load providers qgs.initQgis() # Write your code here to load some layers, use processing # algorithms, etc. # When your script is complete, call exitQgis() to remove the # provider and layer registries from memory qgs.exitQgis() Das Script \u00f6ffent und schlie\u00dft QGIS gleich wieder. Der erste Teil, bis Zeile 7 bereitet den Start von qgis vor Der zweite Zeil (Zeilen 9-14) \u00f6ffnet QGIS als QgsApplication-Objekt dahinter w\u00e4re der Platz zur Ausf\u00fchrung von QGIS-Funktionen Im letzten Teil wird qgis mit der Methode exitQgis() geschlossen Wir werden dieses Script im n\u00e4chsten Kapitel als Alternative zur Python Shell innerhalb von QGIS nutzen k\u00f6nnen. Zudem ist es ein Beispiel f\u00fcr Qt-Anwendung unter Python, mit der wir letztendlich unser Plugin erstellen werden.","title":"Objektorientierung"},{"location":"ch01/p03_ooprog.html#objektorientierte-programmierung","text":"Alles in Python ist ein Objekt: \"Objects are Python\u2019s abstraction for data. All data in a Python program is represented by objects or by relations between objects. (In a sense, and in conformance to Von Neumann\u2019s model of a stored program computer, code is also represented by objects.)\" Dokumentation Zu den M\u00f6glichkeiten der Objektorientierten Programmierung haben wir in Python bislang nur elementare Dinge zum Aufbau eigener Klassen kennengelernt. Dazu geh\u00f6ren: die Verwendung des Schl\u00fcsselworts class der Einsatz von __init__ als Methode die Bedeutung von self als Objektvariable der allgemeine Einsatz von Methoden class Point(object): def __init__(self, x=0.0, y=0.0): self.X = x self.Y = y def __str__(self): return \"POINT (%s %s)\" % (self.X, self.Y) def distance(self, point): dx = abs(self.X - point.X) dy = abs(self.Y - point.Y) return math.sqrt(dx**2 + dy**2) Daran k\u00f6nnen wir bereits wesentliche Eigenschaften (Vorteile) der OO-Programmierung erkennen: Encapsulation: Daten und Funktionen werden zusammen verwaltet, Data Abstraction: interne Datenstrukturen werden nicht direkt zugegriffen, sondern \u00fcber eine Schnittstelle weitergegeben (wir erlauben hier den Zugriff auf X und Y, besser w\u00e4ren Methoden, s.u.), Polymorphism: Klassenstrukturen helfen, die Schnittstelle \u00fcber verschiedene Klassen konsistenz zu halten: z.B: Methodennamen lauten in allen Klassen gleich, Inheritance: Vererbung meint die Weitergabe von Daten und Methoden von allgemeineren Klassen zu spezielleren, hier nur Vererbung aus der Klasse object . In Python3 kann dies weggelassen werden! Diskussion auf stackoverflow Variante mit Zugriff auf Daten mit Properties: class Point(object): def __init__(self, x=0.0, y=0.0): print(\"init\") self.X = x self.Y = y def __str__(self): print(\"str\") return \"POINT: %s, %s\" % (self.X, self.Y) def setX(self, x): print(\"setX\") if x >= 0: self._x = x def setY(self, y): print(\"setY\") if y >= 0: self._y = y def getX(self): print(\"getX\") return self._x def getY(self): print(\"getY\") return self._y X = property(getX, setX) Y = property(getY, setY) Properties sind Objekte, die es erm\u00f6glichen, Daten auch in Zuweisungen zu nutzen, au\u00dferdem ist der direkte Zugriff auf die Daten nicht m\u00f6glich. Hier wurden _x und _y durch den Unterstrich explizit gesch\u00fctzt. Was war nochmal der underscore? Diese Seite erl\u00e4utert dies ziemlich umfassend, zugleich kurz und \u00fcbersichtlich. Properties k\u00f6nnen auch mit decorators erzeugt werden: Python @property p1 = Point() print(p1) print(p1.getX(), p1.getY()) print(p1.X, p1.Y) p1.X = -0.5 p1.Y = 1.0 print(p1)","title":"Objektorientierte Programmierung"},{"location":"ch01/p03_ooprog.html#objektorientierter-entwurf","text":"Klassenstrukturen sind Teil des Entwurfs, sie werden zun\u00e4chst aufgeschrieben: Klassendiagramm f\u00fcr Datenobjekte Hier der Entwurf zu einer Klassenstruktur zum Einlesen von Daten (Datenquelle), entweder aus Dateien oder aus Datenbanken. Beide \"Zweige\" des Entwurfs benutzen eine Klasse Table , mit der die Daten verbunden werden. Die oberste Klasse Datenquelle ist im Idealfall eine abstrakte Klasse, aus der sich keine Objekte ableiten lassen, sondern die die gemeinsamen Strukturen der anderen Klasse vorschreibt. class DataSource(object): def __init__(self): pass def open(self, location): pass def read(self): pass class DataFile(DataSource): def open(self, location): pass class CSVFile(DataFile): def read(self, delim): pass Ein erster Entwurf f\u00fcr die Klasse CSVFile , sie erbt Methoden und Eigenschaften von DataFile , die Wiederum aus der Klasse DataSource abgeleitet ist. Diese abstrakte Klasse gibt bereits die Namen der Methoden vor. Angedeutet ist ebenfalls, dass Methoden von einer spezialisierten Klasse \u00fcberschrieben werden k\u00f6nnen: In DataFile definieren wir die Methode open() neu, da zum \u00d6ffnen einer Datei eine andere Vorgehensweise gew\u00e4hlt werden muss, als beispielsweise zum \u00d6ffnen einer Datenbank. In CSVFile trifft dies auf die Methode read() zu. Wir gehen davon aus, dass eine CSV-Datei genau wie eine beliebige Datei ge\u00f6ffnet wird, aber bedingt durch das Format, eine andere Form des Lesens der Inhalte gew\u00e4hlt werden muss.","title":"Objektorientierter Entwurf"},{"location":"ch01/p03_ooprog.html#objektorientierte-anwendungen","text":"Viele Anwendungen (im Sinne von Software/Programmen) werden durch den Einsatz von Klassen aufgebaut. Typisch f\u00fcr die Vorgehensweise ist es, eine eigene Klasse f\u00fcr die Software sebst zu definieren. Python-Scripte basieren immer auf Modulen und diese Module k\u00f6nnen entweder importiert oder ausgef\u00fchrt werden: def main(): pass if __name__ == '__main__': main() Zwar ist in Python ein Modul ein Objekt, das Programm selbst ist in diesem Beispiel aber keine Klasse! Hier schon: class App(object): def main(): print(\"Hello World!\") if __name__ == '__main__': app = App() app.main() Doch lohnt dieser Aufwand nat\u00fcrlich nur, wenn die Klasse zur Applikation (App) Teil einer umfangreicheren Software ist und spezielle Aufgaben \u00fcbernimmt. Dies ist z.B. bei Benutzeroberfl\u00e4chen der Fall. Die Klasse App dient dann der Verarbeitung von Benutzereingaben und die konkreten auszuf\u00fchrenden Funktionen werden in einer abgeleiteten Klasse verarbeitet. Als Beispiel schauen wir uns das Python-Modul cmd an. Mit cmd k\u00f6nnen CLI-Programme realisiert werden. d.h. hier l\u00e4uft die Benutzersteuerung \u00fcber eine Kommandozeile und die ANwendung definiert ihre eigenen Befehle. Das Modul cmd enth\u00e4lt eine Klasse Cmd, welche die Funktionalit\u00e4t bereitstellt, um es dem Benutzer zu erm\u00f6glichen, Befehle als Eingabe zu verwenden. Eine kurze Beschreibung des Moduls finden wir hier . Hier unser eigenes Beispiel f\u00fcr eine minimale cmd-Shell : from cmd import Cmd class MyPrompt(Cmd): def do_hello(self, args): \"\"\"Says hello. If you provide a name, it will greet you with it.\"\"\" if len(args) == 0: name = 'stranger' else: name = args print (\"Hello, %s\" % name) def do_quit(self, args): \"\"\"Quits the program.\"\"\" print (\"Quitting.\") raise SystemExit def main(): prompt = MyPrompt() prompt.prompt = '> ' prompt.cmdloop('Starting prompt...') if __name__ == '__main__': main() Wir importieren zun\u00e4chst die Klasse Cmd, und erstellen eine eigene, vom Cmd abgeleitete Klasse 'MyPrompt'. Cmd sieht vor, dass Befehle durch Methoden definiert werden, deren Name mit do_ beginnt und mit dem Befehlswort endet: do_hello legt also das Kommando hello an. do_hello hat zudem zwei Parameter: neben der obligatorischen Objektvariable self den Parameter args . Wenn wir nun den Befehl hello mit einem zus\u00e4tzliche Parameter eingeben, wird user dieser als Name wieder ausgegeben. Fehlt der Parameter, wird \"stranger\" ausgegeben. do_quit schlie\u00dft das Programm. Au\u00dferdem gibt es per default ein Kommando \"help\", das die Befehle auflistet oder zu einem bestimmten Befehl den doc-String der Methode ausgibt. Das Python-typische main() in Verbindung mit if __name__ == '__main__' wurde hier beibehalten. Die Verwendung von raise SystemExit aus dem Originalcode wurde beibehalten, in der Dokumentation zum cmd-Modul ist angegeben, ein return True zu verwenden.","title":"Objektorientierte Anwendungen"},{"location":"ch01/p03_ooprog.html#beispiel-package-mit-__main__py","text":"In Python kann ein Package direkt ausf\u00fchrbar gemacht werden, indem ein Modul __main__.py hinzugef\u00fcgt wird. Die enth\u00e4lt dann den Code zur Ausf\u00fchrung und wird gestartet wenn der Python-Interpreter mit -m gestartet wird: Dazu f\u00fcgen wir eine Datei __main__.py dem Package hinzu. meinProjekt - `__init__.py` - `__main__.py` - `meinModul.py` __main__.py: # -*- coding: utf-8 -*- from meinProjekt.meinModul import MeineClass m = MeineClass() m.beispiel(\"Tada!\") Dies ist \u00fcbrigens derselbe Code wie in useMainProjekt.py , __main__.py ist also nur eine von mehreren M\u00f6glichkeiten.","title":"Beispiel: Package mit __main__.py"},{"location":"ch01/p03_ooprog.html#beispiel-pyqgis","text":"Auch QGIS kann unter Python als objektorientiertes Programm ausgef\u00fchrt werden. Im Folgenden werden wir ein standalone script schreiben, das QGIS-Funktionen ohne GUI ausf\u00fchren kann. # -*- coding: utf-8 -*- from qgis.core import * import os # supply path to qgis install location env_prefix_path = os.environ['QGIS_PREFIX_PATH'] QgsApplication.setPrefixPath(env_prefix_path, True) # create a reference to the QgsApplication, setting the # second argument to False disables the GUI qgs = QgsApplication([], False) # load providers qgs.initQgis() # Write your code here to load some layers, use processing # algorithms, etc. # When your script is complete, call exitQgis() to remove the # provider and layer registries from memory qgs.exitQgis() Das Script \u00f6ffent und schlie\u00dft QGIS gleich wieder. Der erste Teil, bis Zeile 7 bereitet den Start von qgis vor Der zweite Zeil (Zeilen 9-14) \u00f6ffnet QGIS als QgsApplication-Objekt dahinter w\u00e4re der Platz zur Ausf\u00fchrung von QGIS-Funktionen Im letzten Teil wird qgis mit der Methode exitQgis() geschlossen Wir werden dieses Script im n\u00e4chsten Kapitel als Alternative zur Python Shell innerhalb von QGIS nutzen k\u00f6nnen. Zudem ist es ein Beispiel f\u00fcr Qt-Anwendung unter Python, mit der wir letztendlich unser Plugin erstellen werden.","title":"Beispiel: PyQGIS"},{"location":"ch01/p04_qgis_einf.html","text":"QGIS Open Source Software Auf den Rechnern der CIP-Pools installiert M\u00f6glichkeit zur Installation auf USB-Stick/-Laufwerk USB-Version: Im Campus-Netz zum herunterladen: Gro\u00dfe oder Kleine Installation USB-Laufwerk (Stick) mit USB3, schnelles Medium Das Startmen\u00fc der USB-Version Vorteile: Gute Kartographie im Vergleich zu anderen GIS kann mit nach Hause genommen werden zus\u00e4tzliche GIS-/Software integriert und mit eigenen PortableApps erg\u00e4nzbar Einf\u00fchrungen in QGIS Auf qgis.org Neue Version QGIS3 mit teilweise unvollst\u00e4ndiger Dokumentation Online-Ressourcen zu einzelnen \u00dcbungen Literatur: A. Cutts, A. Graser: Learn QGIS, 4. Auflage, Packt> A. Graser and G. N. Peterson: QGIS Map Design Einf\u00fchrung: - Treglia_QGIS_Tutorial_3_0 QGIS-Benutzeroberfl\u00e4che Die Benutzeroberf\u00e4che von QGIS3 Um die Processing Toolbox Toolbox anzuzeigen, klicken wir Men\u00fc: View | Panels | Processing Toolbox Bedienfelder und Werkzeugk\u00e4sten k\u00f6nnen \u00fcber das Menu:Ansicht ein- oder ausgeschaltet werden Projekt: Funktionen, um ein QGIS-Projekt zu laden, zu speichern, oder zu erzeugen. Kartennavigation: beinhaltet Werkzeuge zum Verschieben, Zoomen als auch die Verwaltung von Lesezeichen und die Kartenaktualisierung. Attributwerkzeuge: umfasst Tools, um Objekte in der Karte zu identifizieren, zu seleltieren, eine Tabellenansicht zu \u00f6ffnen oder in der Karte zu messen. Datenquellen: Funktionen, um Daten in ein QGIS-Projekt zu laden, oder neue Datens\u00e4tze zu erzeugen. \u00dcbung: Ikea-Filialen Daten: Wikipedia-Artikel https://de.wikipedia.org/wiki/IKEA_Deutschland mit Tabelle und Karte ikea_wiki_table_org.csv : Angaben zum Jahr der Er\u00f6ffnung und Gr\u00f6\u00dfe der Verkaufsfl\u00e4che herunterladen ikea_wikipedia Standorte.kml : Punkte/Koordinaten herunterladen Vorgehensweise: Daten ansehen csv-Feldtypen anpassen Daten in QGIS laden Join \u00fcber den Namen der Filialen Speichern im GeoPackage-Format, mit Auswahl relevanter Felder (Attribute) Laden der Datei ikea_wikipedia Standorte.kml in QGIS \u00fcber die Datenquellverwaltung: Datenquellverwaltung \u00f6ffnen Inspektion der Ikea-Standorte Ansicht und Abfrage geladener Informationen Vorbereitung zur Datei ikea_wiki_table_org.csv kopieren nach ikea_wiki_table.csv Mit Notepad++ \u00f6ffnen und editieren: Erste Zeile mit Namen, Tabulator getrennt: Filiale Jahr VerkFl Suchen/ersetzen: Punkte in Verkaufsfl\u00e4chen eliminieren Filiale Jahr VerkFl Augsburg (Gersthofen) 2006 31000 Berlin-Lichtenberg 2010 43000 Berlin-Spandau 1979 36300 Berlin-Tempelhof (Berlin-Sch\u00f6neberg) 2003 37000 Datentypen der Spalten deklarieren: Neue Datei anlegen ikea_wiki_table.csvt Mit Notepad++ \u00f6ffnen und editieren: \"String\",\"Integer\",\"Integer\" Datei ikea_wiki_table.csv in QGIS laden Optionen beim Importieren der Tabelle Join der beiden Datens\u00e4tze Layereigenschaften der kml-Datei \u00f6ffnen auf Verkn\u00fcpfungen klicken mit Plus [+] neuen Join hinzuf\u00fcgen Aufruf Layereigenschaften->Verkn\u00fcpfungen Die Spalten f\u00fcr den Join m\u00fcssen exakt dieselben Werte enthalten! Namen m\u00fcssen evtl. korrigiert werden! Optionen der Verkn\u00fcpfung Ergebnis: Spalten aus ikea_wiki_table wurden angehangen. Daten in QGIS untersuchen Tabelle anzeigen: Men\u00fc->Layer->Attributtabelle \u00f6ffnen ge\u00f6ffnete Attributtabelle Klick auf Spaltennamen sortiert die Anzeige Datenexport: Wir exportieren das Ergebnis in ein anderes Datenformat Unter Layer-> ikea_wikipedia Standorte rufen wir das Kontextmen\u00fc mit der rechten Maustaste auf und w\u00e4hlen: Exportieren->Objekt speichern als Wir w\u00e4hlen alle \u00fcberfl\u00fcssigen Spalten ab und behalten nur diese Spalten: Name, description, ikea_wiki_table_Jahr, ikea_wiki_table_VerkFl Optionen f\u00fcr den Export als Geopackage GeoPackage ist ein relativ neues aber standardisiertes Datenformat f\u00fcr Geodaten! Basiskarte f\u00fcr die Ikea-Filialen Plugin QuickMapServices benutzen Plugin installieren: Suche: QuickMapServices Men\u00fc:Web->Quick Map Services->Settings: More Services->Get contributed pack ausw\u00e4hlen der Basiskarte: OSM-Standard Installation des Plugins Anpassen der Projektion Projektion der Basiskarte: Web-Mercator Einstellen f\u00fcr Projekt, Projekteigenschaften->KBS Suche: Web Einstellung f\u00fcr das Koordinatensystem des Projekts Da die Basiskarte als Raster dargestellt wird, erhalten wir mit der passenden Projektion eine bessere Qualit\u00e4t! Grafikeinstellungen f\u00fcr Vektorlayer Unter Layer \u00f6ffnen wir das Layergestaltungsfenster Layergestalungsfenster \u00f6ffnen Im ge\u00f6ffneten Bedienfeld find wir die Einstellungen zur Grafik des Layers Bedienfeld Layergestaltung Alternativ kann man diese Einstellungen auch \u00fcber die Layereigenschaften erreichen, Das bereits ge\u00f6ffnete sogenannte Dockingfenster ist praktischer (live-Aktualisierung) Aufruf der Symbology \u00fcber die Layereigenschaften Die Einstellungen k\u00f6nnen im Bedienfeld sehr detailliert vorgenommen werden. Grobe Einteilung: Ansicht zur Einstellung \"Einfache Markierung\" Einzelsymbol: Alle Daten erhalten die gleiche Darstellung Klicken Sie auf Einzelsymbol, um weitere Darstellungsmethoden zu sehen Neben Einzelsymbol gibt es: Kategorisiert, Abgestuft und so weiter, \u00e4hnlich wie in ESRI's ArcMap Eigenschaften f\u00fcr Einfache Markierung Hier sehen wir die einzelnen Graphikparameter Gr\u00f6\u00dfe F\u00fcllfarbe Strichfarbe usw. dienen der Auswahl von Farben und Gr\u00f6\u00dfen etc. Einstellungen zu Einfache Markierung Neben der \"Einfachen Markierung\" gibt es aber auch andere Zeichenverfahren: Symbollayertypen als Zeichenverfahren Datengesteuerte Parameter Zus\u00e4tzlich k\u00f6nnen alle Parameter auch durch Datenwerte gesteuert werden! Ikea-Filialen darstellen: Einzelsymbol Zeichengr\u00f6\u00dfe: Angegeben in Millimeter, Ver\u00e4nderungen k\u00f6nnen direkt eingegeben und im Kartenfenster beurteilt werden Gr\u00f6\u00dfenangabe Die F\u00fcllfarbe kann auf zweierleiweise eingestellt werden: Farbe Ein Klick auf den Schalter (rechts) \u00f6ffnet eine Farbauswahl, direkt im Fenster direkte Farbauswahl Ein Klick auf die Farbe selbst \u00f6ffnet eine neue Ansicht, in der mehr Optionen zur Verf\u00fcg stehen von dort zur\u00fcck geht es \u00fcber den blauen Pfeil: Farbauswahl im Folgefenster Ikea-Filialen darstellen: Abgestuft Eine abgestufte Darstellung wird durch die Datenwerte eines Attributs gesteuert Wir w\u00e4hlen das Attribut f\u00fcr die Verkaufsfl\u00e4che Als Methode w\u00e4hlen wir Size, um die Gr\u00f6\u00dfe der Zeichen zu variieren Anschlie\u00dfend w\u00e4hlen wir Klassifizieren, um 5 unterschiedliche Gr\u00f6\u00dfenabstufungen zu erzielen Darstellungsverfahren \"Abgestuft\" Ergebnis (Ausschnitt) Ergebnisdarstellung Ikea-Filialen darstellen: Kreisdiagramm Diagrammdarstellungen finden wir unter Layereigenschaften->Diagramme Einstellungen f\u00fcr Kreisdiagramme Einstellungen: Die Darstellung aus den vorangegangenen Schritten schalten wir aus: \"Keine Symbole\" Attribute: Wir benutzen ein beliebiges Attribut, um dem Diagramm eine Farbe zuzuordnen (theoretisch k\u00f6nnen mehrere Sektoren dargestellt werden) Gr\u00f6\u00dfe: Wir variieren die Gr\u00f6\u00dfe der Kreise entsprechend der Verkaufsfl\u00e4chen. Alternative zum Diagramm Gr\u00f6\u00dfe von Einzelzeichen nach Datenwerten variieren Einstellung f\u00fcr Einzelsymbol: Bei Gr\u00f6\u00dfe \"Datendefinierte Steuerung\" anklicken Dort \u00fcber \"Bearbeiten\" einen Ausdruck eingeben: Datendefinierte Steuerung f\u00fcr Gr\u00f6\u00dfe Ausdruckseditor Der eingegebene Ausdruck muss eine Gr\u00f6\u00dfenangabe ergeben, die einem Wert im Eingabefeld Gr\u00f6\u00dfe entspricht. Wir erreichen dies durch die Division des Attributwertes!","title":"QGIS-Einf\u00fchrung"},{"location":"ch01/p04_qgis_einf.html#qgis","text":"Open Source Software Auf den Rechnern der CIP-Pools installiert M\u00f6glichkeit zur Installation auf USB-Stick/-Laufwerk","title":"QGIS"},{"location":"ch01/p04_qgis_einf.html#usb-version","text":"Im Campus-Netz zum herunterladen: Gro\u00dfe oder Kleine Installation USB-Laufwerk (Stick) mit USB3, schnelles Medium Das Startmen\u00fc der USB-Version Vorteile: Gute Kartographie im Vergleich zu anderen GIS kann mit nach Hause genommen werden zus\u00e4tzliche GIS-/Software integriert und mit eigenen PortableApps erg\u00e4nzbar","title":"USB-Version:"},{"location":"ch01/p04_qgis_einf.html#einfuhrungen-in-qgis","text":"Auf qgis.org Neue Version QGIS3 mit teilweise unvollst\u00e4ndiger Dokumentation Online-Ressourcen zu einzelnen \u00dcbungen Literatur: A. Cutts, A. Graser: Learn QGIS, 4. Auflage, Packt> A. Graser and G. N. Peterson: QGIS Map Design Einf\u00fchrung: - Treglia_QGIS_Tutorial_3_0","title":"Einf\u00fchrungen in QGIS"},{"location":"ch01/p04_qgis_einf.html#qgis-benutzeroberflache","text":"Die Benutzeroberf\u00e4che von QGIS3 Um die Processing Toolbox Toolbox anzuzeigen, klicken wir Men\u00fc: View | Panels | Processing Toolbox","title":"QGIS-Benutzeroberfl\u00e4che"},{"location":"ch01/p04_qgis_einf.html#bedienfelder-und-werkzeugkasten","text":"k\u00f6nnen \u00fcber das Menu:Ansicht ein- oder ausgeschaltet werden Projekt: Funktionen, um ein QGIS-Projekt zu laden, zu speichern, oder zu erzeugen. Kartennavigation: beinhaltet Werkzeuge zum Verschieben, Zoomen als auch die Verwaltung von Lesezeichen und die Kartenaktualisierung. Attributwerkzeuge: umfasst Tools, um Objekte in der Karte zu identifizieren, zu seleltieren, eine Tabellenansicht zu \u00f6ffnen oder in der Karte zu messen. Datenquellen: Funktionen, um Daten in ein QGIS-Projekt zu laden, oder neue Datens\u00e4tze zu erzeugen.","title":"Bedienfelder und Werkzeugk\u00e4sten"},{"location":"ch01/p04_qgis_einf.html#ubung-ikea-filialen","text":"Daten: Wikipedia-Artikel https://de.wikipedia.org/wiki/IKEA_Deutschland mit Tabelle und Karte ikea_wiki_table_org.csv : Angaben zum Jahr der Er\u00f6ffnung und Gr\u00f6\u00dfe der Verkaufsfl\u00e4che herunterladen ikea_wikipedia Standorte.kml : Punkte/Koordinaten herunterladen","title":"\u00dcbung: Ikea-Filialen"},{"location":"ch01/p04_qgis_einf.html#vorgehensweise","text":"Daten ansehen csv-Feldtypen anpassen Daten in QGIS laden Join \u00fcber den Namen der Filialen Speichern im GeoPackage-Format, mit Auswahl relevanter Felder (Attribute) Laden der Datei ikea_wikipedia Standorte.kml in QGIS \u00fcber die Datenquellverwaltung: Datenquellverwaltung \u00f6ffnen Inspektion der Ikea-Standorte Ansicht und Abfrage geladener Informationen Vorbereitung zur Datei ikea_wiki_table_org.csv kopieren nach ikea_wiki_table.csv Mit Notepad++ \u00f6ffnen und editieren: Erste Zeile mit Namen, Tabulator getrennt: Filiale Jahr VerkFl Suchen/ersetzen: Punkte in Verkaufsfl\u00e4chen eliminieren Filiale Jahr VerkFl Augsburg (Gersthofen) 2006 31000 Berlin-Lichtenberg 2010 43000 Berlin-Spandau 1979 36300 Berlin-Tempelhof (Berlin-Sch\u00f6neberg) 2003 37000 Datentypen der Spalten deklarieren: Neue Datei anlegen ikea_wiki_table.csvt Mit Notepad++ \u00f6ffnen und editieren: \"String\",\"Integer\",\"Integer\" Datei ikea_wiki_table.csv in QGIS laden Optionen beim Importieren der Tabelle Join der beiden Datens\u00e4tze Layereigenschaften der kml-Datei \u00f6ffnen auf Verkn\u00fcpfungen klicken mit Plus [+] neuen Join hinzuf\u00fcgen Aufruf Layereigenschaften->Verkn\u00fcpfungen Die Spalten f\u00fcr den Join m\u00fcssen exakt dieselben Werte enthalten! Namen m\u00fcssen evtl. korrigiert werden! Optionen der Verkn\u00fcpfung Ergebnis: Spalten aus ikea_wiki_table wurden angehangen. Daten in QGIS untersuchen Tabelle anzeigen: Men\u00fc->Layer->Attributtabelle \u00f6ffnen ge\u00f6ffnete Attributtabelle Klick auf Spaltennamen sortiert die Anzeige Datenexport: Wir exportieren das Ergebnis in ein anderes Datenformat Unter Layer-> ikea_wikipedia Standorte rufen wir das Kontextmen\u00fc mit der rechten Maustaste auf und w\u00e4hlen: Exportieren->Objekt speichern als Wir w\u00e4hlen alle \u00fcberfl\u00fcssigen Spalten ab und behalten nur diese Spalten: Name, description, ikea_wiki_table_Jahr, ikea_wiki_table_VerkFl Optionen f\u00fcr den Export als Geopackage GeoPackage ist ein relativ neues aber standardisiertes Datenformat f\u00fcr Geodaten!","title":"Vorgehensweise:"},{"location":"ch01/p04_qgis_einf.html#basiskarte-fur-die-ikea-filialen","text":"Plugin QuickMapServices benutzen Plugin installieren: Suche: QuickMapServices Men\u00fc:Web->Quick Map Services->Settings: More Services->Get contributed pack ausw\u00e4hlen der Basiskarte: OSM-Standard Installation des Plugins Anpassen der Projektion Projektion der Basiskarte: Web-Mercator Einstellen f\u00fcr Projekt, Projekteigenschaften->KBS Suche: Web Einstellung f\u00fcr das Koordinatensystem des Projekts Da die Basiskarte als Raster dargestellt wird, erhalten wir mit der passenden Projektion eine bessere Qualit\u00e4t!","title":"Basiskarte f\u00fcr die Ikea-Filialen"},{"location":"ch01/p04_qgis_einf.html#grafikeinstellungen-fur-vektorlayer","text":"Unter Layer \u00f6ffnen wir das Layergestaltungsfenster Layergestalungsfenster \u00f6ffnen Im ge\u00f6ffneten Bedienfeld find wir die Einstellungen zur Grafik des Layers Bedienfeld Layergestaltung Alternativ kann man diese Einstellungen auch \u00fcber die Layereigenschaften erreichen, Das bereits ge\u00f6ffnete sogenannte Dockingfenster ist praktischer (live-Aktualisierung) Aufruf der Symbology \u00fcber die Layereigenschaften Die Einstellungen k\u00f6nnen im Bedienfeld sehr detailliert vorgenommen werden. Grobe Einteilung: Ansicht zur Einstellung \"Einfache Markierung\" Einzelsymbol: Alle Daten erhalten die gleiche Darstellung Klicken Sie auf Einzelsymbol, um weitere Darstellungsmethoden zu sehen Neben Einzelsymbol gibt es: Kategorisiert, Abgestuft und so weiter, \u00e4hnlich wie in ESRI's ArcMap Eigenschaften f\u00fcr Einfache Markierung Hier sehen wir die einzelnen Graphikparameter Gr\u00f6\u00dfe F\u00fcllfarbe Strichfarbe usw. dienen der Auswahl von Farben und Gr\u00f6\u00dfen etc. Einstellungen zu Einfache Markierung Neben der \"Einfachen Markierung\" gibt es aber auch andere Zeichenverfahren: Symbollayertypen als Zeichenverfahren Datengesteuerte Parameter Zus\u00e4tzlich k\u00f6nnen alle Parameter auch durch Datenwerte gesteuert werden!","title":"Grafikeinstellungen f\u00fcr Vektorlayer"},{"location":"ch01/p04_qgis_einf.html#ikea-filialen-darstellen-einzelsymbol","text":"Zeichengr\u00f6\u00dfe: Angegeben in Millimeter, Ver\u00e4nderungen k\u00f6nnen direkt eingegeben und im Kartenfenster beurteilt werden Gr\u00f6\u00dfenangabe Die F\u00fcllfarbe kann auf zweierleiweise eingestellt werden: Farbe Ein Klick auf den Schalter (rechts) \u00f6ffnet eine Farbauswahl, direkt im Fenster direkte Farbauswahl Ein Klick auf die Farbe selbst \u00f6ffnet eine neue Ansicht, in der mehr Optionen zur Verf\u00fcg stehen von dort zur\u00fcck geht es \u00fcber den blauen Pfeil: Farbauswahl im Folgefenster","title":"Ikea-Filialen darstellen: Einzelsymbol"},{"location":"ch01/p04_qgis_einf.html#ikea-filialen-darstellen-abgestuft","text":"Eine abgestufte Darstellung wird durch die Datenwerte eines Attributs gesteuert Wir w\u00e4hlen das Attribut f\u00fcr die Verkaufsfl\u00e4che Als Methode w\u00e4hlen wir Size, um die Gr\u00f6\u00dfe der Zeichen zu variieren Anschlie\u00dfend w\u00e4hlen wir Klassifizieren, um 5 unterschiedliche Gr\u00f6\u00dfenabstufungen zu erzielen Darstellungsverfahren \"Abgestuft\" Ergebnis (Ausschnitt) Ergebnisdarstellung","title":"Ikea-Filialen darstellen: Abgestuft"},{"location":"ch01/p04_qgis_einf.html#ikea-filialen-darstellen-kreisdiagramm","text":"Diagrammdarstellungen finden wir unter Layereigenschaften->Diagramme Einstellungen f\u00fcr Kreisdiagramme Einstellungen: Die Darstellung aus den vorangegangenen Schritten schalten wir aus: \"Keine Symbole\" Attribute: Wir benutzen ein beliebiges Attribut, um dem Diagramm eine Farbe zuzuordnen (theoretisch k\u00f6nnen mehrere Sektoren dargestellt werden) Gr\u00f6\u00dfe: Wir variieren die Gr\u00f6\u00dfe der Kreise entsprechend der Verkaufsfl\u00e4chen.","title":"Ikea-Filialen darstellen: Kreisdiagramm"},{"location":"ch01/p04_qgis_einf.html#alternative-zum-diagramm","text":"Gr\u00f6\u00dfe von Einzelzeichen nach Datenwerten variieren Einstellung f\u00fcr Einzelsymbol: Bei Gr\u00f6\u00dfe \"Datendefinierte Steuerung\" anklicken Dort \u00fcber \"Bearbeiten\" einen Ausdruck eingeben: Datendefinierte Steuerung f\u00fcr Gr\u00f6\u00dfe Ausdruckseditor Der eingegebene Ausdruck muss eine Gr\u00f6\u00dfenangabe ergeben, die einem Wert im Eingabefeld Gr\u00f6\u00dfe entspricht. Wir erreichen dies durch die Division des Attributwertes!","title":"Alternative zum Diagramm"},{"location":"ch01/p05_pyqgis.html","text":"\u00dcbersicht zu PyQGIS F\u00fcr QGIS existiert eine umfangreiche Python-Schnitstelle, die die Komplette C++-API umfasst. Diese Schnitstelle zu der kompletten GIS-Funktionalit\u00e4t wird PyQGIS genannt. Wie wir gesehen haben, lassen sich mit Python eigenst\u00e4ndige GIS-Programme schreiben, die auf das QgsApplication-Objekt zugreifen. Aber auch innerhalb des QGIS kann Python eingesetzt werden, um den Funktionsumfang zu erweitern: Scripte ausf\u00fchren, \u00fcber die eingebaute Python-Shell Processing scripts schreiben, werden in der Processing Toolbox angezeigt Plugins, lassen sie \u00fcber den Plugin-Manager installieren und k\u00f6nnen in den Men\u00fcs und Toolbars aufgerufen werden Ressourcen Umfangreiches Cookbook . Beschreibung der API - C++ Speziell aufbereitet f\u00fcr [Python] (https://qgis.org/pyqgis/3.4/) Code-Beispiele f\u00fcr Python-Classes der API Buch zur Python-Qgis-Entwicklung von Gary Sherman: The PyQGIS Programmer\u2019s Guide Das pyqgis-Modul (qgis) Ein Modul mit Untermodulen f\u00fcr den den Zugang der QGIS-Funktionen und Benutzeroberf\u00e4che, aufgeteilt in die Untermodule qgis.core - core classes qgis.gui - graphical user interface classes qgis.analysis - analysis related classes weitere ... (Im Ordner osgeo4w unter apps\\qgis-ltr\\python\\qgis) Iface-Objekt qgis.gui.iface entspricht der Schnittstelle (QgisInterface) zu den aktiven Elementen von QGIS, etwa zum Kartenfenster und den dort angezeigten Layern. In der QGIS-Python-Konsole ist das iface-Objekt bereits importiert. Auch Plugins bekommen \u00fcber dieses Objekt Zugriff auf QGIS-Elemente. Beispiel: Wir laden hierf\u00fcr den Layer mit Ikea-Standorten! >>> layer = iface.activeLayer() >>> layer.id() >>> layer.featureCount() Weitere Beispiele zur Nutzung des Iface-Objekts mapCanvas() >>> map = iface.mapCanvas() >>> map.layers() [...] Layer laden: iface.addVectorLayer(r\"Pfad_zu\\data\\fluesse_01_03.gpkg\", \"Fluss\", \"ogr\") iface.addRasterLayer(r\"Pfad_zu\\data\\brd_dgm_utm.tif\", \"DGM\") Nachrichten an den Nutzer mit messageBar: >>> iface.messageBar().pushMessage( \"Error\", \"I'm sorry Dave, I'm afraid I can't do that\", level=Qgis.Critical) Das Devoloper-Cookbook Die folgenden Beispiele sind dem Developer Cookbook entnommen (s. oben in Ressourcen). Es behandelt die wichtigsten Grundlagen zur Programmierung mit Python und QGIS. Einige der Beispiele benutzen andere Daten oder wurden zur K\u00fcrzung leicht abge\u00e4ndert. Loading Projects >>> project = QgsProject.instance() >>> project <qgis._core.QgsProject object at 0x11326CB0> >>> project.fileName() '' >>> project.read(r'C:\\Pfad\\zum\\projekt\\analyse.qgz') True Loading Layers Hier wird die Vorgehensweise ohne iface-Objekt beschrieben. Vektor-Layer Wir legen im Editor ein Script an: path=r\"C:\\Pfad\\zu\\qgis_einf\\ikea_wikipedia.kml\" vlayer = QgsVectorLayer(path, \"Ikea layer\", \"ogr\") if not vlayer.isValid(): print(\"Layer failed to load!\") else: QgsProject.instance().addMapLayer(vlayer) Das Laden eines Vektor-Layers erfolgt mit Parametern, die abh\u00e4ngig von der Datenquelle sind. Im Cookbook werden Beispiele gegeben f\u00fcr Shapefile dxf PostGIS Datenbank CSV GPX WFS Internet-Zugriff und andere mehr Raster Wir benutzen ein DGM-Raster f\u00fcr Deutschland path = r\"C:\\Pfad\\zu\\data\\brd_dgm_utm.tif\" rlayer = QgsRasterLayer(path, \"SRTM DEM layer\") if not rlayer.isValid(): print(\"Layer failed to load!\") else: QgsProject.instance().addMapLayer(rlayer) Auch bei Rastern gibt es mehrere m\u00f6gliche Datenformate. Using Raster Layers Wir bleiben bei dem zuvor geladenen Raster-Layer und benutzen die Python-Console >>> rlayer <qgis._core.QgsRasterLayer object at 0x05505620> >>> rlayer.width(), rlayer.height() (3207, 4331) >>> rlayer.extent() <QgsRectangle: 279899.99999999988358468 5235899.99999999813735485, 921299.99999999953433871 6102099.99999999720603228> rlayer.extent().toString() '279899.9999999998835847,5235899.9999999981373549 : 921299.9999999995343387,6102099.9999999972060323' rlayer.rasterType() 0 Der Rastertyp verwender eine Zahl als Code: Code Wert 0 GrayOrUndefined (single band) 1 Palette (single band) 2 Multiband Renderer Der Renderer ist daf\u00fcr zust\u00e4ndig, wie das Raster dargestellt wird. F\u00fcr Raster gibt es: Name/Klasse Erl\u00e4uterung QgsMultiBandColorRenderer typically drawn by mapping the bands to RGB colors QgsPalettedRasterRenderer using the palette stored inside the raster QgsSingleBandGrayRenderer in gray colors (low values = black, high values = white) QgsSingleBandPseudoColorRenderer use pseudocolor algorithm that assigns colors to values >>> rlayer.renderer() <qgis._core.QgsSingleBandGrayRenderer object at 0x045951C0> >>> rlayer.renderer().type() 'singlebandgray' QgsSingleBandPseudoColorRenderer Ein Beispiel f\u00fcr ein Farbreihe mit dem QgsSingleBandPseudoColorRenderer. Wir schreiben ein Script im Editor! Im ersten Schritt erfolgt die Definition eines Shaders, im zweiten wir ein Renderer-Objekt erstellt und dem Raster zugewiesen: fcn = QgsColorRampShader() fcn.setColorRampType(QgsColorRampShader.Interpolated) lst = [ QgsColorRampShader.ColorRampItem(0, QColor(100,255,0)) , QgsColorRampShader.ColorRampItem(1000, QColor(226, 83, 3)), ] fcn.setColorRampItemList(lst) shader = QgsRasterShader() shader.setRasterShaderFunction(fcn) renderer = QgsSingleBandPseudoColorRenderer(rlayer.dataProvider(), 1, shader) rlayer.setRenderer(renderer) rlayer.triggerRepaint() Query Values Hier geht darum, wie der Wert einer Rasterzelle abgefragt werden k\u00f6nnen. Dazu ben\u00f6tigen wir einen Punkt, in QGIS ein QgsPointXY-Objekt: ident = rlayer.dataProvider().identify(QgsPointXY(609933, 5737266), QgsRaster.IdentifyFormatValue) if ident.isValid(): print(ident.results()) Koordinaten m\u00fcssen zum System des Rasters passen: UTM32: 609933, 5737266 im Bereich des Harz Entspricht der interaktiven Funktion \"Identify Features\" L\u00f6sung f\u00fcr Zugriff auf Rasterdaten Gemeint ist die Nutzung der \"Pixelwerte\" eines Rasters. In Python realisierbar \u00fcber das Modul Numpy. Eine m\u00f6gliche L\u00f6sung, um ein Numpy-Array aus einem Rasterdatensatz zu erzeugen, f\u00fchrt \u00fcber das gdal-Modul: from osgeo import gdal def layerAsArray(layer): \"\"\" read the data from a single-band layer into a numpy/Numeric array. Only works for gdal layers! \"\"\" gd = gdal.Open(str(layer.source())) array = gd.ReadAsArray() return array GIS Stackexchange Die Funktion liest die Rasterdatenquelle und gibt ein Numpy-Array zur\u00fcck. Mehr zu Numpy: Numpy aus dem letzten Semester Mehr zu gdal/ogr: Das Python GDAL/OGR-Cookbook Using Vector Layers Wir verwenden weiter den Layer mit den IKEA-Standorten Eine Liste aller Attributspalten (Felder): for field in vlayer.fields(): print(field.name(), field.typeName()) Name String description String timestamp DateTime begin DateTime end DateTime altitudeMode String tessellate Integer extrude Integer visibility Integer drawOrder Integer icon String snippet String Iterating over Vector Layer Wir legen ein Script an. Im Script geben wir Informationen \u00fcber alle Ikea-Stadorte aus: features = vlayer.getFeatures() for feature in features: print(\"Feature ID: \", feature.id(), end=\", \") print(\"Geometry type:\", feature.geometry().type()) Der Geometrietyp aller Objekte ist 0. Die Zahl ist ein Code f\u00fcr die folgenden Geometrietypen: Code Definition Bedeutung 0 QgsWkbTypes.PointGeometry Punkt 1 QgsWkbTypes.LineGeometry Linie 2 QgsWkbTypes.PolygonGeometry Polygon 3 QgsWkbTypes.UnknownGeometry Unbekannte Geometrie 4 QgsWkbTypes.MultiPoint Multi-Gemeometrie mit Punkten 5 QgsWkbTypes.MultiLineString Multi-Gemeometrie mit Linien 6 QgsWkbTypes.MultiPolygon Multi-Gemeometrie mit Polygonen Eine Erl\u00e4uterung, woher diese Festlegung von Geometrietypen stammt, ist weiter unten erl\u00e4utert. Kennen wir den Typ, so k\u00f6nnen wir auch die Koordinaten ausgeben: # in der for-Schleife geom = feature.geometry() p = geom.asPoint() print(\"Point: \", p) Die Ausgabe der Geometrie kann auch als Well-Known-Text (WKT-String) erfolgen: p.asWkt() Das Feature-Objekt erm\u00f6glicht den Zugriff auf Attributwerte \u00fcber ein Python-Dictionary, hier der Name der Ikea-Filiale, oder alternativ \u00fcber den Index: # in der for-Schleife print(feature['Name']) # alternativ: feature[0] -- Name ist das erste Attribute Selecting features Selektionen auf Daten bilden eine Auswahl, meist \u00fcber einen Wert oder Ausdruck. Die entsprechenden Elemente werden in QGIS in einer voreingestellten Farbe markiert . Dies selektiert alle Objekte: # Get the active layer (must be a vector layer) >>> layer = iface.activeLayer() >>> layer.selectAll() weitere Selektionsfunktionen: Funktion Beispiel/Erl\u00e4uterung layer.removeSelection() entfernt die Markierung wieder selectByExpression() layer.selectByExpression('\"Name\" like \\'W%\\'', QgsVectorLayer.SetSelection) iface.mapCanvas().setSelectionColor() iface.mapCanvas().setSelectionColor( QColor(\"red\") ) Creating Vector-Layers Das Cookbook erw\u00e4hnt zwei unterschiedliche M\u00f6glichkeiten einen Vektorlayer zu erzeugen: QgsVectorFileWriter QgsVectorLayer In diesem Beispiel benutzen wir QgsVectorFileWriter, um den Layer der Ikea-Standorte in einem Geopacke zu speichern: layer = iface.activeLayer() # Write to a GeoPackage (default) error = QgsVectorFileWriter.writeAsVectorFormat(layer, \"c:/path/to/folder/my_data\", \"\") if error[0] == QgsVectorFileWriter.NoError: print(\"success!\") Haben wir die Daten noch nicht als Layer vorliegen, m\u00fcssen wir sie zun\u00e4chst als Features erzeugen, inkl. Attributen und Geometrien. Dieser Vorgang erfolgt in mehreren Schritten: Erzeugen der Attribute/Felder Anlegen einer neuen Vektor-Datei Erzeugung der Feature-Objekte Speichern der Features in der Vektor-Datei from qgis.PyQt.QtCore import QVariant path = \"C:/Pfad/zu/meinem/out_shape.shp\" # define fields for feature attributes. A QgsFields object is needed fields = QgsFields() fields.append(QgsField(\"Id\", QVariant.Int)) fields.append(QgsField(\"Name\", QVariant.String)) # create a writer object writer = QgsVectorFileWriter(path, \"UTF-8\", fields, QgsWkbTypes.Point, driverName=\"ESRI Shapefile\") if writer.hasError() != QgsVectorFileWriter.NoError: print(\"Error when creating shapefile: \", w.errorMessage()) # add a feature fet = QgsFeature() fet.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(10,10))) fet.setAttributes([1, \"beispiel\"]) writer.addFeature(fet) # delete the writer to flush features to disk del writer Aufgabe zum Import aus einer CSV-Datei Die Beispieldatei temp_1961-90.csv enth\u00e4lt die durchschnittlichen Temperaturwerte, die an 727 Messstationen aufgezeichnet wurden. Die Temperaturen sind im Monats- und im Jahresmittel angegeben. So sehen die ersten beiden Zeilen der Textdatei 'temp_1961-90.csv' aus: ALIASNAME;H\u00f6he \u00fc NN;Breite;L\u00e4nge;Bundesland;Jan;Feb;Mrz;Apr;Mai;Jun;Jul;Aug;Sep;Okt;Nov;Dez;Jahr AACHEN (WEWA);202;50\u00b047';06\u00b005';Nordrhein-Westfalen;2.4;2.8;5.4;8.4;12.8;15.6;17.3;17.1;14.4;10.8;6.1;3.4;9.7 Wir verwenden Bordmittel f\u00fcr den Import: Datei \u00f6ffnen Feldnamen lesen Qgis-Felder erzeugen Ausgabedatei mit QgsVectorFileWriter anlegen Features zeilenweise lesen, jeweils: Werte als Variablen mit den korrekten Typen anlegen eine Punktgeometrie erzeugen QGIS-Feature erzeugen und in Ausgabe-Datei schreiben # Helper function def toDD(Deg, Min, Sec=0): \"\"\"make decimal from degree, minutes, seconds\"\"\" return float(Deg + Min/60 + Sec/3600) # read csv with open('data/temp_1961-90.csv') as csvfile: header = csvfile.readline().split(';') # Header line # create qgis fields # create outfile with QgsVectorFileWriter for srow in csvfile: row = srow.split(';') name = row[0] H = float(row[1]) # B = toDD(*map(int, row[2].strip(\"'\").split('\u00b0'))) # L = toDD(*map(int, row[3].strip(\"'\").split('\u00b0'))) # https://www.i18nqa.com/debug/utf8-debug.html # row[2].strip(\"'\").split('\\u00c2\\u00b0') => ['49','7'] # map(int, ['49','7']) => [49, 7] # *[49, 7] => 49, 7 B = toDD(*map(int, row[2].strip(\"'\").split('\\u00c2\\u00b0'))) L = toDD(*map(int, row[3].strip(\"'\").split('\\u00c2\\u00b0'))) land = row[4] values = list(map(float, row[5:])) # make a point geometry # build a qgis feature # write to file Hinweis: Das Script benutzt die with-Anweisung: in Python kann ein Code-Block mit with erzeugt werden. Hierbei wird eine Anweisung hinzugef\u00fcgt, die ein Objekt erzeugt, das nur innerhalb des Blocks g\u00fcltig ist und von python am Ende der Verarbeitung automatisch gel\u00f6scht wird. stackoverflow In unserem Fall ist dies die Open-Anweisung, welche ein file object zur\u00fcckgibt. Vorteil: Das file object muss nicht explizit geschlossen werden. Geometry Handling Behandelt das Thema zur Umgang mit Geometrien von Vektordaten, ausf\u00fchrlicher als oben im Beispiel der erzeugten Punkte. QGIS benutzt f\u00fcr die Geometrien die Definitionen aus dem Simple-Features-Modell : Schema des Simple-Feature-Modells Behandelt werden Points, Linestrings und Polygons mit Single oder Multipart-Geometrien. Eine abstakte Klasse dazu ist QgsGeometry . Ein Beispiel um Geometrien als Point, LineString und Polygon zu erzeugen: gPnt = QgsGeometry.fromPointXY(QgsPointXY(1,1)) gLine = QgsGeometry.fromPolyline([QgsPoint(1, 1), QgsPoint(2, 2)]) gPolygon = QgsGeometry.fromPolygonXY([[QgsPointXY(1, 1), QgsPointXY(2, 2), QgsPointXY(2, 1)]]) Die Definition eine Geometrietyps wird \u00fcber die Methode wkbType() realisiert. Objekt Typvergleich gPnt.wkbType() # 1 gPnt.wkbType() == QgsWkbTypes.Point gLine.wkbType() # 2 gLine.wkbType() == QgsWkbTypes.LineString gPolygon.wkbType() # 3 gPolygone.wkbType() == QgsWkbTypes.Polygon wkbType steht f\u00fcr Well-Known-Binary-Type und gibt die angegebenen Codes zur\u00fcck. Vorsicht: Diese unterscheiden sich von der Angabe in geometry.type()! Ein Beispiel, um Geometrien als Python-Lists zu erhalten: gPnt.asPoint() # output: <QgsPointXY: POINT(1 1)> gLine.asPolyline() # output: [<QgsPointXY: POINT(1 1)>, <QgsPointXY: POINT(2 2)>] gPolygon.asPolygon() # output: [[<QgsPointXY: POINT(1 1)>, <QgsPointXY: POINT(2 2)>, <QgsPointXY: POINT(2 1)>, <QgsPointXY: POINT(1 1)>]] Hinweis: QgsPointXY ist keine QGIS-Geometrieklasse, sondern ein Hilfsmittel (eine Primitive ), um Geometrien zu erzeugen. Neben QgsPointsXY existiert eine weitere Klasse QgsPoint als abstrakte Geometrie . In diesem Bereich fallen auch QgsLineString und QgsPolygon. Sie k\u00f6nnen ebenfalls den Geometrie-Funktionen fromPolyline bzw. fromPolygon \u00fcbergeben werden. Auch asPolyline() und asPolygon() geben keine QGIS-Geometrien zur\u00fcck, sondern verpacken QgsPointXY-Objekte in python lists. Geometrien nehmen mit steigender Dimension an Komplexit\u00e4t zu. Folgende Abbildung zeigt die unterschiedlichen Definitionen ein Polygons: Polygon und Multipolygon ist ein Polygon, bestehend aus einem Linear Ring, dem sog. Exterior Ring ein Polygon mit einem Loch, also mit einem Exterior Ring und einem Interior Ring ein Multipolygon, bestehend aus zwei Polygonen wie unter 1 beschrieben Ein Multipolygon, bestehend aus zwei Polygonen wie unter 2 beschrieben Projections Support QGIS definiert Projektionen/Koordinatensysteme \u00fcber die Klasse QgsCoordinateReferenceSystem . Die Koordinatensysteme k\u00f6nnen als Code angegeben werden, n\u00e4mlich u.a. als EPSG-Codes, oder als Well-Known-Text, also einem festgelegten Stringformat. Ein Verzeichnis aller Codes finden wir hier crs = QgsCoordinateReferenceSystem(4326, QgsCoordinateReferenceSystem.EpsgCrsId) print(crs.description()) print(crs.toWkt()) Wenn das Koordinatensystem einer Geometrie ge\u00e4ndert werden soll, muss es transformiert werden. QGIS definiert hierf\u00fcr die Klasse QgsCoordinateTransform: crsSrc = QgsCoordinateReferenceSystem(4326) # WGS 84 crsDest = QgsCoordinateReferenceSystem(25832) # ETRS89 / UTM zone 32N xform = QgsCoordinateTransform(crsSrc, crsDest, QgsProject.instance()) pt1 = xform.transform(QgsPointXY(49.756, 6.643)) # Trierer Dom print(\"Transformed point:\", pt1) # inverse transformation: dest -> src pt2 = xform.transform(pt1, QgsCoordinateTransform.ReverseTransform) print(\"Transformed back:\", pt2) Aufgabe zur Koordinatentransformation Wir transformieren die Punkte der Temperatur-Messstationen von ihrem Ausgangskoordinatensystem WGS84 in das der UTM-Zone 32. Aufbauend auf den Script-Entwurf oden erg\u00e4nzen wir die notwendigen Schritte: # Helper function def toDD(Deg, Min, Sec=0): \"\"\"make decimal from degree, minutes, seconds\"\"\" return float(Deg + Min/60 + Sec/3600) # read csv with open('data/temp_1961-90.csv') as csvfile: header = csvfile.readline().split(';') # Header line # create qgis fields # prepare coordinate transformation: create crsSrc, crsDest und xform # create outfile with QgsVectorFileWriter # use Parameter srs=crsDest to store crs with the shapefile for srow in csvfile: row = srow.split(';') name = row[0] H = float(row[1]) # B = toDD(*map(int, row[2].strip(\"'\").split('\u00b0'))) # L = toDD(*map(int, row[3].strip(\"'\").split('\u00b0'))) # https://www.i18nqa.com/debug/utf8-debug.html # row[2].strip(\"'\").split('\\u00c2\\u00b0') => ['49','7'] # map(int, ['49','7']) => [49, 7] # *[49, 7] => 49, 7 B = toDD(*map(int, row[2].strip(\"'\").split('\\u00c2\\u00b0'))) L = toDD(*map(int, row[3].strip(\"'\").split('\\u00c2\\u00b0'))) land = row[4] values = list(map(float, row[5:])) # transform with xform into a QgsPointXY # make a point geometry # build a qgis feature # write to file","title":"PyQGIS-Tutorial"},{"location":"ch01/p05_pyqgis.html#ubersicht-zu-pyqgis","text":"F\u00fcr QGIS existiert eine umfangreiche Python-Schnitstelle, die die Komplette C++-API umfasst. Diese Schnitstelle zu der kompletten GIS-Funktionalit\u00e4t wird PyQGIS genannt. Wie wir gesehen haben, lassen sich mit Python eigenst\u00e4ndige GIS-Programme schreiben, die auf das QgsApplication-Objekt zugreifen. Aber auch innerhalb des QGIS kann Python eingesetzt werden, um den Funktionsumfang zu erweitern: Scripte ausf\u00fchren, \u00fcber die eingebaute Python-Shell Processing scripts schreiben, werden in der Processing Toolbox angezeigt Plugins, lassen sie \u00fcber den Plugin-Manager installieren und k\u00f6nnen in den Men\u00fcs und Toolbars aufgerufen werden","title":"\u00dcbersicht zu PyQGIS"},{"location":"ch01/p05_pyqgis.html#ressourcen","text":"Umfangreiches Cookbook . Beschreibung der API - C++ Speziell aufbereitet f\u00fcr [Python] (https://qgis.org/pyqgis/3.4/) Code-Beispiele f\u00fcr Python-Classes der API Buch zur Python-Qgis-Entwicklung von Gary Sherman: The PyQGIS Programmer\u2019s Guide","title":"Ressourcen"},{"location":"ch01/p05_pyqgis.html#das-pyqgis-modul-qgis","text":"Ein Modul mit Untermodulen f\u00fcr den den Zugang der QGIS-Funktionen und Benutzeroberf\u00e4che, aufgeteilt in die Untermodule qgis.core - core classes qgis.gui - graphical user interface classes qgis.analysis - analysis related classes weitere ... (Im Ordner osgeo4w unter apps\\qgis-ltr\\python\\qgis)","title":"Das pyqgis-Modul (qgis)"},{"location":"ch01/p05_pyqgis.html#iface-objekt","text":"qgis.gui.iface entspricht der Schnittstelle (QgisInterface) zu den aktiven Elementen von QGIS, etwa zum Kartenfenster und den dort angezeigten Layern. In der QGIS-Python-Konsole ist das iface-Objekt bereits importiert. Auch Plugins bekommen \u00fcber dieses Objekt Zugriff auf QGIS-Elemente. Beispiel: Wir laden hierf\u00fcr den Layer mit Ikea-Standorten! >>> layer = iface.activeLayer() >>> layer.id() >>> layer.featureCount() Weitere Beispiele zur Nutzung des Iface-Objekts mapCanvas() >>> map = iface.mapCanvas() >>> map.layers() [...] Layer laden: iface.addVectorLayer(r\"Pfad_zu\\data\\fluesse_01_03.gpkg\", \"Fluss\", \"ogr\") iface.addRasterLayer(r\"Pfad_zu\\data\\brd_dgm_utm.tif\", \"DGM\") Nachrichten an den Nutzer mit messageBar: >>> iface.messageBar().pushMessage( \"Error\", \"I'm sorry Dave, I'm afraid I can't do that\", level=Qgis.Critical)","title":"Iface-Objekt"},{"location":"ch01/p05_pyqgis.html#das-devoloper-cookbook","text":"Die folgenden Beispiele sind dem Developer Cookbook entnommen (s. oben in Ressourcen). Es behandelt die wichtigsten Grundlagen zur Programmierung mit Python und QGIS. Einige der Beispiele benutzen andere Daten oder wurden zur K\u00fcrzung leicht abge\u00e4ndert.","title":"Das Devoloper-Cookbook"},{"location":"ch01/p05_pyqgis.html#loading-projects","text":">>> project = QgsProject.instance() >>> project <qgis._core.QgsProject object at 0x11326CB0> >>> project.fileName() '' >>> project.read(r'C:\\Pfad\\zum\\projekt\\analyse.qgz') True","title":"Loading Projects"},{"location":"ch01/p05_pyqgis.html#loading-layers","text":"Hier wird die Vorgehensweise ohne iface-Objekt beschrieben.","title":"Loading Layers"},{"location":"ch01/p05_pyqgis.html#vektor-layer","text":"Wir legen im Editor ein Script an: path=r\"C:\\Pfad\\zu\\qgis_einf\\ikea_wikipedia.kml\" vlayer = QgsVectorLayer(path, \"Ikea layer\", \"ogr\") if not vlayer.isValid(): print(\"Layer failed to load!\") else: QgsProject.instance().addMapLayer(vlayer) Das Laden eines Vektor-Layers erfolgt mit Parametern, die abh\u00e4ngig von der Datenquelle sind. Im Cookbook werden Beispiele gegeben f\u00fcr Shapefile dxf PostGIS Datenbank CSV GPX WFS Internet-Zugriff und andere mehr","title":"Vektor-Layer"},{"location":"ch01/p05_pyqgis.html#raster","text":"Wir benutzen ein DGM-Raster f\u00fcr Deutschland path = r\"C:\\Pfad\\zu\\data\\brd_dgm_utm.tif\" rlayer = QgsRasterLayer(path, \"SRTM DEM layer\") if not rlayer.isValid(): print(\"Layer failed to load!\") else: QgsProject.instance().addMapLayer(rlayer) Auch bei Rastern gibt es mehrere m\u00f6gliche Datenformate.","title":"Raster"},{"location":"ch01/p05_pyqgis.html#using-raster-layers","text":"Wir bleiben bei dem zuvor geladenen Raster-Layer und benutzen die Python-Console >>> rlayer <qgis._core.QgsRasterLayer object at 0x05505620> >>> rlayer.width(), rlayer.height() (3207, 4331) >>> rlayer.extent() <QgsRectangle: 279899.99999999988358468 5235899.99999999813735485, 921299.99999999953433871 6102099.99999999720603228> rlayer.extent().toString() '279899.9999999998835847,5235899.9999999981373549 : 921299.9999999995343387,6102099.9999999972060323' rlayer.rasterType() 0 Der Rastertyp verwender eine Zahl als Code: Code Wert 0 GrayOrUndefined (single band) 1 Palette (single band) 2 Multiband","title":"Using Raster Layers"},{"location":"ch01/p05_pyqgis.html#renderer","text":"Der Renderer ist daf\u00fcr zust\u00e4ndig, wie das Raster dargestellt wird. F\u00fcr Raster gibt es: Name/Klasse Erl\u00e4uterung QgsMultiBandColorRenderer typically drawn by mapping the bands to RGB colors QgsPalettedRasterRenderer using the palette stored inside the raster QgsSingleBandGrayRenderer in gray colors (low values = black, high values = white) QgsSingleBandPseudoColorRenderer use pseudocolor algorithm that assigns colors to values >>> rlayer.renderer() <qgis._core.QgsSingleBandGrayRenderer object at 0x045951C0> >>> rlayer.renderer().type() 'singlebandgray'","title":"Renderer"},{"location":"ch01/p05_pyqgis.html#qgssinglebandpseudocolorrenderer","text":"Ein Beispiel f\u00fcr ein Farbreihe mit dem QgsSingleBandPseudoColorRenderer. Wir schreiben ein Script im Editor! Im ersten Schritt erfolgt die Definition eines Shaders, im zweiten wir ein Renderer-Objekt erstellt und dem Raster zugewiesen: fcn = QgsColorRampShader() fcn.setColorRampType(QgsColorRampShader.Interpolated) lst = [ QgsColorRampShader.ColorRampItem(0, QColor(100,255,0)) , QgsColorRampShader.ColorRampItem(1000, QColor(226, 83, 3)), ] fcn.setColorRampItemList(lst) shader = QgsRasterShader() shader.setRasterShaderFunction(fcn) renderer = QgsSingleBandPseudoColorRenderer(rlayer.dataProvider(), 1, shader) rlayer.setRenderer(renderer) rlayer.triggerRepaint()","title":"QgsSingleBandPseudoColorRenderer"},{"location":"ch01/p05_pyqgis.html#query-values","text":"Hier geht darum, wie der Wert einer Rasterzelle abgefragt werden k\u00f6nnen. Dazu ben\u00f6tigen wir einen Punkt, in QGIS ein QgsPointXY-Objekt: ident = rlayer.dataProvider().identify(QgsPointXY(609933, 5737266), QgsRaster.IdentifyFormatValue) if ident.isValid(): print(ident.results()) Koordinaten m\u00fcssen zum System des Rasters passen: UTM32: 609933, 5737266 im Bereich des Harz Entspricht der interaktiven Funktion \"Identify Features\"","title":"Query Values"},{"location":"ch01/p05_pyqgis.html#losung-fur-zugriff-auf-rasterdaten","text":"Gemeint ist die Nutzung der \"Pixelwerte\" eines Rasters. In Python realisierbar \u00fcber das Modul Numpy. Eine m\u00f6gliche L\u00f6sung, um ein Numpy-Array aus einem Rasterdatensatz zu erzeugen, f\u00fchrt \u00fcber das gdal-Modul: from osgeo import gdal def layerAsArray(layer): \"\"\" read the data from a single-band layer into a numpy/Numeric array. Only works for gdal layers! \"\"\" gd = gdal.Open(str(layer.source())) array = gd.ReadAsArray() return array GIS Stackexchange Die Funktion liest die Rasterdatenquelle und gibt ein Numpy-Array zur\u00fcck. Mehr zu Numpy: Numpy aus dem letzten Semester Mehr zu gdal/ogr: Das Python GDAL/OGR-Cookbook","title":"L\u00f6sung f\u00fcr Zugriff auf Rasterdaten"},{"location":"ch01/p05_pyqgis.html#using-vector-layers","text":"Wir verwenden weiter den Layer mit den IKEA-Standorten Eine Liste aller Attributspalten (Felder): for field in vlayer.fields(): print(field.name(), field.typeName()) Name String description String timestamp DateTime begin DateTime end DateTime altitudeMode String tessellate Integer extrude Integer visibility Integer drawOrder Integer icon String snippet String","title":"Using Vector Layers"},{"location":"ch01/p05_pyqgis.html#iterating-over-vector-layer","text":"Wir legen ein Script an. Im Script geben wir Informationen \u00fcber alle Ikea-Stadorte aus: features = vlayer.getFeatures() for feature in features: print(\"Feature ID: \", feature.id(), end=\", \") print(\"Geometry type:\", feature.geometry().type()) Der Geometrietyp aller Objekte ist 0. Die Zahl ist ein Code f\u00fcr die folgenden Geometrietypen: Code Definition Bedeutung 0 QgsWkbTypes.PointGeometry Punkt 1 QgsWkbTypes.LineGeometry Linie 2 QgsWkbTypes.PolygonGeometry Polygon 3 QgsWkbTypes.UnknownGeometry Unbekannte Geometrie 4 QgsWkbTypes.MultiPoint Multi-Gemeometrie mit Punkten 5 QgsWkbTypes.MultiLineString Multi-Gemeometrie mit Linien 6 QgsWkbTypes.MultiPolygon Multi-Gemeometrie mit Polygonen Eine Erl\u00e4uterung, woher diese Festlegung von Geometrietypen stammt, ist weiter unten erl\u00e4utert. Kennen wir den Typ, so k\u00f6nnen wir auch die Koordinaten ausgeben: # in der for-Schleife geom = feature.geometry() p = geom.asPoint() print(\"Point: \", p) Die Ausgabe der Geometrie kann auch als Well-Known-Text (WKT-String) erfolgen: p.asWkt() Das Feature-Objekt erm\u00f6glicht den Zugriff auf Attributwerte \u00fcber ein Python-Dictionary, hier der Name der Ikea-Filiale, oder alternativ \u00fcber den Index: # in der for-Schleife print(feature['Name']) # alternativ: feature[0] -- Name ist das erste Attribute","title":"Iterating over Vector Layer"},{"location":"ch01/p05_pyqgis.html#selecting-features","text":"Selektionen auf Daten bilden eine Auswahl, meist \u00fcber einen Wert oder Ausdruck. Die entsprechenden Elemente werden in QGIS in einer voreingestellten Farbe markiert . Dies selektiert alle Objekte: # Get the active layer (must be a vector layer) >>> layer = iface.activeLayer() >>> layer.selectAll() weitere Selektionsfunktionen: Funktion Beispiel/Erl\u00e4uterung layer.removeSelection() entfernt die Markierung wieder selectByExpression() layer.selectByExpression('\"Name\" like \\'W%\\'', QgsVectorLayer.SetSelection) iface.mapCanvas().setSelectionColor() iface.mapCanvas().setSelectionColor( QColor(\"red\") )","title":"Selecting features"},{"location":"ch01/p05_pyqgis.html#creating-vector-layers","text":"Das Cookbook erw\u00e4hnt zwei unterschiedliche M\u00f6glichkeiten einen Vektorlayer zu erzeugen: QgsVectorFileWriter QgsVectorLayer In diesem Beispiel benutzen wir QgsVectorFileWriter, um den Layer der Ikea-Standorte in einem Geopacke zu speichern: layer = iface.activeLayer() # Write to a GeoPackage (default) error = QgsVectorFileWriter.writeAsVectorFormat(layer, \"c:/path/to/folder/my_data\", \"\") if error[0] == QgsVectorFileWriter.NoError: print(\"success!\") Haben wir die Daten noch nicht als Layer vorliegen, m\u00fcssen wir sie zun\u00e4chst als Features erzeugen, inkl. Attributen und Geometrien. Dieser Vorgang erfolgt in mehreren Schritten: Erzeugen der Attribute/Felder Anlegen einer neuen Vektor-Datei Erzeugung der Feature-Objekte Speichern der Features in der Vektor-Datei from qgis.PyQt.QtCore import QVariant path = \"C:/Pfad/zu/meinem/out_shape.shp\" # define fields for feature attributes. A QgsFields object is needed fields = QgsFields() fields.append(QgsField(\"Id\", QVariant.Int)) fields.append(QgsField(\"Name\", QVariant.String)) # create a writer object writer = QgsVectorFileWriter(path, \"UTF-8\", fields, QgsWkbTypes.Point, driverName=\"ESRI Shapefile\") if writer.hasError() != QgsVectorFileWriter.NoError: print(\"Error when creating shapefile: \", w.errorMessage()) # add a feature fet = QgsFeature() fet.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(10,10))) fet.setAttributes([1, \"beispiel\"]) writer.addFeature(fet) # delete the writer to flush features to disk del writer","title":"Creating Vector-Layers"},{"location":"ch01/p05_pyqgis.html#aufgabe-zum-import-aus-einer-csv-datei","text":"Die Beispieldatei temp_1961-90.csv enth\u00e4lt die durchschnittlichen Temperaturwerte, die an 727 Messstationen aufgezeichnet wurden. Die Temperaturen sind im Monats- und im Jahresmittel angegeben. So sehen die ersten beiden Zeilen der Textdatei 'temp_1961-90.csv' aus: ALIASNAME;H\u00f6he \u00fc NN;Breite;L\u00e4nge;Bundesland;Jan;Feb;Mrz;Apr;Mai;Jun;Jul;Aug;Sep;Okt;Nov;Dez;Jahr AACHEN (WEWA);202;50\u00b047';06\u00b005';Nordrhein-Westfalen;2.4;2.8;5.4;8.4;12.8;15.6;17.3;17.1;14.4;10.8;6.1;3.4;9.7 Wir verwenden Bordmittel f\u00fcr den Import: Datei \u00f6ffnen Feldnamen lesen Qgis-Felder erzeugen Ausgabedatei mit QgsVectorFileWriter anlegen Features zeilenweise lesen, jeweils: Werte als Variablen mit den korrekten Typen anlegen eine Punktgeometrie erzeugen QGIS-Feature erzeugen und in Ausgabe-Datei schreiben # Helper function def toDD(Deg, Min, Sec=0): \"\"\"make decimal from degree, minutes, seconds\"\"\" return float(Deg + Min/60 + Sec/3600) # read csv with open('data/temp_1961-90.csv') as csvfile: header = csvfile.readline().split(';') # Header line # create qgis fields # create outfile with QgsVectorFileWriter for srow in csvfile: row = srow.split(';') name = row[0] H = float(row[1]) # B = toDD(*map(int, row[2].strip(\"'\").split('\u00b0'))) # L = toDD(*map(int, row[3].strip(\"'\").split('\u00b0'))) # https://www.i18nqa.com/debug/utf8-debug.html # row[2].strip(\"'\").split('\\u00c2\\u00b0') => ['49','7'] # map(int, ['49','7']) => [49, 7] # *[49, 7] => 49, 7 B = toDD(*map(int, row[2].strip(\"'\").split('\\u00c2\\u00b0'))) L = toDD(*map(int, row[3].strip(\"'\").split('\\u00c2\\u00b0'))) land = row[4] values = list(map(float, row[5:])) # make a point geometry # build a qgis feature # write to file Hinweis: Das Script benutzt die with-Anweisung: in Python kann ein Code-Block mit with erzeugt werden. Hierbei wird eine Anweisung hinzugef\u00fcgt, die ein Objekt erzeugt, das nur innerhalb des Blocks g\u00fcltig ist und von python am Ende der Verarbeitung automatisch gel\u00f6scht wird. stackoverflow In unserem Fall ist dies die Open-Anweisung, welche ein file object zur\u00fcckgibt. Vorteil: Das file object muss nicht explizit geschlossen werden.","title":"Aufgabe zum Import aus einer CSV-Datei"},{"location":"ch01/p05_pyqgis.html#geometry-handling","text":"Behandelt das Thema zur Umgang mit Geometrien von Vektordaten, ausf\u00fchrlicher als oben im Beispiel der erzeugten Punkte. QGIS benutzt f\u00fcr die Geometrien die Definitionen aus dem Simple-Features-Modell : Schema des Simple-Feature-Modells Behandelt werden Points, Linestrings und Polygons mit Single oder Multipart-Geometrien. Eine abstakte Klasse dazu ist QgsGeometry . Ein Beispiel um Geometrien als Point, LineString und Polygon zu erzeugen: gPnt = QgsGeometry.fromPointXY(QgsPointXY(1,1)) gLine = QgsGeometry.fromPolyline([QgsPoint(1, 1), QgsPoint(2, 2)]) gPolygon = QgsGeometry.fromPolygonXY([[QgsPointXY(1, 1), QgsPointXY(2, 2), QgsPointXY(2, 1)]]) Die Definition eine Geometrietyps wird \u00fcber die Methode wkbType() realisiert. Objekt Typvergleich gPnt.wkbType() # 1 gPnt.wkbType() == QgsWkbTypes.Point gLine.wkbType() # 2 gLine.wkbType() == QgsWkbTypes.LineString gPolygon.wkbType() # 3 gPolygone.wkbType() == QgsWkbTypes.Polygon wkbType steht f\u00fcr Well-Known-Binary-Type und gibt die angegebenen Codes zur\u00fcck. Vorsicht: Diese unterscheiden sich von der Angabe in geometry.type()! Ein Beispiel, um Geometrien als Python-Lists zu erhalten: gPnt.asPoint() # output: <QgsPointXY: POINT(1 1)> gLine.asPolyline() # output: [<QgsPointXY: POINT(1 1)>, <QgsPointXY: POINT(2 2)>] gPolygon.asPolygon() # output: [[<QgsPointXY: POINT(1 1)>, <QgsPointXY: POINT(2 2)>, <QgsPointXY: POINT(2 1)>, <QgsPointXY: POINT(1 1)>]] Hinweis: QgsPointXY ist keine QGIS-Geometrieklasse, sondern ein Hilfsmittel (eine Primitive ), um Geometrien zu erzeugen. Neben QgsPointsXY existiert eine weitere Klasse QgsPoint als abstrakte Geometrie . In diesem Bereich fallen auch QgsLineString und QgsPolygon. Sie k\u00f6nnen ebenfalls den Geometrie-Funktionen fromPolyline bzw. fromPolygon \u00fcbergeben werden. Auch asPolyline() und asPolygon() geben keine QGIS-Geometrien zur\u00fcck, sondern verpacken QgsPointXY-Objekte in python lists. Geometrien nehmen mit steigender Dimension an Komplexit\u00e4t zu. Folgende Abbildung zeigt die unterschiedlichen Definitionen ein Polygons: Polygon und Multipolygon ist ein Polygon, bestehend aus einem Linear Ring, dem sog. Exterior Ring ein Polygon mit einem Loch, also mit einem Exterior Ring und einem Interior Ring ein Multipolygon, bestehend aus zwei Polygonen wie unter 1 beschrieben Ein Multipolygon, bestehend aus zwei Polygonen wie unter 2 beschrieben","title":"Geometry Handling"},{"location":"ch01/p05_pyqgis.html#projections-support","text":"QGIS definiert Projektionen/Koordinatensysteme \u00fcber die Klasse QgsCoordinateReferenceSystem . Die Koordinatensysteme k\u00f6nnen als Code angegeben werden, n\u00e4mlich u.a. als EPSG-Codes, oder als Well-Known-Text, also einem festgelegten Stringformat. Ein Verzeichnis aller Codes finden wir hier crs = QgsCoordinateReferenceSystem(4326, QgsCoordinateReferenceSystem.EpsgCrsId) print(crs.description()) print(crs.toWkt()) Wenn das Koordinatensystem einer Geometrie ge\u00e4ndert werden soll, muss es transformiert werden. QGIS definiert hierf\u00fcr die Klasse QgsCoordinateTransform: crsSrc = QgsCoordinateReferenceSystem(4326) # WGS 84 crsDest = QgsCoordinateReferenceSystem(25832) # ETRS89 / UTM zone 32N xform = QgsCoordinateTransform(crsSrc, crsDest, QgsProject.instance()) pt1 = xform.transform(QgsPointXY(49.756, 6.643)) # Trierer Dom print(\"Transformed point:\", pt1) # inverse transformation: dest -> src pt2 = xform.transform(pt1, QgsCoordinateTransform.ReverseTransform) print(\"Transformed back:\", pt2)","title":"Projections Support"},{"location":"ch01/p05_pyqgis.html#aufgabe-zur-koordinatentransformation","text":"Wir transformieren die Punkte der Temperatur-Messstationen von ihrem Ausgangskoordinatensystem WGS84 in das der UTM-Zone 32. Aufbauend auf den Script-Entwurf oden erg\u00e4nzen wir die notwendigen Schritte: # Helper function def toDD(Deg, Min, Sec=0): \"\"\"make decimal from degree, minutes, seconds\"\"\" return float(Deg + Min/60 + Sec/3600) # read csv with open('data/temp_1961-90.csv') as csvfile: header = csvfile.readline().split(';') # Header line # create qgis fields # prepare coordinate transformation: create crsSrc, crsDest und xform # create outfile with QgsVectorFileWriter # use Parameter srs=crsDest to store crs with the shapefile for srow in csvfile: row = srow.split(';') name = row[0] H = float(row[1]) # B = toDD(*map(int, row[2].strip(\"'\").split('\u00b0'))) # L = toDD(*map(int, row[3].strip(\"'\").split('\u00b0'))) # https://www.i18nqa.com/debug/utf8-debug.html # row[2].strip(\"'\").split('\\u00c2\\u00b0') => ['49','7'] # map(int, ['49','7']) => [49, 7] # *[49, 7] => 49, 7 B = toDD(*map(int, row[2].strip(\"'\").split('\\u00c2\\u00b0'))) L = toDD(*map(int, row[3].strip(\"'\").split('\\u00c2\\u00b0'))) land = row[4] values = list(map(float, row[5:])) # transform with xform into a QgsPointXY # make a point geometry # build a qgis feature # write to file","title":"Aufgabe zur Koordinatentransformation"},{"location":"ch01/receipes.html","text":"Python-Rezepte Rekursion Funktionen, die sich selbst aufrufen Anwendungen: Schleifen, deren Anzahl an Durchl\u00e4ufen unbestimmt, aber nicht gro\u00df ist Funktionen werden auf einem Stack ausgef\u00fchrt, dessen Kapazit\u00e4t ist begrenzt. Standardbeispiel \"Fakult\u00e4t\" Berechnung von 4! 4! = 4 * 3! 3! = 3 * 2! 2! = 2 * 1! (1! = 1) def factorial(n): if n == 1: return 1 else: return n * factorial(n-1) try it Rekursiv durch den Pfad Eine rekursive Funktion zum Durchlaufen einer Verzeichnisstruktur. Die Tiefe des Pfades wird per count angegeben, alle Dateien werden mit print ausgegeben Path-Funktionen aus dem os-Modul: os.path.realpath() gibt den korrekten Pfadnamen zur\u00fcck os.listdir(): alle Dateien und Ordner als Liste os.path.join(): Verzeichnis und Dateinamen korrekt verkn\u00fcpfen import os def pathfind(dir, count): count += 1 for f in os.listdir(dir): f = os.path.join(dir,f) if os.path.isdir(f): pathfind(f, count) else: print count, f return var = os.environ['OSGEO4W_ROOT'] + \"/var\" c = 0 pathfind(os.path.realpath(var), c) Tiefe eines Tuples Wir berechnen die Verschachtelungstiefe eines Tuples: Tupel mit Tiefe 1: (1,2,3) Tupel mit Tiefe 2: ((1,2,3),(3,2,1)) def getDeepness(aList, dim=0): if isinstance(aList, (list, tuple)): if not aList: return dim dim = dim + 1 dim = getDeepness(aList[0], dim) return dim else: if dim == 0: return -1 else: return dim try it Jede Rekursion ist auch mit einer Schleife darstellbar Pfad durchsuchen ohne Rekursion: def pathfindseriell(dir): end = False entries = [] entries = map(lambda p: os.path.join(dir, p), os.listdir(dir)) while (entries): f = entries[0] if os.path.isdir(f): entries.remove(f) entries = map(lambda p: os.path.join(f, p), os.listdir(f)) + entries else: print f entries.remove(f) Dictionaries f\u00fcr komplexe Daten Schl\u00fcssel als Zeiger Eine Menge von Linien, die auf einer separaten Menge von Punkten aufbauen. Topologische Struktur: Jeder Punkt wird nur einmal gespeichert, Anfangs- und Endpunkte der Linien sind die Knoten eines Netzwerks ein Punkt ist ein Element eines Dictionary mit einer ID als Schl\u00fcssel und dem zugrordneten Koordinatenpaar als Tuple eine Linie besteht aus Dictionary-Element mit einer ID und einem Tuple der Punkt-ID's points = {1:(1,3), 2:(3,1), 3:(3,2), 4:(5,2), 5:(7,3), 6:(9,2), 7:(8,6), \\ 8:(3,8), 9:(2,8), 10:(4,5), 11:(1,7), 12:(6,6)} lines = {'a':(1,3), 'b':(2,3), 'c':(3,4,5), 'd':(5,6), 'e':(1,10), \\ 'f':(5,7), 'h':(8,9), 'j':(9,11,10), 'k':(8,10), 'l':(5,12,7)} try it Funktionen f\u00fcr das Netzwerk Eine Funktion zur Darstellung der Linien mit ihren Koordinaten: points = {1:(1,3), 2:(3,1), 3:(3,2), 4:(5,2), 5:(7,3), 6:(9,2), 7:(8,6), \\ 8:(3,8), 9:(2,8), 10:(4,5), 11:(1,7), 12:(6,6)} lines = {'a':(1,3), 'b':(2,3), 'c':(3,4,5), 'd':(5,6), 'e':(1,10), \\ 'f':(5,7), 'h':(8,9), 'j':(9,11,10), 'k':(8,10), 'l':(5,12,7)} def make_line(key): line_str = [] if lines.has_key(key): for pid in lines[key]: if points.has_key(pid): line_str.append(points[pid]) return line_str try it Eine Funktion zur Ermittlung der Knoten aller Linien: def find_nodes(): nodes = {} for key in lines: lin = lines[key] for nd in (lin[0], lin[-1]): if not nodes.has_key(nd): nodes[nd] = [key] else: nodes[nd].append(key) return nodes Ein Graph der Knoten f\u00fcr Routingzwecke def build_graph(nodes): graph = {} for key in nodes: graph[key] = [] for lid in nodes[key]: for nid in (lines[lid][0], lines[lid][-1]): if nid != key: graph[key].append(nid) return graph Pfadsuche zwischen zwei Knoten: Anwendung einer Rekursion! gefunden bei python-course.eu def find_path(start_vertex, end_vertex, graph, path=None): \"\"\" find a path from start_vertex to end_vertex in graph \"\"\" if path == None: path = [] path = path + [start_vertex] if start_vertex == end_vertex: return path if start_vertex not in graph: return None for vertex in graph[start_vertex]: if vertex not in path: extended_path = find_path(vertex, end_vertex, graph, path) if extended_path: return extended_path return None diese Funktion findet nur einen Pfad, der nicht der g\u00fcnstigste sein muss. Der Pfad ist eine Liste der id's seiner Knoten (s.u.). Um zu den Knoten die entsprechenden Linien mit ihren Koordinaten zu finden, greifen wir auf die Struktur der nodes zur\u00fcck. def lin_path(path, nodes): if not path or len(path) < 2: return None linpath = [] for i in range(len(path)-1): l1 = nodes[path[i]] l2 = nodes[path[i+1]] #, network[path[i+2]] lfound = None for l in l1: if l in l2: lfound = l linpath.append(lfound) return linpath die Funktion erzeugt eine Liste mit den Id's der Linen eines Pfades. ## insert date and pathes here nodes = find_nodes() graph = build_graph(nodes) path = find_path(3, 8, graph) print \"PATH:\", lin_path(path, nodes) hier eine Variante f\u00fcr alle m\u00f6glichen Pfade: def find_all_paths(start_vertex, end_vertex, graph, path=[]): \"\"\" find all paths from start_vertex to end_vertex in graph \"\"\" path = path + [start_vertex] if start_vertex == end_vertex: return [path] if start_vertex not in graph: return [] paths = [] for vertex in graph[start_vertex]: if vertex not in path: extended_paths = find_all_paths(vertex, end_vertex, graph, path) for p in extended_paths: paths.append(p) return paths anschlie\u00dfend k\u00f6nnen die Pfade ausgewertet werden, z.B. um die k\u00fcrzeste Strecke zu ermitteln. Darstellung des Netzwerks R\u00fcckgriff auf draw_map aus dem ersten Teil: import draw_map # function definitions... # main nodes = find_nodes() graph = build_graph(nodes) pathes = find_all_paths(3,8,graph) import draw_map map = draw_map.create() for l in lines: lin = make_line(l) draw_map.draw_line(map, lin) draw_map.draw_point(map, points[3]) draw_map.draw_point(map, points[8], \"r^\") for p in pathes: lp = lin_path(p, nodes) for l in lp: draw_map.draw_line(map, make_line(l),\"y--\") draw_map.show_map(map, ((0,0),(10,10)))","title":"Python-Rezepte"},{"location":"ch01/receipes.html#python-rezepte","text":"","title":"Python-Rezepte"},{"location":"ch01/receipes.html#rekursion","text":"Funktionen, die sich selbst aufrufen Anwendungen: Schleifen, deren Anzahl an Durchl\u00e4ufen unbestimmt, aber nicht gro\u00df ist Funktionen werden auf einem Stack ausgef\u00fchrt, dessen Kapazit\u00e4t ist begrenzt.","title":"Rekursion"},{"location":"ch01/receipes.html#standardbeispiel-fakultat","text":"Berechnung von 4! 4! = 4 * 3! 3! = 3 * 2! 2! = 2 * 1! (1! = 1) def factorial(n): if n == 1: return 1 else: return n * factorial(n-1) try it","title":"Standardbeispiel \"Fakult\u00e4t\""},{"location":"ch01/receipes.html#rekursiv-durch-den-pfad","text":"Eine rekursive Funktion zum Durchlaufen einer Verzeichnisstruktur. Die Tiefe des Pfades wird per count angegeben, alle Dateien werden mit print ausgegeben Path-Funktionen aus dem os-Modul: os.path.realpath() gibt den korrekten Pfadnamen zur\u00fcck os.listdir(): alle Dateien und Ordner als Liste os.path.join(): Verzeichnis und Dateinamen korrekt verkn\u00fcpfen import os def pathfind(dir, count): count += 1 for f in os.listdir(dir): f = os.path.join(dir,f) if os.path.isdir(f): pathfind(f, count) else: print count, f return var = os.environ['OSGEO4W_ROOT'] + \"/var\" c = 0 pathfind(os.path.realpath(var), c)","title":"Rekursiv durch den Pfad"},{"location":"ch01/receipes.html#tiefe-eines-tuples","text":"Wir berechnen die Verschachtelungstiefe eines Tuples: Tupel mit Tiefe 1: (1,2,3) Tupel mit Tiefe 2: ((1,2,3),(3,2,1)) def getDeepness(aList, dim=0): if isinstance(aList, (list, tuple)): if not aList: return dim dim = dim + 1 dim = getDeepness(aList[0], dim) return dim else: if dim == 0: return -1 else: return dim try it","title":"Tiefe eines Tuples"},{"location":"ch01/receipes.html#jede-rekursion-ist-auch-mit-einer-schleife-darstellbar","text":"Pfad durchsuchen ohne Rekursion: def pathfindseriell(dir): end = False entries = [] entries = map(lambda p: os.path.join(dir, p), os.listdir(dir)) while (entries): f = entries[0] if os.path.isdir(f): entries.remove(f) entries = map(lambda p: os.path.join(f, p), os.listdir(f)) + entries else: print f entries.remove(f)","title":"Jede Rekursion ist auch mit einer Schleife darstellbar"},{"location":"ch01/receipes.html#dictionaries-fur-komplexe-daten","text":"","title":"Dictionaries f\u00fcr komplexe Daten"},{"location":"ch01/receipes.html#schlussel-als-zeiger","text":"Eine Menge von Linien, die auf einer separaten Menge von Punkten aufbauen. Topologische Struktur: Jeder Punkt wird nur einmal gespeichert, Anfangs- und Endpunkte der Linien sind die Knoten eines Netzwerks ein Punkt ist ein Element eines Dictionary mit einer ID als Schl\u00fcssel und dem zugrordneten Koordinatenpaar als Tuple eine Linie besteht aus Dictionary-Element mit einer ID und einem Tuple der Punkt-ID's points = {1:(1,3), 2:(3,1), 3:(3,2), 4:(5,2), 5:(7,3), 6:(9,2), 7:(8,6), \\ 8:(3,8), 9:(2,8), 10:(4,5), 11:(1,7), 12:(6,6)} lines = {'a':(1,3), 'b':(2,3), 'c':(3,4,5), 'd':(5,6), 'e':(1,10), \\ 'f':(5,7), 'h':(8,9), 'j':(9,11,10), 'k':(8,10), 'l':(5,12,7)} try it","title":"Schl\u00fcssel als Zeiger"},{"location":"ch01/receipes.html#funktionen-fur-das-netzwerk","text":"Eine Funktion zur Darstellung der Linien mit ihren Koordinaten: points = {1:(1,3), 2:(3,1), 3:(3,2), 4:(5,2), 5:(7,3), 6:(9,2), 7:(8,6), \\ 8:(3,8), 9:(2,8), 10:(4,5), 11:(1,7), 12:(6,6)} lines = {'a':(1,3), 'b':(2,3), 'c':(3,4,5), 'd':(5,6), 'e':(1,10), \\ 'f':(5,7), 'h':(8,9), 'j':(9,11,10), 'k':(8,10), 'l':(5,12,7)} def make_line(key): line_str = [] if lines.has_key(key): for pid in lines[key]: if points.has_key(pid): line_str.append(points[pid]) return line_str try it Eine Funktion zur Ermittlung der Knoten aller Linien: def find_nodes(): nodes = {} for key in lines: lin = lines[key] for nd in (lin[0], lin[-1]): if not nodes.has_key(nd): nodes[nd] = [key] else: nodes[nd].append(key) return nodes Ein Graph der Knoten f\u00fcr Routingzwecke def build_graph(nodes): graph = {} for key in nodes: graph[key] = [] for lid in nodes[key]: for nid in (lines[lid][0], lines[lid][-1]): if nid != key: graph[key].append(nid) return graph Pfadsuche zwischen zwei Knoten: Anwendung einer Rekursion! gefunden bei python-course.eu def find_path(start_vertex, end_vertex, graph, path=None): \"\"\" find a path from start_vertex to end_vertex in graph \"\"\" if path == None: path = [] path = path + [start_vertex] if start_vertex == end_vertex: return path if start_vertex not in graph: return None for vertex in graph[start_vertex]: if vertex not in path: extended_path = find_path(vertex, end_vertex, graph, path) if extended_path: return extended_path return None diese Funktion findet nur einen Pfad, der nicht der g\u00fcnstigste sein muss. Der Pfad ist eine Liste der id's seiner Knoten (s.u.). Um zu den Knoten die entsprechenden Linien mit ihren Koordinaten zu finden, greifen wir auf die Struktur der nodes zur\u00fcck. def lin_path(path, nodes): if not path or len(path) < 2: return None linpath = [] for i in range(len(path)-1): l1 = nodes[path[i]] l2 = nodes[path[i+1]] #, network[path[i+2]] lfound = None for l in l1: if l in l2: lfound = l linpath.append(lfound) return linpath die Funktion erzeugt eine Liste mit den Id's der Linen eines Pfades. ## insert date and pathes here nodes = find_nodes() graph = build_graph(nodes) path = find_path(3, 8, graph) print \"PATH:\", lin_path(path, nodes) hier eine Variante f\u00fcr alle m\u00f6glichen Pfade: def find_all_paths(start_vertex, end_vertex, graph, path=[]): \"\"\" find all paths from start_vertex to end_vertex in graph \"\"\" path = path + [start_vertex] if start_vertex == end_vertex: return [path] if start_vertex not in graph: return [] paths = [] for vertex in graph[start_vertex]: if vertex not in path: extended_paths = find_all_paths(vertex, end_vertex, graph, path) for p in extended_paths: paths.append(p) return paths anschlie\u00dfend k\u00f6nnen die Pfade ausgewertet werden, z.B. um die k\u00fcrzeste Strecke zu ermitteln.","title":"Funktionen f\u00fcr das Netzwerk"},{"location":"ch01/receipes.html#darstellung-des-netzwerks","text":"R\u00fcckgriff auf draw_map aus dem ersten Teil: import draw_map # function definitions... # main nodes = find_nodes() graph = build_graph(nodes) pathes = find_all_paths(3,8,graph) import draw_map map = draw_map.create() for l in lines: lin = make_line(l) draw_map.draw_line(map, lin) draw_map.draw_point(map, points[3]) draw_map.draw_point(map, points[8], \"r^\") for p in pathes: lp = lin_path(p, nodes) for l in lp: draw_map.draw_line(map, make_line(l),\"y--\") draw_map.show_map(map, ((0,0),(10,10)))","title":"Darstellung des Netzwerks"},{"location":"ch01/repetitorium.html","text":"Python-Repetitorium Im R\u00fcckgriff auf den ersten Teil, hier eine kleine Zusammenfassung der Inhalte. Klicken Sie Drucken f\u00fcr eine Druckansicht! Datentypen Strings Dokumentation Notation eines Strings word = 'word' sentence = \"This is a sentence.\" paragraph = \"\"\"This is a paragraph. It is made up of multiple lines and sentences.\"\"\" print \"%s\\n%s\\n%s\"%(word, sentence, paragraph) try it Verkettungen von Strings a = \"Hello\" b = \"World\" print a + b + \"!\" print \" \".join((a, b, \"!\")) c = \"!\" print \"%s %s%s L\u00e4nge von a,b:%d,%d\" % (a, b, c, len(a), len(b)) try it Strings f\u00fcr Pfadangaben print \"C:/temp/nix.da\" print 'C:\\\\nowhere' print r'C:\\nowhere' Typ-Umwandlung s = \"5\" i = int(s) print i+1 s = \"5.1\" f = float(s) print f+1 try it Numbers Wir unterscheiden Integer (int) und Float (float) als Datentypen. Dokumentation Standard-Operatoren sind Addition (+), Subtraktion (-), Multiplikation (*) und Division (/) C = 12 K = C+237.15 F = C*1.8 + 32 print C, K, F try it Modul math Standardmodul in Python, mathematische Funktionen, entsprechen dem Standard der Sprache C Dokumentation import math print math.sqrt(5) print \"Euler:\", math.e print \"Pi :\", math.pi try it Umwandlung a = 9 b = 2 print a/b print float(a)/float(b) try it weitere Datentypen Dokumentation Datenstrukturen Listen (list) liste = [1,2,3,4,5] print liste print liste[0] print liste[1] print liste[0:2] print len(liste) print liste.index(4) liste.append(6) # Element anh\u00e4ngen print liste print liste.pop(2) # das zweite Element l\u00f6schen print liste liste = range(10) # eine neue Liste erzeugen print liste try it Umwandlung s = '2546386,000000;5521004,000000;\"Kultur\";\"Burg Ramstein\"' liste = s.split(\";\") print liste, len(liste) try it Tupel (tuple) tuple = ( 'abcd', 786 , 2.23, 'john', 70.2 ) print tuple print tuple[0] try it Dictionarys (dict) dic = {'Name': 'Andreas', 'Hobby': 'Musik', \\ 'Eltern': ['Mama', 'Papa']} # Ausgabe des Werts f\u00fcr 'Name' print dic['Name'] # Ausgabe aller Schl\u00fcssel for key in dic: print key, dic[key] try it Umwandlungen dic = {'Name': 'Andreas', 'Hobby': 'Musik', 'Eltern': ['Mama', 'Papa']} liste = list(dic) print liste, tuple(liste) try it Sprachelemente Operatoren Tutorialspoint if-Anweisungen a=0 b=1 if a == b: b = b+1 elif a < b: a = b else: a = b + 1 print a,b try it \"tern\u00e4rer Operator\": x = 9 y = 7 a = 1 if x > y else -1 print a try it for-Schleife Liste erzeugen und durchlaufen aList = range(10) print aList for e in aList: print e try it Liste mit Z\u00e4hl-Variable durchlaufen alist = [\"banana\", \"orange\", \"ananas\", \"apple\"] for i in range(len(alist)): print i, alist[i] try it Iteration \u00fcberspringen alist = [\"banana\", \"orange\", \"ananas\", \"apple\"] skip = \"ananas\" for i in range(len(alist)): if alist[i] == skip: continue print i, alist[i] try it for-Schleife abbrechen alist = [\"banana\", \"orange\", \"ananas\", \"apple\"] search = \"orange\" for i in range(len(alist)): if alist[i] == search: print i, alist[i] break try it Anwendung f\u00fcr Summe myList = [0, 90, 140, 110, 0, 0, 170, 150, 160, 130] # Summe berechnen total = 0 for value in myList: total += value try it while-Schleife Liste r\u00fcckw\u00e4rts l\u00f6schen myList = [0, 90, 140, 110, 0, 0, 170, 150, 160, 130] while len(myList) > 1: print myList.pop() try it Endlosschleife verlassen while True: num = raw_input(\"Enter a number or q to quit :\") if num == \"q\": print \"Good bye\" break print \"You entered: \", num try it Funktionen Tutorialspoint Funktionsdefinition und -aufruf def gC2gK(c): \"\"\"berechnet Grad in Kelvin aus Grad Celsius\"\"\" return c+237.15 gC = 18.4 print \"%s degC = %s degK\"%(gC, gC2gK(gC)) try it Lamda g = lambda x: x**2 # ** exponential print g(8) try it Mapping Liste der Quadratzahlen f\u00fcr die Werte 0-9 import math ql = map(lambda x: x**2, range(10)) rl = map(math.sqrt,ql) print rl print ql try it Zip Dokumentation rl = range(10) ql = map(lambda x: x**2, rl) print zip(rl,ql) # oder print zip(rl, map(lambda x: x**2, rl)) try it weitere Konstrukte list-(dict-)Comprehensions alle geraden Zahlen einer Liste lq = [x**2 for x in range(10)] print lq even = [e for e in lq if e%2 == 0] print even # oder verschachtelt: even = [e for e in [x**2 for x in range(10)] if e%2 == 0] print even try it Quadratzahlen als dict rl = range(10) qd = {k:v for (k, v) in zip(rl, [q*q for q in rl]) } print qd[4] try it Python-Module sys Python-Kurs.eu import sys for arg in sys.argv: print arg os import os import sys for env in os.environ: print env, os.environ[env] print \"--- Python befindet sich hier:\" print os.environ['PYTHONHOME'] print \"--- Running on\", if os.sep == \"/\": print \"Unix!\" else: print \"Windows!\" print \"--- Programmverzeichnis:\" print os.path.dirname(sys.argv[0]) random import random for i in range(100): print i, random.randint(0,255) time import time import math import random startt = time.time() ll = [] for i in range(10000): ll.append( (i, math.sqrt(random.randint(0,255))) ) ll.sort(lambda a,b: 1 if a[1] > b[1] else -1) print \"done\", time.time() - startt weitere Standardmodule Dokumentation Geodaten Vektordaten Punkte, deren horizontaler und vertikaler Abstand sowie die Luftliniendistanz import math p1 = (7.5, 4.3) p2 = (4.7, 5.4) dxy = (p1[0] - p2[0], p1[1] - p2[1]) print \"Distanz von p1 %s und p2 %s: %s\"%(p1, p2, math.sqrt(dxy[0]**2 + dxy[1]**2)) try it Strecke, Segment, Kante: 2 Punkte p1 = (7.5, 4.3) p2 = (4.7, 5.4) edge = (p1,p2) try it Rechtecke, MUR: 2 Punkte p1 = (7.5, 4.3) p2 = (4.7, 5.4) # sortiere nach links unten und rechts oben def rechteck(p1, p2): return ( ( min(p1[0],p2[0]), min(p1[1],p2[1]) ), ( max(p1[0],p2[0]), max(p1[1],p2[1]) ) ) r1 = rechteck(p1, p2) print r1 try it Linien: beliege Anzahl von Punkten lin = ((7.5, 4.3), (4.7, 5.4), (2.5, 2.1), (5.9, 1.1)) print lin try it Polygone: Parts und Rings # ring rng = ((7.5, 4.3), (4.7, 5.4), (2.5, 2.1), (5.9, 1.1), (3.3,1.5)) def pr_closed(pr): # test auf geschlossenen polygonalen ring if pr[0][0] == pr[-1][0] and pr[0][1] == pr[-1][1]: return pr else: pr = list(pr) pr.append(pr[0]) return pr pol = pr_closed(rng) print pol try it Test und Korrektur der Drehrichtung: \"signed area\" nach Gau\u00df def pr_signed_area(pr): xs, ys = map(list, zip(*pr)) xs.append(xs[1]) ys.append(ys[1]) return sum(xs[i]*(ys[i+1]-ys[i-1]) for i in range(1, len(pr)))/2.0 def pr_reverse(pr): temp = list(pr) temp.reverse() return tuple(temp) try it Linien und Ringe umformen: def pr_arrangexy(ls): return zip(*ls) l = ((1.2,2.3),(2.1,3.2),(3.1,1.3)) xl, yl = pr_arrangexy(l) print \"x:\",xl print \"y:\",yl try it Mehrere Ringe: Polygone mit L\u00f6chern ein erster Ring bildet den \u00e4u\u00dferen Rand weitere Ringe bilden die L\u00f6chern innere Ringe haben umgekehrte Drehrichtung diese werden auch einfache Polygone genannt Polygone mit Ringen und unterschiedlichen Drehrichtungen Multi-Polygone: - erlauben mehrere einfache Polygone Rasterdaten Raster 3x3, Integer R = ( (7, 9, 6), (6, 8, 9), (6, 7, 8) ) print \"Zeilen:\", len(R) print \"Spalten:\", len(R[0]) try it Raster mit mehreren B\u00e4ndern: R = ( ( (r,g,b), (r,g,b), (r,g,b) ), ( (r,g,b), (r,g,b), (r,g,b) ), ( (r,g,b), (r,g,b), (r,g,b) ) ) Numpy Rasterdarstellung und Zugriff import numpy r = numpy.array([[7, 9, 6], [6, 8, 9], [6, 7, 8]]) # Indexing print \"r[0]\\n\", r[0] print \"r[(0,1)]\\n\", r[(0,1)] # entspricht print \"r[0:2]\\n\", r[0:2] # Pixel print \"r[0,1]\\n\", r[0,1] try it Methoden (skulpt kennt nicht alle...): import numpy a = numpy.array([[7, 9, 6], [6, 8, 9], [6, 7, 8]]) # Angaben: print \"Shape\", a.shape print \"dtype\", a.dtype print \"Size\", a.size print \"len\", len(a) # print \"min\", a.min() print \"sum\", a.sum() # print \"max\", a.max() # print \"sum, axis=1\", a.sum(axis=1) # print \"sum, axis=0\", a.sum(axis=0) try it Operatoren (skulpt kennt nicht alle...) import numpy a = numpy.array([[7, 9, 6], [6, 8, 9], [6, 7, 8]]) print a/2 print a > 7 try it Georeferenz externe Vektordaten als Metadaten (linke untere/obere Ecke) Pixelgr\u00f6\u00dfe Anzahl Zeilen und Spalten NODATA-Wert Beispiel: ncols 129 nrows 150 xllcorner 2550946.798032000200 yllcorner 5506994.751716000000 cellsize 46.602676800001 NODATA_value -9999","title":"Python-Repetitorium"},{"location":"ch01/repetitorium.html#python-repetitorium","text":"Im R\u00fcckgriff auf den ersten Teil, hier eine kleine Zusammenfassung der Inhalte. Klicken Sie Drucken f\u00fcr eine Druckansicht!","title":"Python-Repetitorium"},{"location":"ch01/repetitorium.html#datentypen","text":"","title":"Datentypen"},{"location":"ch01/repetitorium.html#strings","text":"Dokumentation","title":"Strings"},{"location":"ch01/repetitorium.html#notation-eines-strings","text":"word = 'word' sentence = \"This is a sentence.\" paragraph = \"\"\"This is a paragraph. It is made up of multiple lines and sentences.\"\"\" print \"%s\\n%s\\n%s\"%(word, sentence, paragraph) try it","title":"Notation eines Strings"},{"location":"ch01/repetitorium.html#verkettungen-von-strings","text":"a = \"Hello\" b = \"World\" print a + b + \"!\" print \" \".join((a, b, \"!\")) c = \"!\" print \"%s %s%s L\u00e4nge von a,b:%d,%d\" % (a, b, c, len(a), len(b)) try it","title":"Verkettungen von Strings"},{"location":"ch01/repetitorium.html#strings-fur-pfadangaben","text":"print \"C:/temp/nix.da\" print 'C:\\\\nowhere' print r'C:\\nowhere'","title":"Strings f\u00fcr Pfadangaben"},{"location":"ch01/repetitorium.html#typ-umwandlung","text":"s = \"5\" i = int(s) print i+1 s = \"5.1\" f = float(s) print f+1 try it","title":"Typ-Umwandlung"},{"location":"ch01/repetitorium.html#numbers","text":"Wir unterscheiden Integer (int) und Float (float) als Datentypen. Dokumentation Standard-Operatoren sind Addition (+), Subtraktion (-), Multiplikation (*) und Division (/) C = 12 K = C+237.15 F = C*1.8 + 32 print C, K, F try it","title":"Numbers"},{"location":"ch01/repetitorium.html#modul-math","text":"Standardmodul in Python, mathematische Funktionen, entsprechen dem Standard der Sprache C Dokumentation import math print math.sqrt(5) print \"Euler:\", math.e print \"Pi :\", math.pi try it","title":"Modul math"},{"location":"ch01/repetitorium.html#umwandlung","text":"a = 9 b = 2 print a/b print float(a)/float(b) try it","title":"Umwandlung"},{"location":"ch01/repetitorium.html#weitere-datentypen","text":"Dokumentation","title":"weitere Datentypen"},{"location":"ch01/repetitorium.html#datenstrukturen","text":"","title":"Datenstrukturen"},{"location":"ch01/repetitorium.html#listen-list","text":"liste = [1,2,3,4,5] print liste print liste[0] print liste[1] print liste[0:2] print len(liste) print liste.index(4) liste.append(6) # Element anh\u00e4ngen print liste print liste.pop(2) # das zweite Element l\u00f6schen print liste liste = range(10) # eine neue Liste erzeugen print liste try it Umwandlung s = '2546386,000000;5521004,000000;\"Kultur\";\"Burg Ramstein\"' liste = s.split(\";\") print liste, len(liste) try it","title":"Listen (list)"},{"location":"ch01/repetitorium.html#tupel-tuple","text":"tuple = ( 'abcd', 786 , 2.23, 'john', 70.2 ) print tuple print tuple[0] try it","title":"Tupel (tuple)"},{"location":"ch01/repetitorium.html#dictionarys-dict","text":"dic = {'Name': 'Andreas', 'Hobby': 'Musik', \\ 'Eltern': ['Mama', 'Papa']} # Ausgabe des Werts f\u00fcr 'Name' print dic['Name'] # Ausgabe aller Schl\u00fcssel for key in dic: print key, dic[key] try it","title":"Dictionarys (dict)"},{"location":"ch01/repetitorium.html#umwandlungen","text":"dic = {'Name': 'Andreas', 'Hobby': 'Musik', 'Eltern': ['Mama', 'Papa']} liste = list(dic) print liste, tuple(liste) try it","title":"Umwandlungen"},{"location":"ch01/repetitorium.html#sprachelemente","text":"","title":"Sprachelemente"},{"location":"ch01/repetitorium.html#operatoren","text":"Tutorialspoint","title":"Operatoren"},{"location":"ch01/repetitorium.html#if-anweisungen","text":"a=0 b=1 if a == b: b = b+1 elif a < b: a = b else: a = b + 1 print a,b try it \"tern\u00e4rer Operator\": x = 9 y = 7 a = 1 if x > y else -1 print a try it","title":"if-Anweisungen"},{"location":"ch01/repetitorium.html#for-schleife","text":"","title":"for-Schleife"},{"location":"ch01/repetitorium.html#liste-erzeugen-und-durchlaufen","text":"aList = range(10) print aList for e in aList: print e try it","title":"Liste erzeugen und durchlaufen"},{"location":"ch01/repetitorium.html#liste-mit-zahl-variable-durchlaufen","text":"alist = [\"banana\", \"orange\", \"ananas\", \"apple\"] for i in range(len(alist)): print i, alist[i] try it","title":"Liste mit Z\u00e4hl-Variable durchlaufen"},{"location":"ch01/repetitorium.html#iteration-uberspringen","text":"alist = [\"banana\", \"orange\", \"ananas\", \"apple\"] skip = \"ananas\" for i in range(len(alist)): if alist[i] == skip: continue print i, alist[i] try it","title":"Iteration \u00fcberspringen"},{"location":"ch01/repetitorium.html#for-schleife-abbrechen","text":"alist = [\"banana\", \"orange\", \"ananas\", \"apple\"] search = \"orange\" for i in range(len(alist)): if alist[i] == search: print i, alist[i] break try it","title":"for-Schleife abbrechen"},{"location":"ch01/repetitorium.html#anwendung-fur-summe","text":"myList = [0, 90, 140, 110, 0, 0, 170, 150, 160, 130] # Summe berechnen total = 0 for value in myList: total += value try it","title":"Anwendung f\u00fcr Summe"},{"location":"ch01/repetitorium.html#while-schleife","text":"Liste r\u00fcckw\u00e4rts l\u00f6schen myList = [0, 90, 140, 110, 0, 0, 170, 150, 160, 130] while len(myList) > 1: print myList.pop() try it Endlosschleife verlassen while True: num = raw_input(\"Enter a number or q to quit :\") if num == \"q\": print \"Good bye\" break print \"You entered: \", num try it","title":"while-Schleife"},{"location":"ch01/repetitorium.html#funktionen","text":"Tutorialspoint","title":"Funktionen"},{"location":"ch01/repetitorium.html#funktionsdefinition-und-aufruf","text":"def gC2gK(c): \"\"\"berechnet Grad in Kelvin aus Grad Celsius\"\"\" return c+237.15 gC = 18.4 print \"%s degC = %s degK\"%(gC, gC2gK(gC)) try it","title":"Funktionsdefinition und -aufruf"},{"location":"ch01/repetitorium.html#lamda","text":"g = lambda x: x**2 # ** exponential print g(8) try it","title":"Lamda"},{"location":"ch01/repetitorium.html#mapping","text":"Liste der Quadratzahlen f\u00fcr die Werte 0-9 import math ql = map(lambda x: x**2, range(10)) rl = map(math.sqrt,ql) print rl print ql try it","title":"Mapping"},{"location":"ch01/repetitorium.html#zip","text":"Dokumentation rl = range(10) ql = map(lambda x: x**2, rl) print zip(rl,ql) # oder print zip(rl, map(lambda x: x**2, rl)) try it","title":"Zip"},{"location":"ch01/repetitorium.html#weitere-konstrukte","text":"","title":"weitere Konstrukte"},{"location":"ch01/repetitorium.html#list-dict-comprehensions","text":"alle geraden Zahlen einer Liste lq = [x**2 for x in range(10)] print lq even = [e for e in lq if e%2 == 0] print even # oder verschachtelt: even = [e for e in [x**2 for x in range(10)] if e%2 == 0] print even try it Quadratzahlen als dict rl = range(10) qd = {k:v for (k, v) in zip(rl, [q*q for q in rl]) } print qd[4] try it","title":"list-(dict-)Comprehensions"},{"location":"ch01/repetitorium.html#python-module","text":"","title":"Python-Module"},{"location":"ch01/repetitorium.html#sys","text":"Python-Kurs.eu import sys for arg in sys.argv: print arg","title":"sys"},{"location":"ch01/repetitorium.html#os","text":"import os import sys for env in os.environ: print env, os.environ[env] print \"--- Python befindet sich hier:\" print os.environ['PYTHONHOME'] print \"--- Running on\", if os.sep == \"/\": print \"Unix!\" else: print \"Windows!\" print \"--- Programmverzeichnis:\" print os.path.dirname(sys.argv[0])","title":"os"},{"location":"ch01/repetitorium.html#random","text":"import random for i in range(100): print i, random.randint(0,255)","title":"random"},{"location":"ch01/repetitorium.html#time","text":"import time import math import random startt = time.time() ll = [] for i in range(10000): ll.append( (i, math.sqrt(random.randint(0,255))) ) ll.sort(lambda a,b: 1 if a[1] > b[1] else -1) print \"done\", time.time() - startt","title":"time"},{"location":"ch01/repetitorium.html#weitere-standardmodule","text":"Dokumentation","title":"weitere Standardmodule"},{"location":"ch01/repetitorium.html#geodaten","text":"","title":"Geodaten"},{"location":"ch01/repetitorium.html#vektordaten","text":"Punkte, deren horizontaler und vertikaler Abstand sowie die Luftliniendistanz import math p1 = (7.5, 4.3) p2 = (4.7, 5.4) dxy = (p1[0] - p2[0], p1[1] - p2[1]) print \"Distanz von p1 %s und p2 %s: %s\"%(p1, p2, math.sqrt(dxy[0]**2 + dxy[1]**2)) try it Strecke, Segment, Kante: 2 Punkte p1 = (7.5, 4.3) p2 = (4.7, 5.4) edge = (p1,p2) try it Rechtecke, MUR: 2 Punkte p1 = (7.5, 4.3) p2 = (4.7, 5.4) # sortiere nach links unten und rechts oben def rechteck(p1, p2): return ( ( min(p1[0],p2[0]), min(p1[1],p2[1]) ), ( max(p1[0],p2[0]), max(p1[1],p2[1]) ) ) r1 = rechteck(p1, p2) print r1 try it Linien: beliege Anzahl von Punkten lin = ((7.5, 4.3), (4.7, 5.4), (2.5, 2.1), (5.9, 1.1)) print lin try it Polygone: Parts und Rings # ring rng = ((7.5, 4.3), (4.7, 5.4), (2.5, 2.1), (5.9, 1.1), (3.3,1.5)) def pr_closed(pr): # test auf geschlossenen polygonalen ring if pr[0][0] == pr[-1][0] and pr[0][1] == pr[-1][1]: return pr else: pr = list(pr) pr.append(pr[0]) return pr pol = pr_closed(rng) print pol try it Test und Korrektur der Drehrichtung: \"signed area\" nach Gau\u00df def pr_signed_area(pr): xs, ys = map(list, zip(*pr)) xs.append(xs[1]) ys.append(ys[1]) return sum(xs[i]*(ys[i+1]-ys[i-1]) for i in range(1, len(pr)))/2.0 def pr_reverse(pr): temp = list(pr) temp.reverse() return tuple(temp) try it Linien und Ringe umformen: def pr_arrangexy(ls): return zip(*ls) l = ((1.2,2.3),(2.1,3.2),(3.1,1.3)) xl, yl = pr_arrangexy(l) print \"x:\",xl print \"y:\",yl try it Mehrere Ringe: Polygone mit L\u00f6chern ein erster Ring bildet den \u00e4u\u00dferen Rand weitere Ringe bilden die L\u00f6chern innere Ringe haben umgekehrte Drehrichtung diese werden auch einfache Polygone genannt Polygone mit Ringen und unterschiedlichen Drehrichtungen Multi-Polygone: - erlauben mehrere einfache Polygone","title":"Vektordaten"},{"location":"ch01/repetitorium.html#rasterdaten","text":"Raster 3x3, Integer R = ( (7, 9, 6), (6, 8, 9), (6, 7, 8) ) print \"Zeilen:\", len(R) print \"Spalten:\", len(R[0]) try it Raster mit mehreren B\u00e4ndern: R = ( ( (r,g,b), (r,g,b), (r,g,b) ), ( (r,g,b), (r,g,b), (r,g,b) ), ( (r,g,b), (r,g,b), (r,g,b) ) )","title":"Rasterdaten"},{"location":"ch01/repetitorium.html#numpy","text":"Rasterdarstellung und Zugriff import numpy r = numpy.array([[7, 9, 6], [6, 8, 9], [6, 7, 8]]) # Indexing print \"r[0]\\n\", r[0] print \"r[(0,1)]\\n\", r[(0,1)] # entspricht print \"r[0:2]\\n\", r[0:2] # Pixel print \"r[0,1]\\n\", r[0,1] try it Methoden (skulpt kennt nicht alle...): import numpy a = numpy.array([[7, 9, 6], [6, 8, 9], [6, 7, 8]]) # Angaben: print \"Shape\", a.shape print \"dtype\", a.dtype print \"Size\", a.size print \"len\", len(a) # print \"min\", a.min() print \"sum\", a.sum() # print \"max\", a.max() # print \"sum, axis=1\", a.sum(axis=1) # print \"sum, axis=0\", a.sum(axis=0) try it Operatoren (skulpt kennt nicht alle...) import numpy a = numpy.array([[7, 9, 6], [6, 8, 9], [6, 7, 8]]) print a/2 print a > 7 try it","title":"Numpy"},{"location":"ch01/repetitorium.html#georeferenz","text":"externe Vektordaten als Metadaten (linke untere/obere Ecke) Pixelgr\u00f6\u00dfe Anzahl Zeilen und Spalten NODATA-Wert Beispiel: ncols 129 nrows 150 xllcorner 2550946.798032000200 yllcorner 5506994.751716000000 cellsize 46.602676800001 NODATA_value -9999","title":"Georeferenz"},{"location":"ch02/designer.html","text":"Qt-Designer: der Qt-Editor Qt-Designer erlaubt die graphische Gestaltung einer Benutzeroberfl\u00e4che Urspr\u00fcnglich f\u00fcr C++-Programmierer entwickelt, speichert eine xml-Datei Hauptfenster des QtDesigners mit Liste der Widgets (links), einem Dialogentwurf (mitte) und den Widgeteinstellungen (rechts) F\u00fcr PyQt muss die XML-Datei in Python-Code umgewandelt werden (Nicht vergessen, py3_env und qt5_env auszuf\u00fchren!) pyuic5 name.ui -o name.py Dies erzeugt aus der Designer-Datei (.ui) eine Python-Datei (.py) Es gibt auch eine Methode, die ui-Datei direkt in Python \"aufzurufen\", dazu sp\u00e4ter mehr im Themenbereich QGIS-Plugins. Werden \"ressources\" eingebunden, m\u00fcssen diese auch \u00fcbersetzt werden: pyrcc5 ressources.qrc \u2013o ressources.py Ressources werden sp\u00e4ter behandelt, sie beinhalten z.B. eingebundene Bilder f\u00fcr Icons etc. rechte Seitenleiste mit Widget-Einstellungen Aufbau einer Python-QtDesigner Anwendung die \u00fcbersetzten Pythonscripte aus den ui- und qrc-Dateien bleiben als Module unver\u00e4ndert in einem weiteren Modul importieren wir diese und erstellen eine neue class, die von der Klasse aus dem Designer abgeleitet wird. Beispiel: hei\u00dft die Klasse in der ui-Datei z.B. DataTable, erstellen wir in einem neuen Modul die Klassen MyDataTable: class MyDataTable(DataTable): In dieser neuen Klasse k\u00f6nnen wir dann die Funktionalit\u00e4t und Interaktivit\u00e4t unterbringen, um die Oberfl\u00e4che (oder das Widget) anzuzeigen. Man kann dann noch weiter gehen und f\u00fcr das eigentliche Qt-Programm noch ein weiteres Modul anlegen, sodass die Klassen auch in anderen Programmen verwendet werden k\u00f6nnen. Eine kurze Einf\u00fchrung in den Prozess der GUI-Erstellung mit PyQt und QtDesigner finder z.B. hier Der aufgef\u00fchrte Quellcode stammt aus dieser Quelle hier . Anzeige des Dialogs aus dem Tutorial von Nikola Kovacevic Dieser Code basiert noch auf python2 mit pyqt4 und ist nicht ohne weiteres lauff\u00e4hig... # -*- coding: utf-8 -*- # Form implementation generated from reading ui file 'design.ui' # # Created: Wed May 27 16:39:17 2015 # by: PyQt4 UI code generator 4.11.3 # # WARNING! All changes made in this file will be lost! from PyQt4 import QtCore, QtGui try: _fromUtf8 = QtCore.QString.fromUtf8 except AttributeError: def _fromUtf8(s): return s try: _encoding = QtGui.QApplication.UnicodeUTF8 def _translate(context, text, disambig): return QtGui.QApplication.translate(context, text, disambig, _encoding) except AttributeError: def _translate(context, text, disambig): return QtGui.QApplication.translate(context, text, disambig) class Ui_MainWindow(object): def setupUi(self, MainWindow): MainWindow.setObjectName(_fromUtf8(\"MainWindow\")) MainWindow.resize(240, 345) self.centralwidget = QtGui.QWidget(MainWindow) self.centralwidget.setObjectName(_fromUtf8(\"centralwidget\")) self.verticalLayout = QtGui.QVBoxLayout(self.centralwidget) self.verticalLayout.setObjectName(_fromUtf8(\"verticalLayout\")) self.listWidget = QtGui.QListWidget(self.centralwidget) self.listWidget.setObjectName(_fromUtf8(\"listWidget\")) self.verticalLayout.addWidget(self.listWidget) self.btnBrowse = QtGui.QPushButton(self.centralwidget) self.btnBrowse.setObjectName(_fromUtf8(\"btnBrowse\")) self.verticalLayout.addWidget(self.btnBrowse) MainWindow.setCentralWidget(self.centralwidget) self.retranslateUi(MainWindow) QtCore.QMetaObject.connectSlotsByName(MainWindow) def retranslateUi(self, MainWindow): MainWindow.setWindowTitle(_translate(\"MainWindow\", \"MainWindow\", None)) self.btnBrowse.setText(_translate(\"MainWindow\", \"Pick a folder\", None)) download Aus der ui-Datei erzeugter Python-Code, er wurde demnach schon \u00fcbersetzt! Die Klassen f\u00fcr eine GUI enthalten den Code mit den Widgets und einer Funktion retranslateUi, womit eine Internationalierung mit mehreren Sprachen erreicht werden kann (In diesem Falle ungenutzt). Die zugeh\u00f6riger ui-Datei f\u00fcr den QtDesigner: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <ui version=\"4.0\"> <class>MainWindow</class> <widget class=\"QMainWindow\" name=\"MainWindow\"> <property name=\"geometry\"> <rect> <x>0</x> <y>0</y> <width>240</width> <height>345</height> </rect> </property> <property name=\"windowTitle\"> <string>MainWindow</string> </property> <widget class=\"QWidget\" name=\"centralwidget\"> <layout class=\"QVBoxLayout\" name=\"verticalLayout\"> <item> <widget class=\"QListWidget\" name=\"listWidget\"/> </item> <item> <widget class=\"QPushButton\" name=\"btnBrowse\"> <property name=\"text\"> <string>Pick a folder</string> </property> </widget> </item> </layout> </widget> </widget> <resources/> <connections/> </ui> download Das eigentliche Hauptprogramm: from PyQt4 import QtGui # Import the PyQt4 module we'll need import sys # We need sys so that we can pass argv to QApplication import design # This file holds our MainWindow and all design related things # it also keeps events etc that we defined in Qt Designer import os # For listing directory methods class ExampleApp(QtGui.QMainWindow, design.Ui_MainWindow): def __init__(self): # Explaining super is out of the scope of this article # So please google it if you're not familar with it # Simple reason why we use it here is that it allows us to # access variables, methods etc in the design.py file super(self.__class__, self).__init__() self.setupUi(self) # This is defined in design.py file automatically # It sets up layout and widgets that are defined self.btnBrowse.clicked.connect(self.browse_folder) # When the button is pressed # Execute browse_folder function def browse_folder(self): self.listWidget.clear() # In case there are any existing elements in the list directory = QtGui.QFileDialog.getExistingDirectory(self, \"Pick a folder\") # execute getExistingDirectory dialog and set the directory variable to be equal # to the user selected directory if directory: # if user didn't pick a directory don't continue for file_name in os.listdir(directory): # for all files, if any, in the directory self.listWidget.addItem(file_name) # add file to the listWidget def main(): app = QtGui.QApplication(sys.argv) # A new instance of QApplication form = ExampleApp() # We set the form to be our ExampleApp (design) form.show() # Show the form app.exec_() # and execute the app if __name__ == '__main__': # if we're running file directly and not importing it main() # run the main function download Hier sehen wir die objektorientierte Umsetzung mit der eigenen Klasse ExampleApp , die den funktionalen Teil der GUI festlegt. In main() finden wir die \u00fcbliche Objekterzeugung, hier form (Instanz von ExampelApp) und den Aufruf des Event-Loops der app (Instanz von QApplication) als app.exec_() .","title":"Qt-Designer: der Qt-Editor"},{"location":"ch02/designer.html#qt-designer-der-qt-editor","text":"Qt-Designer erlaubt die graphische Gestaltung einer Benutzeroberfl\u00e4che Urspr\u00fcnglich f\u00fcr C++-Programmierer entwickelt, speichert eine xml-Datei Hauptfenster des QtDesigners mit Liste der Widgets (links), einem Dialogentwurf (mitte) und den Widgeteinstellungen (rechts) F\u00fcr PyQt muss die XML-Datei in Python-Code umgewandelt werden (Nicht vergessen, py3_env und qt5_env auszuf\u00fchren!) pyuic5 name.ui -o name.py Dies erzeugt aus der Designer-Datei (.ui) eine Python-Datei (.py) Es gibt auch eine Methode, die ui-Datei direkt in Python \"aufzurufen\", dazu sp\u00e4ter mehr im Themenbereich QGIS-Plugins. Werden \"ressources\" eingebunden, m\u00fcssen diese auch \u00fcbersetzt werden: pyrcc5 ressources.qrc \u2013o ressources.py Ressources werden sp\u00e4ter behandelt, sie beinhalten z.B. eingebundene Bilder f\u00fcr Icons etc. rechte Seitenleiste mit Widget-Einstellungen","title":"Qt-Designer: der Qt-Editor"},{"location":"ch02/designer.html#aufbau-einer-python-qtdesigner-anwendung","text":"die \u00fcbersetzten Pythonscripte aus den ui- und qrc-Dateien bleiben als Module unver\u00e4ndert in einem weiteren Modul importieren wir diese und erstellen eine neue class, die von der Klasse aus dem Designer abgeleitet wird. Beispiel: hei\u00dft die Klasse in der ui-Datei z.B. DataTable, erstellen wir in einem neuen Modul die Klassen MyDataTable: class MyDataTable(DataTable): In dieser neuen Klasse k\u00f6nnen wir dann die Funktionalit\u00e4t und Interaktivit\u00e4t unterbringen, um die Oberfl\u00e4che (oder das Widget) anzuzeigen. Man kann dann noch weiter gehen und f\u00fcr das eigentliche Qt-Programm noch ein weiteres Modul anlegen, sodass die Klassen auch in anderen Programmen verwendet werden k\u00f6nnen. Eine kurze Einf\u00fchrung in den Prozess der GUI-Erstellung mit PyQt und QtDesigner finder z.B. hier Der aufgef\u00fchrte Quellcode stammt aus dieser Quelle hier . Anzeige des Dialogs aus dem Tutorial von Nikola Kovacevic Dieser Code basiert noch auf python2 mit pyqt4 und ist nicht ohne weiteres lauff\u00e4hig... # -*- coding: utf-8 -*- # Form implementation generated from reading ui file 'design.ui' # # Created: Wed May 27 16:39:17 2015 # by: PyQt4 UI code generator 4.11.3 # # WARNING! All changes made in this file will be lost! from PyQt4 import QtCore, QtGui try: _fromUtf8 = QtCore.QString.fromUtf8 except AttributeError: def _fromUtf8(s): return s try: _encoding = QtGui.QApplication.UnicodeUTF8 def _translate(context, text, disambig): return QtGui.QApplication.translate(context, text, disambig, _encoding) except AttributeError: def _translate(context, text, disambig): return QtGui.QApplication.translate(context, text, disambig) class Ui_MainWindow(object): def setupUi(self, MainWindow): MainWindow.setObjectName(_fromUtf8(\"MainWindow\")) MainWindow.resize(240, 345) self.centralwidget = QtGui.QWidget(MainWindow) self.centralwidget.setObjectName(_fromUtf8(\"centralwidget\")) self.verticalLayout = QtGui.QVBoxLayout(self.centralwidget) self.verticalLayout.setObjectName(_fromUtf8(\"verticalLayout\")) self.listWidget = QtGui.QListWidget(self.centralwidget) self.listWidget.setObjectName(_fromUtf8(\"listWidget\")) self.verticalLayout.addWidget(self.listWidget) self.btnBrowse = QtGui.QPushButton(self.centralwidget) self.btnBrowse.setObjectName(_fromUtf8(\"btnBrowse\")) self.verticalLayout.addWidget(self.btnBrowse) MainWindow.setCentralWidget(self.centralwidget) self.retranslateUi(MainWindow) QtCore.QMetaObject.connectSlotsByName(MainWindow) def retranslateUi(self, MainWindow): MainWindow.setWindowTitle(_translate(\"MainWindow\", \"MainWindow\", None)) self.btnBrowse.setText(_translate(\"MainWindow\", \"Pick a folder\", None)) download Aus der ui-Datei erzeugter Python-Code, er wurde demnach schon \u00fcbersetzt! Die Klassen f\u00fcr eine GUI enthalten den Code mit den Widgets und einer Funktion retranslateUi, womit eine Internationalierung mit mehreren Sprachen erreicht werden kann (In diesem Falle ungenutzt). Die zugeh\u00f6riger ui-Datei f\u00fcr den QtDesigner: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <ui version=\"4.0\"> <class>MainWindow</class> <widget class=\"QMainWindow\" name=\"MainWindow\"> <property name=\"geometry\"> <rect> <x>0</x> <y>0</y> <width>240</width> <height>345</height> </rect> </property> <property name=\"windowTitle\"> <string>MainWindow</string> </property> <widget class=\"QWidget\" name=\"centralwidget\"> <layout class=\"QVBoxLayout\" name=\"verticalLayout\"> <item> <widget class=\"QListWidget\" name=\"listWidget\"/> </item> <item> <widget class=\"QPushButton\" name=\"btnBrowse\"> <property name=\"text\"> <string>Pick a folder</string> </property> </widget> </item> </layout> </widget> </widget> <resources/> <connections/> </ui> download Das eigentliche Hauptprogramm: from PyQt4 import QtGui # Import the PyQt4 module we'll need import sys # We need sys so that we can pass argv to QApplication import design # This file holds our MainWindow and all design related things # it also keeps events etc that we defined in Qt Designer import os # For listing directory methods class ExampleApp(QtGui.QMainWindow, design.Ui_MainWindow): def __init__(self): # Explaining super is out of the scope of this article # So please google it if you're not familar with it # Simple reason why we use it here is that it allows us to # access variables, methods etc in the design.py file super(self.__class__, self).__init__() self.setupUi(self) # This is defined in design.py file automatically # It sets up layout and widgets that are defined self.btnBrowse.clicked.connect(self.browse_folder) # When the button is pressed # Execute browse_folder function def browse_folder(self): self.listWidget.clear() # In case there are any existing elements in the list directory = QtGui.QFileDialog.getExistingDirectory(self, \"Pick a folder\") # execute getExistingDirectory dialog and set the directory variable to be equal # to the user selected directory if directory: # if user didn't pick a directory don't continue for file_name in os.listdir(directory): # for all files, if any, in the directory self.listWidget.addItem(file_name) # add file to the listWidget def main(): app = QtGui.QApplication(sys.argv) # A new instance of QApplication form = ExampleApp() # We set the form to be our ExampleApp (design) form.show() # Show the form app.exec_() # and execute the app if __name__ == '__main__': # if we're running file directly and not importing it main() # run the main function download Hier sehen wir die objektorientierte Umsetzung mit der eigenen Klasse ExampleApp , die den funktionalen Teil der GUI festlegt. In main() finden wir die \u00fcbliche Objekterzeugung, hier form (Instanz von ExampelApp) und den Aufruf des Event-Loops der app (Instanz von QApplication) als app.exec_() .","title":"Aufbau einer Python-QtDesigner Anwendung"},{"location":"ch02/geodatabase.html","text":"Python-Zugriff auf Datenbanken SQLite als Datenbank seht verbreitet, besteht aus Funktionsbibliothek und Datenbankdatei, Unterst\u00fctzt den Standard SQL als Abfragesprache, mit Erweiterung zu Spatiallite auch Geodatenverwaltung in einer Geodatabase Spatialite wird durch eine Funktionsbibliothek repr\u00e4sentiert, f\u00fcr die es ein Python-Modul gibt: pyspatialite Um die Funktionen zu nutzen impotieren wir das Modul: import pyspatialite.dbapi2 as db oder from pyspatialite import dbapi2 as db dbapi2 ist das einzige \"Submodul\" in pyspatialite Objekte zum Zugriff auf Datenbanken db-Modul Methode R\u00fcckgabe Beispiel db.connect(filepath) Connection-Objekt connect = db.connect(\"C:\\tmp\\test.sqlite\") enth\u00e4lt zudem Fehler-Klassen und die Klassen Cursor, Row, etc. Diese werden aber nur innerhalb des Moduls benutzt legt eine neue Datenbankdatei an, falls diese noch nicht existiert. Connection-Objekt Verbindung zur Datenbank wird automatisch durch die Methode connect des db-Moduls erzeugt erlaubt es, SQL-Befehle abzusetzen Methode R\u00fcckgabe Beispiel/Erl\u00e4uterung connect.cursor() Cursor-Objekt cur = connect.cursor() connect.execute() Cursor-Objekt cur = connect.execute(\"Select 'Hello World'\") connect.close() keine schlie\u00dft die Verbindung Cursor-Objekt Zeiger auf die zur\u00fcckgegebenen Daten eines SQL-Befehls Kann auch selbst SQL-Befehle ausf\u00fchren Methode R\u00fcckgabe Beispiel/Erl\u00e4uterung cur.fetchall() List-Objekt result = cur.fetchall() cur.execute() Cursor-Objekt cur.execute(\"Select 'Hello New World'\") cur.close() keine schlie\u00dft die Verbindung fetchall() wird aufgerufen, nachdem ein SQL-Kommando ausgef\u00fchrt wurde execute() \u00fcberschreibt den Zustand des Cursers mit der (neuen) Abfrage close() schlie\u00dft den Cursor. Enthaltene Daten einer Abfrage werden gel\u00f6scht. SQL Part 1 eine Tabelle verwalten Anlegen einer Tabelle unter Angabe der Spaltennamen und Datentypen (Tabellendefinition). SQL-Datentypen : CREATE TABLE kreise (ks INTEGER, name VARCHAR(30), einw INTEGER); \u00c4ndern der Tabellendefinition, hier wird eine Spalte erg\u00e4nzt: ALTER TABLE kreise ADD COLUMN sitz VARCHAR(30); L\u00f6schen eines DB-Elements, also z.B. einer Tabelle ( DROP TABLE kreise ): DROP {database, table, index, view} name Daten in ein Tabelle eintragen INSERT INTO kreise (ks, name, einw) VALUES (7131, Ahrweiler,127770); Tabellendaten verarbeiten Tabellendaten k\u00f6nnen durch Suchausdr\u00fccke, mit einer sog. WHERE-Clause, auf Zeilenebene selektiert werden. siehe auch Tabellendaten aktualisieren ( ersetzen ): UPDATE name SET zuweisung WHERE suchausdruck Tabellendaten l\u00f6schen: DELETE FROM name WHERE suchausdruck Tabelle abfragen F\u00fcr den SELECT-Befehl existieren drei grundlegende Anwendungsm\u00f6glichkeiten -- die ganze Tabelle SELECT * FROM name -- Einschr\u00e4nkungen der auszugebenden Spalten SELECT attribute FROM name -- Einschr\u00e4nkung der auszugebenden Zeilen SELECT attribute FROM name WHERE suchausdruck Beispieldatenbank mit Daten der Kreise und Kreisfreien St\u00e4dte in Rheinland-Pfalz. Wir erstellen diese Datenbank mit SQL-Befehlen in spatialite_gui : CREATE TABLE kreise (ks INTEGER NOT NULL PRIMARY KEY, name VARCHAR(30), einw INTEGER); insert into kreise VALUES (7311,\"Frankenthal (Pfalz)\",48363); insert into kreise VALUES (7312,\"Kaiserslautern\",98520); insert into kreise VALUES (7111,\"Koblenz\",112586); insert into kreise VALUES (7313,\"Landau in der Pfalz\",45362); insert into kreise VALUES (7314,\"Ludwigshafen am Rhein\",164718); insert into kreise VALUES (7315,\"Mainz\",209779); insert into kreise VALUES (7316,\"Neustadt an der Weinstra\u00dfe\",52999); insert into kreise VALUES (7317,\"Pirmasens\",40125); insert into kreise VALUES (7318,\"Speyer\",50284); insert into kreise VALUES (7211,\"Trier\",114914); insert into kreise VALUES (7319,\"Worms\",82102); insert into kreise VALUES (7320,\"Zweibr\u00fccken\",34260); insert into kreise VALUES (7131,\"Ahrweiler\",127770); insert into kreise VALUES (7132,\"Altenkirchen (Ww)\",129171); insert into kreise VALUES (7331,\"Alzey-Worms\",127274); insert into kreise VALUES (7332,\"Bad D\u00fcrkheim\",132203); insert into kreise VALUES (7133,\"Bad Kreuznach\",156821); insert into kreise VALUES (7231,\"Bernkastel-Wittlich\",111828); insert into kreise VALUES (7134,\"Birkenfeld\",80615); insert into kreise VALUES (7135,\"Cochem-Zell\",62391); insert into kreise VALUES (7333,\"Donnersbergkreis\",75230); insert into kreise VALUES (7232,\"Eifelkreis Bitburg-Pr\u00fcm\",97180); insert into kreise VALUES (7334,\"Germersheim\",127303); insert into kreise VALUES (7335,\"Kaiserslautern\",104966); insert into kreise VALUES (7336,\"Kusel\",70997); insert into kreise VALUES (7339,\"Mainz-Bingen\",208749); insert into kreise VALUES (7137,\"Mayen-Koblenz\",211925); insert into kreise VALUES (7138,\"Neuwied\",180655); insert into kreise VALUES (7140,\"Rhein-Hunsr\u00fcck-Kreis\",102529); insert into kreise VALUES (7141,\"Rhein-Lahn-Kreis\",123543); insert into kreise VALUES (7338,\"Rhein-Pfalz-Kreis\",151546); insert into kreise VALUES (7337,\"S\u00fcdliche Weinstra\u00dfe\",110526); insert into kreise VALUES (7340,\"S\u00fcdwestpfalz\",96474); insert into kreise VALUES (7235,\"Trier-Saarburg\",147999); insert into kreise VALUES (7233,\"Vulkaneifel\",60794); insert into kreise VALUES (7143,\"Westerwaldkreis\",200302); download Beispiele f\u00fcr Abfragen Abfragen f\u00fcr spatialite_gui SELECT name FROM kreise WHERE einw < 100000; SELECT name, einw FROM kreise WHERE name like \"%kreis%\"; SELECT name, einw FROM kreise WHERE NOT name like \"%pfalz%\"; ALTER TABLE kreise ADD COLUMN kurzname varchar(3) UPDATE kreise SET kurzname = substr(name,0,3) UPDATE kreise SET kurzname = substr(name,0,3) || substr(name,-1,2) WHERE substr(name, -1,2) != ')' Abfragen mit Python from pyspatialite import dbapi2 as db conn = db.connect(r\"C:\\temp\\station.sqlite\") cur = conn.cursor() sql = \"\"\"SELECT name, einw FROM kreise WHERE name like \"%kreis%\";\"\"\" cur.execute(sql) result = cur.fetchall() print result Die Abfrage liefert als Ergebnis ein Liste mit Tupeln als Zeilen! Informationen zur Abfrage liefert cur.description, es enth\u00e4lt die Eigenschaften der Spalten (hier nur die Namen). print cur.description # nur die Namen print zip(*cur.description)[0] # m\u00f6gliche Anwendung: print \"%s\\t%s\"%zip(*cur.description)[0] Beispieltabelle poStation Eine Tabelle anlegen from pyspatialite import dbapi2 as db import urlreader def createDbTableStation(cur): sql = \"\"\"CREATE TABLE poStation ( uuid char(36) NOT NULL PRIMARY KEY, number char(7) NOT NULL, shortname varchar, longname varchar, km float, agency varchar, longitude float, latitude float, water varchar)\"\"\" cur.execute(sql) dbname = r\"C:\\temp\\station.sqlite\" conn = db.connect(dbname) cur = conn.cursor() createDbTableStation(cur) conn.close() Die angelegte Datenbank und die Tabelle k\u00f6nnen z.B. mit dem Programm spatialite_gui angsehen werden. Daten laden und aufbereiten def getDataTable(jsdata, columns=[]): table = [] for st in jsdata: row = [] for key in columns: row.append(st[key] if st.has_key(key) else None) table.append(row) return table url = \"https://www.pegelonline.wsv.de/webservices/rest-api/v2/stations.json\" jsdata = urlreader.getJsonResponse(url) fields = [\"uuid\", \"number\", \"shortname\", \"longname\", \"km\", \"agency\", \"longitude\", \"latitude\", \"water\"] table = getDataTable(jsdata, fields) Ein Problem stellt der Eintrag water dar. Die angelegte Tabelle erwartet einen String, wir aber haben ein Dictionary-Objekt: >>> print table[0][-1] Bei der weiteren Verarbeitung m\u00fcssen wir den Namen als longname extrahieren. Angenommen wir betrachten die Zeilen der Tabelle, dann betrifft die \u00c4nderung die letzte Spalte: row = table[0] row[-1] = row[-1]['longname'] Die konkrete Anwendung erfolgt im n\u00e4chsten Schritt. Daten in eine Tabelle einf\u00fcgen Mit dem SQL-Befehl INSERT INTO tablename VALUES (v1,v2,...) k\u00f6nnen wir einer Tabelle eine Zeile mit Werten hinzuf\u00fcgen. Da alle SQL-Befehle als String \u00fcbergeben werden, empfiehlt es sich, die Datenwerte aus einer Python-List in den String einzuf\u00fcgen. Wir kennen bereits Format-Strings in der Form \"%s %s %s\"%(v1,v2,v3) . F\u00fcr einen Cursor wurde dieses Konzept erweitert, sodass auch die Datentypen entsprechend der SQL-Syntax eingef\u00fcgt werden k\u00f6nnen. INSERT INTO poStation VALUES ('36e85829-2fb3-41a0-8a1b-aa9e76431b47', 4940020, 'NIEDERBLOCKLAND', 'NIEDERBLOCKLAND', 7.992, 'WSA BREMEN', 8.826504838107983, 53.161504277715444, 'W\u00dcMME') Die ist ein g\u00fcltiger Insert-Befehl, wobei Strings mit einfachen Hochkommata gekennzeichnet sint, Zahlenwerte hingegen nicht. Eine erweiterte M\u00f6glichkeit f\u00fcr SQL-Befehle und das Cursor-Objekt besteht in einem Formatstring, der Fragezeichen als Platzhalter in der Werteliste verwendet. row = ['36e85829-2fb3-41a0-8a1b-aa9e76431b47', 4940020, 'NIEDERBLOCKLAND', 'NIEDERBLOCKLAND', 7.992, 'WSA BREMEN', 8.826504838107983, 53.161504277715444, 'W\u00dcMME'] sql = \"INSERT INTO poStation VALUES (?,?,?,?,?,?,?,?,?)\" cur.execute(sql, row) Erkl\u00e4rung: row ist eine Python-Liste, die in execute als zweiter Parameter \u00fcbergeben wird. Die Funktion execute setzt die Werte dann, entsprechend ihres Datentyps (also mit oder ohne Hochkomma), in die Werteliste ein. Um in einer Python-Funktion soviele Fragezeichen einzuf\u00fcgen, wie eine Tabelle Spalten oder Zeile Werte hat, k\u00f6nnen wir die Multiplikation von Zeichen mit einer Integerzahl nutzen: >>> ['?']*9 # erzeugt eine Liste mit len(row) Fragezeichen ['?', '?', '?', '?', '?', '?', '?', '?', '?'] >>> \",\".join(['?']*9) # f\u00fcgt eine Liste mit Fragezeichen als String zusammen und trennt diese mit einem Komma '?,?,?,?,?,?,?,?,?' Hintergrund der zweiten Operation: In SQL stehen die Platzhalter in einem String! Nun k\u00f6nnen wir f\u00fcr unsere Fragestellung auch schreiben: row = ['36e85829-2fb3-41a0-8a1b-aa9e76431b47', 4940020, 'NIEDERBLOCKLAND', 'NIEDERBLOCKLAND', 7.992, 'WSA BREMEN', 8.826504838107983, 53.161504277715444, 'W\u00dcMME'] fgz = \",\".join(['?']*len(row)) sql = \"INSERT INTO poStation VALUES (%s)\"%fgz print sql dies bauen wir jetzt in das Script ein: table = getDataTable(jsdata, fields) for row in table: row[-1] = row[-1]['longname'] # letztes Feld enth\u00e4lt dict -> string fgz = \",\".join(['?']*len(row)) sql = \"INSERT INTO poStation VALUES (%s)\"%fgz cur.execute(sql, row) # \u00c4nderungen abschlie\u00dfen conn.commit() Wird ein insert-Befehl doppelt ausgef\u00fchrt, erzeugt er einen Fehler, da mit create table die Spalte uuid als eindeutig festgelegt wurde. Dieser Fehler kann umgangen werden, indem wir nicht insert allein benutzen, sondern schreiben: insert or replace into Die Tabelle kann auf diese Weise mit den aktuellen, abgefragten Werten gef\u00fcllt werden. Das Ergebnis der Operation kann wieder mit spatialite_gui betrachtet werden. Daten aus der Datenbank lesen from pyspatialite import dbapi2 as db dbname = r\"C:\\temp\\station.sqlite\" conn = db.connect(dbname) cur = conn.cursor() cur.execute(\"SELECT * FROM poStation WHERE water='MOSEL'\") data = cur.fetchall() for row in data: for val in row: print val, print \"\" Eine Geometry-Spalte einrichten Standard der Simple Features Sqlite mit InitSpatialData verh\u00e4lt sich wie Postgresql mit PostGIS nutzen (fast) dieselben Funktionen, um geometrische Daten zu verwalten Wir f\u00fcgen eine Geometriespalte f\u00fcr die Stationen hinzu: from pyspatialite import dbapi2 as db dbname = r\"C:\\temp\\station.sqlite\" conn = db.connect(dbname) cur = conn.cursor() # r\u00e4umliche Datenstrukturen anlegen sql = 'SELECT InitSpatialMetadata(1)' # gibt es nicht in PostGIS cur.execute(sql) # creating a POINT Geometry column sql = \"\"\"SELECT AddGeometryColumn('poStation', 'geom', 4326, 'POINT', 'XY')\"\"\" cur.execute(sql) Geodaten in eine Tabelle schreiben Well-Known-Text Geometrien werden entweder bin\u00e4r oder als String verarbeitet Im Fall des SQL-INSERTS \u00fcbergeben wir der Funktion GeomFromText() einen String Das Well-Known-Text-Format definiert f\u00fcr die Simple-Features das passende Textformat f\u00fcr Datenbanken Beispiel f\u00fcr Punkte als String: 'POINT(27.13 47.11)', optional kann/muss auch das Koordinatensystem angegeben werden In einer Abfrage (SQL-SELECT) verwenden wir AsText(), um das Geometrieobjekt als String auszugeben Link zur offiziellen Formatbeschreibung Well-Known-Text-Formate f\u00fcr Simple-Features und SQL in SQL s\u00e4he dies so aus: UPDATE poStation set geom = GeomFromText('POINT(27.13 47.11)', 4326) uns als Abfrage/Anzeige aller Daten: SELECT \"uuid\", \"number\", \"shortname\", \"longname\", \"km\", \"agency\", \"longitude\", \"latitude\", \"water\", AsText(\"geom\") FROM \"poStation\" Probieren Sie dies in spatialite_gui aus: Jetzt haben allerdings alle Stationen diesselbe Koordinate. Nat\u00fcrlich m\u00fcssen wir die Geometrien aus den Angaben f\u00fcr longitute und latitude der Pegelonline-Daten generieren. Wir schauen uns diesen Weg via Python an: from pyspatialite import dbapi2 as db dbname = r\"C:\\temp\\station.sqlite\" conn = db.connect(dbname) sql_select = \"\"\"SELECT \"uuid\", \"longitude\", \"latitude\" FROM poStation;\"\"\" cur_select = conn.execute(sql_select) for row in cur_select.fetchall(): uuid, lon, lat = row if lon and lat: sql_update = \"\"\"UPDATE poStation set geom = GeomFromText('POINT(%f %f)', 4326) WHERE \"uuid\" = '%s';\"\"\"%(lon, lat, uuid) conn.execute(sql_update) conn.commit() Umsetzung f\u00fcr das Projekt Ein sauberer Weg f\u00fchrt allerdings \u00fcber eine direkte Verarbeitung, mit den Schritten leere Tabelle erstellen Geometriespalte hinzuf\u00fcgen Daten von Pegel-Online lesen Daten, inkl. Geometrie einf\u00fcgen Einschr\u00e4nkung: Die Verwendung der Platzhalter ('?') funktioniert mit Funktionen, wie GeomFromText(), die in der Werteliste stehen, etwas anders. An der Stelle, wo ein Wert in eine Funktion eingesetzt wird, muss auch der Funktionsname mit in die Liste der Fragezeichen aufgenommen werden: ''''INSERT INTO poStation VALUES (?,?,?,?,?,?,?,?,?, GeomFromText(?, 4326))'''' from pyspatialite import dbapi2 as db import urlreader def createDbTableStation(cur): sql = \"\"\"CREATE TABLE poStation ( uuid char(36) NOT NULL PRIMARY KEY, number char(7) NOT NULL, shortname varchar, longname varchar, km float, agency varchar, longitude float, latitude float, water varchar)\"\"\" cur.execute(sql) # creating a POINT Geometry column sql = \"\"\"SELECT AddGeometryColumn('poStation', 'geom', 4326, 'POINT', 'XY')\"\"\" cur.execute(sql) def getDataTable(jsdata, columns=[]): table = [] for st in jsdata: row = [] for key in columns: row.append(st[key] if st.has_key(key) else None) table.append(row) return table dbname = r\"C:\\temp\\station.sqlite\" conn = db.connect(dbname) # r\u00e4umliche Datenstrukturen anlegen # sql = 'SELECT InitSpatialMetadata(1)' # conn.execute(sql) cur = conn.cursor() ##createDbTableStation(cur) url = \"https://www.pegelonline.wsv.de/webservices/rest-api/v2/stations.json\" jsdata = urlreader.getJsonResponse(url) fields = [\"uuid\", \"number\", \"shortname\", \"longname\", \"km\", \"agency\", \"longitude\", \"latitude\", \"water\"] table = getDataTable(jsdata, fields) for row in table: # replace water dict with longname row[-1] = row[-1]['longname'] # accept only rows with point coordinates if row[6] and row[7]: # strings for sql statement # WKT-Point-String str_geom = \"POINT(%f %f)\"%(row[6], row[7]) # field list as string str_fields = \",\".join(fields + ['geom']) # 'Fragezeichen' as a string str_fgz = \",\".join(['?']*len(row)) # Functions are always part of this str_fgz += \", GeomFromText(?, 4326)\" # let execute() add all values from row, including WKT-Point-String row.append(str_geom) # build the whole sql string # sql = \"INSERT INTO poStation (%s)\"%str_fields + \" VALUES (%s)\"%str_fgz sql = \"INSERT INTO poStation VALUES (%s)\"%str_fgz cur.execute(sql, row) # \u00c4nderungen abschlie\u00dfen conn.commit() Aufgabenstellungen Funktionen zur Automatisierung: Insert-Befehl erzeugen Entwerfen Sie eine Funktion, die einen SQL-String f\u00fcr den insert-Befehl erstellt, der direkt aus einer Liste von Feldnamen erzeugt wird und daraus die entsprechende Anzahl an Platzhaltern erzeugt. Die Funktion sollte in der Lage sein, auch eine Geometriespalte einzuf\u00fcgen! Geometriespalten stehen nicht notwendigerweise am Schluss einer Feldliste m\u00f6glicher Funktionsaufruf: buildSQLstring(row, fields, geom_field, srid) row: die Datenzeile einer Tabelle als zweidimensionales Feld (List, Tuple) fields: Liste der Namen der Tabellenspalten geom_field: die Position oder der Name der Geometriespalte in fields, bzw. ein Wert, der anzeigt, dass keine Geometrie vorliegt (bspw. None, -1) srid: Die Nummer des Koordinatensystems der Geometrie, wird an GeomFromText() \u00fcbergeben WKT-Darstellungen aus Tuplen erzeugen Entwerfen Sie eine Funktion, die aus Geomtriedaten (bestehend aus Tuples ), eine WKT-Darstellung erzeugt. Diese soll eingesetzt werden, wenn Geometrien in eine DB-Tabelle eingef\u00fcgt werden sollen. Geometrietypen sollen als POINT, LINESTRING und POLYGON umgewandelt werden k\u00f6nnen Nutzen Sie z.B. die Funktion test_dim aus dem Geometriemodul geomet, um zwischen den Geometrietypen zu unterscheiden! Beide Funktionen sollen so funktionieren, dass sie in einer for-Schleife, wie oben, eingesetzt werden k\u00f6nnen! Probieren Sie es aus!","title":"Python-Zugriff auf Datenbanken"},{"location":"ch02/geodatabase.html#python-zugriff-auf-datenbanken","text":"SQLite als Datenbank seht verbreitet, besteht aus Funktionsbibliothek und Datenbankdatei, Unterst\u00fctzt den Standard SQL als Abfragesprache, mit Erweiterung zu Spatiallite auch Geodatenverwaltung in einer Geodatabase Spatialite wird durch eine Funktionsbibliothek repr\u00e4sentiert, f\u00fcr die es ein Python-Modul gibt: pyspatialite Um die Funktionen zu nutzen impotieren wir das Modul: import pyspatialite.dbapi2 as db oder from pyspatialite import dbapi2 as db dbapi2 ist das einzige \"Submodul\" in pyspatialite","title":"Python-Zugriff auf Datenbanken"},{"location":"ch02/geodatabase.html#objekte-zum-zugriff-auf-datenbanken","text":"db-Modul Methode R\u00fcckgabe Beispiel db.connect(filepath) Connection-Objekt connect = db.connect(\"C:\\tmp\\test.sqlite\") enth\u00e4lt zudem Fehler-Klassen und die Klassen Cursor, Row, etc. Diese werden aber nur innerhalb des Moduls benutzt legt eine neue Datenbankdatei an, falls diese noch nicht existiert. Connection-Objekt Verbindung zur Datenbank wird automatisch durch die Methode connect des db-Moduls erzeugt erlaubt es, SQL-Befehle abzusetzen Methode R\u00fcckgabe Beispiel/Erl\u00e4uterung connect.cursor() Cursor-Objekt cur = connect.cursor() connect.execute() Cursor-Objekt cur = connect.execute(\"Select 'Hello World'\") connect.close() keine schlie\u00dft die Verbindung Cursor-Objekt Zeiger auf die zur\u00fcckgegebenen Daten eines SQL-Befehls Kann auch selbst SQL-Befehle ausf\u00fchren Methode R\u00fcckgabe Beispiel/Erl\u00e4uterung cur.fetchall() List-Objekt result = cur.fetchall() cur.execute() Cursor-Objekt cur.execute(\"Select 'Hello New World'\") cur.close() keine schlie\u00dft die Verbindung fetchall() wird aufgerufen, nachdem ein SQL-Kommando ausgef\u00fchrt wurde execute() \u00fcberschreibt den Zustand des Cursers mit der (neuen) Abfrage close() schlie\u00dft den Cursor. Enthaltene Daten einer Abfrage werden gel\u00f6scht.","title":"Objekte zum Zugriff auf Datenbanken"},{"location":"ch02/geodatabase.html#sql-part-1","text":"eine Tabelle verwalten Anlegen einer Tabelle unter Angabe der Spaltennamen und Datentypen (Tabellendefinition). SQL-Datentypen : CREATE TABLE kreise (ks INTEGER, name VARCHAR(30), einw INTEGER); \u00c4ndern der Tabellendefinition, hier wird eine Spalte erg\u00e4nzt: ALTER TABLE kreise ADD COLUMN sitz VARCHAR(30); L\u00f6schen eines DB-Elements, also z.B. einer Tabelle ( DROP TABLE kreise ): DROP {database, table, index, view} name Daten in ein Tabelle eintragen INSERT INTO kreise (ks, name, einw) VALUES (7131, Ahrweiler,127770); Tabellendaten verarbeiten Tabellendaten k\u00f6nnen durch Suchausdr\u00fccke, mit einer sog. WHERE-Clause, auf Zeilenebene selektiert werden. siehe auch Tabellendaten aktualisieren ( ersetzen ): UPDATE name SET zuweisung WHERE suchausdruck Tabellendaten l\u00f6schen: DELETE FROM name WHERE suchausdruck Tabelle abfragen F\u00fcr den SELECT-Befehl existieren drei grundlegende Anwendungsm\u00f6glichkeiten -- die ganze Tabelle SELECT * FROM name -- Einschr\u00e4nkungen der auszugebenden Spalten SELECT attribute FROM name -- Einschr\u00e4nkung der auszugebenden Zeilen SELECT attribute FROM name WHERE suchausdruck","title":"SQL Part 1"},{"location":"ch02/geodatabase.html#beispieldatenbank","text":"mit Daten der Kreise und Kreisfreien St\u00e4dte in Rheinland-Pfalz. Wir erstellen diese Datenbank mit SQL-Befehlen in spatialite_gui : CREATE TABLE kreise (ks INTEGER NOT NULL PRIMARY KEY, name VARCHAR(30), einw INTEGER); insert into kreise VALUES (7311,\"Frankenthal (Pfalz)\",48363); insert into kreise VALUES (7312,\"Kaiserslautern\",98520); insert into kreise VALUES (7111,\"Koblenz\",112586); insert into kreise VALUES (7313,\"Landau in der Pfalz\",45362); insert into kreise VALUES (7314,\"Ludwigshafen am Rhein\",164718); insert into kreise VALUES (7315,\"Mainz\",209779); insert into kreise VALUES (7316,\"Neustadt an der Weinstra\u00dfe\",52999); insert into kreise VALUES (7317,\"Pirmasens\",40125); insert into kreise VALUES (7318,\"Speyer\",50284); insert into kreise VALUES (7211,\"Trier\",114914); insert into kreise VALUES (7319,\"Worms\",82102); insert into kreise VALUES (7320,\"Zweibr\u00fccken\",34260); insert into kreise VALUES (7131,\"Ahrweiler\",127770); insert into kreise VALUES (7132,\"Altenkirchen (Ww)\",129171); insert into kreise VALUES (7331,\"Alzey-Worms\",127274); insert into kreise VALUES (7332,\"Bad D\u00fcrkheim\",132203); insert into kreise VALUES (7133,\"Bad Kreuznach\",156821); insert into kreise VALUES (7231,\"Bernkastel-Wittlich\",111828); insert into kreise VALUES (7134,\"Birkenfeld\",80615); insert into kreise VALUES (7135,\"Cochem-Zell\",62391); insert into kreise VALUES (7333,\"Donnersbergkreis\",75230); insert into kreise VALUES (7232,\"Eifelkreis Bitburg-Pr\u00fcm\",97180); insert into kreise VALUES (7334,\"Germersheim\",127303); insert into kreise VALUES (7335,\"Kaiserslautern\",104966); insert into kreise VALUES (7336,\"Kusel\",70997); insert into kreise VALUES (7339,\"Mainz-Bingen\",208749); insert into kreise VALUES (7137,\"Mayen-Koblenz\",211925); insert into kreise VALUES (7138,\"Neuwied\",180655); insert into kreise VALUES (7140,\"Rhein-Hunsr\u00fcck-Kreis\",102529); insert into kreise VALUES (7141,\"Rhein-Lahn-Kreis\",123543); insert into kreise VALUES (7338,\"Rhein-Pfalz-Kreis\",151546); insert into kreise VALUES (7337,\"S\u00fcdliche Weinstra\u00dfe\",110526); insert into kreise VALUES (7340,\"S\u00fcdwestpfalz\",96474); insert into kreise VALUES (7235,\"Trier-Saarburg\",147999); insert into kreise VALUES (7233,\"Vulkaneifel\",60794); insert into kreise VALUES (7143,\"Westerwaldkreis\",200302); download","title":"Beispieldatenbank"},{"location":"ch02/geodatabase.html#beispiele-fur-abfragen","text":"Abfragen f\u00fcr spatialite_gui SELECT name FROM kreise WHERE einw < 100000; SELECT name, einw FROM kreise WHERE name like \"%kreis%\"; SELECT name, einw FROM kreise WHERE NOT name like \"%pfalz%\"; ALTER TABLE kreise ADD COLUMN kurzname varchar(3) UPDATE kreise SET kurzname = substr(name,0,3) UPDATE kreise SET kurzname = substr(name,0,3) || substr(name,-1,2) WHERE substr(name, -1,2) != ')'","title":"Beispiele f\u00fcr Abfragen"},{"location":"ch02/geodatabase.html#abfragen-mit-python","text":"from pyspatialite import dbapi2 as db conn = db.connect(r\"C:\\temp\\station.sqlite\") cur = conn.cursor() sql = \"\"\"SELECT name, einw FROM kreise WHERE name like \"%kreis%\";\"\"\" cur.execute(sql) result = cur.fetchall() print result Die Abfrage liefert als Ergebnis ein Liste mit Tupeln als Zeilen! Informationen zur Abfrage liefert cur.description, es enth\u00e4lt die Eigenschaften der Spalten (hier nur die Namen). print cur.description # nur die Namen print zip(*cur.description)[0] # m\u00f6gliche Anwendung: print \"%s\\t%s\"%zip(*cur.description)[0]","title":"Abfragen mit Python"},{"location":"ch02/geodatabase.html#beispieltabelle-postation","text":"","title":"Beispieltabelle poStation"},{"location":"ch02/geodatabase.html#eine-tabelle-anlegen","text":"from pyspatialite import dbapi2 as db import urlreader def createDbTableStation(cur): sql = \"\"\"CREATE TABLE poStation ( uuid char(36) NOT NULL PRIMARY KEY, number char(7) NOT NULL, shortname varchar, longname varchar, km float, agency varchar, longitude float, latitude float, water varchar)\"\"\" cur.execute(sql) dbname = r\"C:\\temp\\station.sqlite\" conn = db.connect(dbname) cur = conn.cursor() createDbTableStation(cur) conn.close() Die angelegte Datenbank und die Tabelle k\u00f6nnen z.B. mit dem Programm spatialite_gui angsehen werden.","title":"Eine Tabelle anlegen"},{"location":"ch02/geodatabase.html#daten-laden-und-aufbereiten","text":"def getDataTable(jsdata, columns=[]): table = [] for st in jsdata: row = [] for key in columns: row.append(st[key] if st.has_key(key) else None) table.append(row) return table url = \"https://www.pegelonline.wsv.de/webservices/rest-api/v2/stations.json\" jsdata = urlreader.getJsonResponse(url) fields = [\"uuid\", \"number\", \"shortname\", \"longname\", \"km\", \"agency\", \"longitude\", \"latitude\", \"water\"] table = getDataTable(jsdata, fields) Ein Problem stellt der Eintrag water dar. Die angelegte Tabelle erwartet einen String, wir aber haben ein Dictionary-Objekt: >>> print table[0][-1] Bei der weiteren Verarbeitung m\u00fcssen wir den Namen als longname extrahieren. Angenommen wir betrachten die Zeilen der Tabelle, dann betrifft die \u00c4nderung die letzte Spalte: row = table[0] row[-1] = row[-1]['longname'] Die konkrete Anwendung erfolgt im n\u00e4chsten Schritt.","title":"Daten laden und aufbereiten"},{"location":"ch02/geodatabase.html#daten-in-eine-tabelle-einfugen","text":"Mit dem SQL-Befehl INSERT INTO tablename VALUES (v1,v2,...) k\u00f6nnen wir einer Tabelle eine Zeile mit Werten hinzuf\u00fcgen. Da alle SQL-Befehle als String \u00fcbergeben werden, empfiehlt es sich, die Datenwerte aus einer Python-List in den String einzuf\u00fcgen. Wir kennen bereits Format-Strings in der Form \"%s %s %s\"%(v1,v2,v3) . F\u00fcr einen Cursor wurde dieses Konzept erweitert, sodass auch die Datentypen entsprechend der SQL-Syntax eingef\u00fcgt werden k\u00f6nnen. INSERT INTO poStation VALUES ('36e85829-2fb3-41a0-8a1b-aa9e76431b47', 4940020, 'NIEDERBLOCKLAND', 'NIEDERBLOCKLAND', 7.992, 'WSA BREMEN', 8.826504838107983, 53.161504277715444, 'W\u00dcMME') Die ist ein g\u00fcltiger Insert-Befehl, wobei Strings mit einfachen Hochkommata gekennzeichnet sint, Zahlenwerte hingegen nicht. Eine erweiterte M\u00f6glichkeit f\u00fcr SQL-Befehle und das Cursor-Objekt besteht in einem Formatstring, der Fragezeichen als Platzhalter in der Werteliste verwendet. row = ['36e85829-2fb3-41a0-8a1b-aa9e76431b47', 4940020, 'NIEDERBLOCKLAND', 'NIEDERBLOCKLAND', 7.992, 'WSA BREMEN', 8.826504838107983, 53.161504277715444, 'W\u00dcMME'] sql = \"INSERT INTO poStation VALUES (?,?,?,?,?,?,?,?,?)\" cur.execute(sql, row) Erkl\u00e4rung: row ist eine Python-Liste, die in execute als zweiter Parameter \u00fcbergeben wird. Die Funktion execute setzt die Werte dann, entsprechend ihres Datentyps (also mit oder ohne Hochkomma), in die Werteliste ein. Um in einer Python-Funktion soviele Fragezeichen einzuf\u00fcgen, wie eine Tabelle Spalten oder Zeile Werte hat, k\u00f6nnen wir die Multiplikation von Zeichen mit einer Integerzahl nutzen: >>> ['?']*9 # erzeugt eine Liste mit len(row) Fragezeichen ['?', '?', '?', '?', '?', '?', '?', '?', '?'] >>> \",\".join(['?']*9) # f\u00fcgt eine Liste mit Fragezeichen als String zusammen und trennt diese mit einem Komma '?,?,?,?,?,?,?,?,?' Hintergrund der zweiten Operation: In SQL stehen die Platzhalter in einem String! Nun k\u00f6nnen wir f\u00fcr unsere Fragestellung auch schreiben: row = ['36e85829-2fb3-41a0-8a1b-aa9e76431b47', 4940020, 'NIEDERBLOCKLAND', 'NIEDERBLOCKLAND', 7.992, 'WSA BREMEN', 8.826504838107983, 53.161504277715444, 'W\u00dcMME'] fgz = \",\".join(['?']*len(row)) sql = \"INSERT INTO poStation VALUES (%s)\"%fgz print sql dies bauen wir jetzt in das Script ein: table = getDataTable(jsdata, fields) for row in table: row[-1] = row[-1]['longname'] # letztes Feld enth\u00e4lt dict -> string fgz = \",\".join(['?']*len(row)) sql = \"INSERT INTO poStation VALUES (%s)\"%fgz cur.execute(sql, row) # \u00c4nderungen abschlie\u00dfen conn.commit() Wird ein insert-Befehl doppelt ausgef\u00fchrt, erzeugt er einen Fehler, da mit create table die Spalte uuid als eindeutig festgelegt wurde. Dieser Fehler kann umgangen werden, indem wir nicht insert allein benutzen, sondern schreiben: insert or replace into Die Tabelle kann auf diese Weise mit den aktuellen, abgefragten Werten gef\u00fcllt werden. Das Ergebnis der Operation kann wieder mit spatialite_gui betrachtet werden.","title":"Daten in eine Tabelle einf\u00fcgen"},{"location":"ch02/geodatabase.html#daten-aus-der-datenbank-lesen","text":"from pyspatialite import dbapi2 as db dbname = r\"C:\\temp\\station.sqlite\" conn = db.connect(dbname) cur = conn.cursor() cur.execute(\"SELECT * FROM poStation WHERE water='MOSEL'\") data = cur.fetchall() for row in data: for val in row: print val, print \"\"","title":"Daten aus der Datenbank lesen"},{"location":"ch02/geodatabase.html#eine-geometry-spalte-einrichten","text":"Standard der Simple Features Sqlite mit InitSpatialData verh\u00e4lt sich wie Postgresql mit PostGIS nutzen (fast) dieselben Funktionen, um geometrische Daten zu verwalten Wir f\u00fcgen eine Geometriespalte f\u00fcr die Stationen hinzu: from pyspatialite import dbapi2 as db dbname = r\"C:\\temp\\station.sqlite\" conn = db.connect(dbname) cur = conn.cursor() # r\u00e4umliche Datenstrukturen anlegen sql = 'SELECT InitSpatialMetadata(1)' # gibt es nicht in PostGIS cur.execute(sql) # creating a POINT Geometry column sql = \"\"\"SELECT AddGeometryColumn('poStation', 'geom', 4326, 'POINT', 'XY')\"\"\" cur.execute(sql)","title":"Eine Geometry-Spalte einrichten"},{"location":"ch02/geodatabase.html#geodaten-in-eine-tabelle-schreiben","text":"","title":"Geodaten in eine Tabelle schreiben"},{"location":"ch02/geodatabase.html#well-known-text","text":"Geometrien werden entweder bin\u00e4r oder als String verarbeitet Im Fall des SQL-INSERTS \u00fcbergeben wir der Funktion GeomFromText() einen String Das Well-Known-Text-Format definiert f\u00fcr die Simple-Features das passende Textformat f\u00fcr Datenbanken Beispiel f\u00fcr Punkte als String: 'POINT(27.13 47.11)', optional kann/muss auch das Koordinatensystem angegeben werden In einer Abfrage (SQL-SELECT) verwenden wir AsText(), um das Geometrieobjekt als String auszugeben Link zur offiziellen Formatbeschreibung Well-Known-Text-Formate f\u00fcr Simple-Features und SQL in SQL s\u00e4he dies so aus: UPDATE poStation set geom = GeomFromText('POINT(27.13 47.11)', 4326) uns als Abfrage/Anzeige aller Daten: SELECT \"uuid\", \"number\", \"shortname\", \"longname\", \"km\", \"agency\", \"longitude\", \"latitude\", \"water\", AsText(\"geom\") FROM \"poStation\" Probieren Sie dies in spatialite_gui aus: Jetzt haben allerdings alle Stationen diesselbe Koordinate. Nat\u00fcrlich m\u00fcssen wir die Geometrien aus den Angaben f\u00fcr longitute und latitude der Pegelonline-Daten generieren. Wir schauen uns diesen Weg via Python an: from pyspatialite import dbapi2 as db dbname = r\"C:\\temp\\station.sqlite\" conn = db.connect(dbname) sql_select = \"\"\"SELECT \"uuid\", \"longitude\", \"latitude\" FROM poStation;\"\"\" cur_select = conn.execute(sql_select) for row in cur_select.fetchall(): uuid, lon, lat = row if lon and lat: sql_update = \"\"\"UPDATE poStation set geom = GeomFromText('POINT(%f %f)', 4326) WHERE \"uuid\" = '%s';\"\"\"%(lon, lat, uuid) conn.execute(sql_update) conn.commit()","title":"Well-Known-Text"},{"location":"ch02/geodatabase.html#umsetzung-fur-das-projekt","text":"Ein sauberer Weg f\u00fchrt allerdings \u00fcber eine direkte Verarbeitung, mit den Schritten leere Tabelle erstellen Geometriespalte hinzuf\u00fcgen Daten von Pegel-Online lesen Daten, inkl. Geometrie einf\u00fcgen Einschr\u00e4nkung: Die Verwendung der Platzhalter ('?') funktioniert mit Funktionen, wie GeomFromText(), die in der Werteliste stehen, etwas anders. An der Stelle, wo ein Wert in eine Funktion eingesetzt wird, muss auch der Funktionsname mit in die Liste der Fragezeichen aufgenommen werden: ''''INSERT INTO poStation VALUES (?,?,?,?,?,?,?,?,?, GeomFromText(?, 4326))'''' from pyspatialite import dbapi2 as db import urlreader def createDbTableStation(cur): sql = \"\"\"CREATE TABLE poStation ( uuid char(36) NOT NULL PRIMARY KEY, number char(7) NOT NULL, shortname varchar, longname varchar, km float, agency varchar, longitude float, latitude float, water varchar)\"\"\" cur.execute(sql) # creating a POINT Geometry column sql = \"\"\"SELECT AddGeometryColumn('poStation', 'geom', 4326, 'POINT', 'XY')\"\"\" cur.execute(sql) def getDataTable(jsdata, columns=[]): table = [] for st in jsdata: row = [] for key in columns: row.append(st[key] if st.has_key(key) else None) table.append(row) return table dbname = r\"C:\\temp\\station.sqlite\" conn = db.connect(dbname) # r\u00e4umliche Datenstrukturen anlegen # sql = 'SELECT InitSpatialMetadata(1)' # conn.execute(sql) cur = conn.cursor() ##createDbTableStation(cur) url = \"https://www.pegelonline.wsv.de/webservices/rest-api/v2/stations.json\" jsdata = urlreader.getJsonResponse(url) fields = [\"uuid\", \"number\", \"shortname\", \"longname\", \"km\", \"agency\", \"longitude\", \"latitude\", \"water\"] table = getDataTable(jsdata, fields) for row in table: # replace water dict with longname row[-1] = row[-1]['longname'] # accept only rows with point coordinates if row[6] and row[7]: # strings for sql statement # WKT-Point-String str_geom = \"POINT(%f %f)\"%(row[6], row[7]) # field list as string str_fields = \",\".join(fields + ['geom']) # 'Fragezeichen' as a string str_fgz = \",\".join(['?']*len(row)) # Functions are always part of this str_fgz += \", GeomFromText(?, 4326)\" # let execute() add all values from row, including WKT-Point-String row.append(str_geom) # build the whole sql string # sql = \"INSERT INTO poStation (%s)\"%str_fields + \" VALUES (%s)\"%str_fgz sql = \"INSERT INTO poStation VALUES (%s)\"%str_fgz cur.execute(sql, row) # \u00c4nderungen abschlie\u00dfen conn.commit()","title":"Umsetzung f\u00fcr das Projekt"},{"location":"ch02/geodatabase.html#aufgabenstellungen","text":"Funktionen zur Automatisierung:","title":"Aufgabenstellungen"},{"location":"ch02/geodatabase.html#insert-befehl-erzeugen","text":"Entwerfen Sie eine Funktion, die einen SQL-String f\u00fcr den insert-Befehl erstellt, der direkt aus einer Liste von Feldnamen erzeugt wird und daraus die entsprechende Anzahl an Platzhaltern erzeugt. Die Funktion sollte in der Lage sein, auch eine Geometriespalte einzuf\u00fcgen! Geometriespalten stehen nicht notwendigerweise am Schluss einer Feldliste m\u00f6glicher Funktionsaufruf: buildSQLstring(row, fields, geom_field, srid) row: die Datenzeile einer Tabelle als zweidimensionales Feld (List, Tuple) fields: Liste der Namen der Tabellenspalten geom_field: die Position oder der Name der Geometriespalte in fields, bzw. ein Wert, der anzeigt, dass keine Geometrie vorliegt (bspw. None, -1) srid: Die Nummer des Koordinatensystems der Geometrie, wird an GeomFromText() \u00fcbergeben","title":"Insert-Befehl erzeugen"},{"location":"ch02/geodatabase.html#wkt-darstellungen-aus-tuplen-erzeugen","text":"Entwerfen Sie eine Funktion, die aus Geomtriedaten (bestehend aus Tuples ), eine WKT-Darstellung erzeugt. Diese soll eingesetzt werden, wenn Geometrien in eine DB-Tabelle eingef\u00fcgt werden sollen. Geometrietypen sollen als POINT, LINESTRING und POLYGON umgewandelt werden k\u00f6nnen Nutzen Sie z.B. die Funktion test_dim aus dem Geometriemodul geomet, um zwischen den Geometrietypen zu unterscheiden! Beide Funktionen sollen so funktionieren, dass sie in einer for-Schleife, wie oben, eingesetzt werden k\u00f6nnen! Probieren Sie es aus!","title":"WKT-Darstellungen aus Tuplen erzeugen"},{"location":"ch02/internetkom.html","text":"Python-Module zur Internetkommunikation urllib, urllib2 sind die Standardmodule zur Internetkommunikation \u00fcber das http-Protokoll. Dar\u00fcber hinaus wird das Modul request als Ersatz empfohlen, es muss allerdings nachtr\u00e4glich installiert werden. In der Standardbibliothek finden sich au\u00dferdem Module f\u00fcr alle anderen Zwecke der Internetkommunikation, wie ftplib, cgi oder smtp - bis hin zum http-Server (SimpleHttpServer) Der Unterschied zwischen urllib und urllib2 stellt sich durch einen erweiterten Funktionsumfang von urllib2 dar. urlib2 zum Download nutzen URI: Uniform Request Identifier Internet-Adresse zum Zugriff auf \"Ressourcen\": html-Seiten, Bilder etc. Schema zum Aufbau eines URI's Um mit python eine URI zu lesen ben\u00f6tigt es eine einfachen Anweisung: import urllib2 url = \"http://endor.uni-trier.de/karto/python2/ch01/receipes/index.html\" response = urllib2.urlopen(url).read() print response Fehlerbehandlung Tritt ein Fehler bei der Kommunikation auf, erzeugt das Modul einen Ausnahmefehler, den wir abfangen k\u00f6nnen: import urllib2 def read_request(url): try: response = urllib2.urlopen(url).read() except (urllib2.HTTPError, urllib2.URLError): print \"error reading url:\", url return None return response url = \"http://endor.uni-trier.de/karto/python2/ch01/receipes/index.html\" resp = read_request(url) print resp Detailierte Fehlerbehandlung: Wir trennen read von urlopen und teilen Fehlerbehandlung in zwei auf anstelle der URL rufen wir das Request-Objekt ab (sp\u00e4ter mehr) import urllib2 def read_request(url): try: request = urllib2.Request(url) print request.headers response = urllib2.urlopen(request) data = response.read() return data except urllib2.HTTPError as e: print \"HTTP error reading url:\", url print \"Code\", e.code print \"Returns\", e.read() except urllib2.URLError as e: print \"URL error reading url:\", url print \"Reason:\", e.reason url = \"http://endor.uni-trier.de/karto/python2/ch01/receipes/index.html\" resp = read_request(url) print resp Ablauf einer http-Kommunikation HTTP: Anwendungsschicht von Netzwerkprotokollen Funktionen f\u00fcr Anwendungen auf der h\u00f6chsten Ebene Zustandslos, zwischen Anfragen kann nichts gespeichert werden Ausnahmen durch andere Techniken: Sitzungen (mit Login), Cookies Nachrichten zwischen Server und Client als Anfrage und Antwort Request und Response mit Header und Body Schema der Kommunikation mit HTTP Quelle: Slideshare GET Schickt einen Request, benutzt einen URI, um eine Ressource (Datei) anzufordern, Daten k\u00f6nnen in begrenztem Ma\u00df \u00fcber die URI \u00fcbermittelt werden POST - Schickt einen Request + Daten an den Server, Daten sind im POST-Body abgelegt und nicht begrenzt import urllib2 url = \"http://endor.uni-trier.de/karto/python2/ch01/receipes/index.html\" request = urllib2.Request(url) print \"URL\", request.get_full_url() print \"HOST\", request.get_host() print \"Method\", request.get_method() response = urllib2.urlopen(request) print \"Code\", response.code print \"Message\", response.msg print \"Headers\", response.headers.dict print \"Content-type:\", response.headers.dict[\"content-type\"] print \"Content-length:\", response.headers.dict[\"content-length\"] Der Content-type im response-Header ist ein sehr interessanter Teil des Headers, er teilt uns mit, welches Datenformat \u00fcbertragen wird (der MIME-Type). Erl\u00e4uterung zu m\u00f6glichen Werten. Um dem request via GET einen Header mitzugeben, kann der Queryteil des URI benutzt werden: https://www.w3schools.com/action_page.php?fname=andreas&lname=mueller url = \"https://www.w3schools.com/action_page.php?fname=andreas&lname=mueller\" request = urllib2.Request(url) response = urllib2.urlopen(request) print response.read() Mehr zum Modul und seinen M\u00f6glichkeiten finden wir in der Python-Online Dokumentation Daten aus dem Response-Objekt speichern Mit read haben wir bereits eine Methode zum Lesen von Daten kennengelernt. Die so erhalten Daten k\u00f6nnen wir in Dateien speichern: import urllib2 url = \"https://www.uni-trier.de/fileadmin/_migrated/pics/Zugang_Kartographie.png\" request = urllib2.Request(url) response = urllib2.urlopen(request) data = response.read() f = open(r\"c:\\tmp\\campus2.png\", \"wb\") # bin\u00e4re Datei schreiben f.write(data) f.close() Falls das Lesen der Daten besser kontrolliert werden soll (um Fehler oder eine gro\u00dfe Datenmenge zu managen), kann auch blockweise (im Sinne von gepuffert) vorgegangen werden: import urllib2 url = \"https://ia902604.us.archive.org/4/items/BennyGoodman_795/BennyGoodman1.mp3\" def download(url, dest): file_name = url.split('/')[-1] response = urllib2.urlopen(url) f = open(dest + file_name, 'wb') file_size_dl = 0 block_sz = 8192 while True: buffer = response.read(block_sz) if not buffer: break file_size_dl += len(buffer) f.write(buffer) f.close() return file_size_dl download(url, \"c:\\\\tmp\\\\\") Lesen komprimierter Daten Manche Dienste verlangen, dass angeforderte Daten in komprimierter Form \u00fcbertragen werden sollen. In diesem Fall k\u00f6nnen wir das Modul gzip verwenden, um den Datenstrom zu entpacken: import gzip from StringIO import StringIO import urllib2 def getFileResponse(url): request = urllib2.Request(url) # accept compressed data request.add_header('Accept-Encoding', 'gzip') # request was sent, get response response = urllib2.urlopen(request) # is response compressed? if response.info().get('Content-Encoding') == 'gzip': # read data and uncompress it buf = StringIO(response.read()) # StingIO makes it readable for gzip f = gzip.GzipFile(fileobj=buf) # again: uncompressed data is a stream else: f = response return f url = \"https://www.uni-trier.de/\" f = getFileResponse(url) print f.read() eine universelle Struktur zum Lesen mit http Wir erstellen ein Modul urlreader : import gzip from StringIO import StringIO import urllib2 def uncompressIO(file_like): \"\"\"read a compressed file like stream, uses gzip, return a file-object\"\"\" buf = StringIO(file_like.read()) f = gzip.GzipFile(fileobj=buf) return f def openURL(url): \"\"\"Send a request to url, return the response\"\"\" try: request = urllib2.Request(url) request.add_header('Accept-Encoding', 'gzip') response = urllib2.urlopen(request) return response except urllib2.HTTPError as e: print \"HTTP error reading url:\", url print \"Code\", e.code print \"Returns\", e.read() except urllib2.URLError as e: print \"URL error reading url:\", url print \"Reason:\", e.reason return None def getFileResponse(url): \"\"\"example: how to read from compressing url, return a file object\"\"\" response = openURL(url) # is response compressed? if response.info().get('Content-Encoding') == 'gzip': # read data and uncompress it buf = StringIO(response.read()) # StingIO makes it readable for gzip f = gzip.GzipFile(fileobj=buf) # again: uncompressed data as a stream else: f = response return f if __name__ == '__main__': url = \"https://www.uni-trier.de/\" f = getFileResponse(url) print f.read() Wir speichern dieses Modul als urlreader01.py! XML- und json-Daten Einige Internetdienste, wie z.B. auf dem REST-Protokoll basierende Datenbanken, liefern als Response xml- oder json-Daten. REST: [Representational State Transfer] ist ein Programmierparadigma f\u00fcr verteilte Systeme, insbesondere Webdienste zur Kommunikation zwischen Maschinen, URL wird als Datenbankanfrage verstanden, jede \"Information\" hat ihre eigene Adresse (URL) daraus lassen sich Meshups erstellen: Internetseiten, die aus verschiedenen Quellen neu zusammengestellt werden wird mit den http-Befehlen umgesetzt Http-Befehle als Datenbankabfrage: GET: read a resource (Abfrage liefert Daten) POST: create a new resource (Abfrage erzeugt Dateneintrag) PUT: update a resource (Abfrage aktualisiert Datensatz) DELETE: remove a resource (Abfrage l\u00f6scht einen Dateneintrag) Das json-Format (Javascript Object Notation) wurde als Ersatz zu XML entwickelt nutzt die Javascript-Syntax ein XML-Tag wird zu einem Javascript-Objekt aufeinanderfolgende gleiche Tags werden zu einer Javascript-Liste Beispiele ein Javascript-Objekt wird in Python zu einem Dictionary, eine Javascript-Liste zu einer Python-Liste Hier ein Beispiel zur Umwandlung des Inhalts einer json-Datei: import json strJson = \"\"\"{\"employees\":[ { \"firstName\":\"John\", \"lastName\":\"Doe\" }, { \"firstName\":\"Anna\", \"lastName\":\"Smith\" }, { \"firstName\":\"Peter\", \"lastName\":\"Jones\" } ]}\"\"\" data = json.loads(strJson) # liest aus einem String print data Um direkt aus einer Datei zu lesen, kann ein File-Objekt erstellt und der Methode json.load() \u00fcbergeben werden: import json f = open(\"trgastro.geojson\") data = json.load(f) # liest aus einer Datei print data.keys() f.close() Als Ergebnis erhalten wir den Inhalt eines GeoJson-Objekts. mehr zu GeoJson Es enth\u00e4lt drei Strukturen: crs: Coordinate Reference System: den Daten zugrunde liegendes Koordinatensystem type: Feature Type, Geometrietyp: Point, LineString, Polygon, MultiPoint, MultiLineString und MultiPolygon features: Die eigentlichen Daten mit Geometrie und Sachattributen Das n\u00e4chste Beispiel nutzt den Dienst Pegelonline, um das Stationsnetz der Pegelmessstellen an deutschen Fl\u00fcssen im json-Format abzufragen. Nun kommt auch das Modul urlreader wieder zum Einsatz. import urlreader01 as urlreader import json def readRestJson(url): \"\"\"load a json structure from a REST-URL, returns a list/dict python object\"\"\" # read from http with url response = urlreader.openURL(url) if response.info().get('Content-Encoding') == 'gzip': data = json.load(urlreader.uncompressIO(response)) else: data = json.load(response) response.close() return data url = \"http://www.pegelonline.wsv.de/webservices/rest-api/v2/stations.json\" jsdata = readRestJson(url) print \"Anzahl der Stationen:\", len(jsdata) print \"Attribute:\", jsdata[0].keys() Im Prinzip unterscheidet sich diese Abfrage nicht von einem Datei-Download, nur das wir die Daten aus dem json Format in Python-Datentypen umgewandelt bekommen. Ergebnis ist eine Liste der Stationen Jede Station entspricht einem Dictionary mit den Attributen als Schl\u00fcssel Wir \u00fcbertragen die neue Funktion readRestJson() in unser Modul urlreader und nennen die Funktion getJsonResponse()! \u00c4nderungen: Angabe urlreader. entf\u00e4llt! Nun probieren wir eine andere Abfrage: http://www.pegelonline.wsv.de/webservices/rest-api/v2/stations.json?waters=MOSEL,SAAR Hier benutzen wir den Query-Teil der URL, um die Abfrage der Stationen auf die Fl\u00fcsse Mosel und Saar zu begrenzen. Testen Sie die Abfragen auch im Browser! Um die Daten auszuwerten, erstellen wir daraus eine Tabelle (zweidimensionale Liste) und geben diese aus: import urlreader01 as urlreader def getDataTable(jsdata, columns=[]): table = [] for st in jsdata: row = [] for key in columns: row.append(st[key] if key in st.keys() else None) table.append(row) return table url = \"http://www.pegelonline.wsv.de/webservices/rest-api/v2/stations.json?waters=MOSEL,SAAR\" jsdata = urlreader.getJsonResponse(url) print \"Anzahl der Stationen:\", len(jsdata) print \"Attribute:\", jsdata[0].keys() table = getDataTable(jsdata, [\"number\", \"longname\", \"agency\", \"longitude\", \"latitude\"]) print \"\\t\".join(map(str, [\"number\", \"longname\", \"agency\", \"longitude\", \"latitude\"])) for st in table: print u\"\\t\".join(map(unicode, st)) Daten aus dem Netz sind h\u00e4ufig als unicode (UTF-8) codiert, hier m\u00fcssen wir immer aufpassen, da python2 nicht automatisch zwischen String und Unicode umwandelt! Andererseits werden Sonderzeichen, die in UTF-8 erlaubt sind in einer URL immer maskiert. Sonderzeichen URL-maskierung Leerzeichen %20 \u00d6 %C3%96 \u00f6 %C3%B6 \u00c4 %C3%84 \u00e4 %C3%A4 \u00dc %C3%9C \u00fc %C3%BC Vergleiche auch den Artikel bei Wikipedia Da bei den Namen in einer Abfrage Umlaute vorkommen k\u00f6nnen, m\u00fcssen wir sicherstellen, dass diese korrekt in die URL eingetragen werden. - Gleichzeitig ein Beispiel zur Abfrage des Wasserstands der Station K\u00f6ln . import urlreader01 as urlreader def maskURLString(urlstr): return urlstr.replace(u\" \", u'%20').replace(u'\u00d6',u'%C3%96').replace(u'\u00c4',u'%C3%84').replace(u'\u00dc', u'%C3%9C') url = u\"http://www.pegelonline.wsv.de/webservices/rest-api/v2/stations/K\u00d6LN/W/currentmeasurement.json\" murl = maskURLString(url) jsdata = urlreader.getJsonResponse(murl) print jsdata Alternative zu maskURLString: urllib.quote_plus() Ein eigenes Modul: urlreader Im Modul urlreader02 fassen wir die Erkenntnisse zusammen. Es soll diese Funktionen umfassen: openURL(url): benutzt die urllib2, um ein response-Objekt zur\u00fcckzugeben getJsonResponse(url): analog zu getDataResponse, liest den Datenstrom und gibt das Ergebnis von json.load() zur\u00fcck Hilfsfunktionen: maskURLString(), uncompressIO(), Neue Funktionen: - getFileResponse(url): \u00c4nderung der vorhandenen Funktion, der Datenstrom wird in einer Datei gespeichert - getDataResponse(url): benutzt openURL, liest den Datenstrom und speichert diesen in einer Variablen, das Ergebnis wird zur\u00fcckgegeben \u00fcberlegen Sie, wie die Daten mit getFileResponse bzw. getDataResponse blockweise gelesen werden k\u00f6nnen! Hilfsfunktion zum Entpacken eines blocks : def uncompressBuffer(buffer): buf = StringIO(buffer) f = gzip.GzipFile(fileobj=buf) data = f.read() return data Die Funktion arbeitet wie uncompressIO, nur das die Daten eines Blocks (hier buffer ) hier schon gelesen und damit entpackt werden. Wie kann das Modul objektorientiert aufgebaut werden?","title":"Python-Module zur Internetkommunikation"},{"location":"ch02/internetkom.html#python-module-zur-internetkommunikation","text":"urllib, urllib2 sind die Standardmodule zur Internetkommunikation \u00fcber das http-Protokoll. Dar\u00fcber hinaus wird das Modul request als Ersatz empfohlen, es muss allerdings nachtr\u00e4glich installiert werden. In der Standardbibliothek finden sich au\u00dferdem Module f\u00fcr alle anderen Zwecke der Internetkommunikation, wie ftplib, cgi oder smtp - bis hin zum http-Server (SimpleHttpServer) Der Unterschied zwischen urllib und urllib2 stellt sich durch einen erweiterten Funktionsumfang von urllib2 dar.","title":"Python-Module zur Internetkommunikation"},{"location":"ch02/internetkom.html#urlib2-zum-download-nutzen","text":"","title":"urlib2 zum Download nutzen"},{"location":"ch02/internetkom.html#uri-uniform-request-identifier","text":"Internet-Adresse zum Zugriff auf \"Ressourcen\": html-Seiten, Bilder etc. Schema zum Aufbau eines URI's Um mit python eine URI zu lesen ben\u00f6tigt es eine einfachen Anweisung: import urllib2 url = \"http://endor.uni-trier.de/karto/python2/ch01/receipes/index.html\" response = urllib2.urlopen(url).read() print response","title":"URI: Uniform Request Identifier"},{"location":"ch02/internetkom.html#fehlerbehandlung","text":"Tritt ein Fehler bei der Kommunikation auf, erzeugt das Modul einen Ausnahmefehler, den wir abfangen k\u00f6nnen: import urllib2 def read_request(url): try: response = urllib2.urlopen(url).read() except (urllib2.HTTPError, urllib2.URLError): print \"error reading url:\", url return None return response url = \"http://endor.uni-trier.de/karto/python2/ch01/receipes/index.html\" resp = read_request(url) print resp Detailierte Fehlerbehandlung: Wir trennen read von urlopen und teilen Fehlerbehandlung in zwei auf anstelle der URL rufen wir das Request-Objekt ab (sp\u00e4ter mehr) import urllib2 def read_request(url): try: request = urllib2.Request(url) print request.headers response = urllib2.urlopen(request) data = response.read() return data except urllib2.HTTPError as e: print \"HTTP error reading url:\", url print \"Code\", e.code print \"Returns\", e.read() except urllib2.URLError as e: print \"URL error reading url:\", url print \"Reason:\", e.reason url = \"http://endor.uni-trier.de/karto/python2/ch01/receipes/index.html\" resp = read_request(url) print resp","title":"Fehlerbehandlung"},{"location":"ch02/internetkom.html#ablauf-einer-http-kommunikation","text":"HTTP: Anwendungsschicht von Netzwerkprotokollen Funktionen f\u00fcr Anwendungen auf der h\u00f6chsten Ebene Zustandslos, zwischen Anfragen kann nichts gespeichert werden Ausnahmen durch andere Techniken: Sitzungen (mit Login), Cookies Nachrichten zwischen Server und Client als Anfrage und Antwort Request und Response mit Header und Body Schema der Kommunikation mit HTTP Quelle: Slideshare GET Schickt einen Request, benutzt einen URI, um eine Ressource (Datei) anzufordern, Daten k\u00f6nnen in begrenztem Ma\u00df \u00fcber die URI \u00fcbermittelt werden POST - Schickt einen Request + Daten an den Server, Daten sind im POST-Body abgelegt und nicht begrenzt import urllib2 url = \"http://endor.uni-trier.de/karto/python2/ch01/receipes/index.html\" request = urllib2.Request(url) print \"URL\", request.get_full_url() print \"HOST\", request.get_host() print \"Method\", request.get_method() response = urllib2.urlopen(request) print \"Code\", response.code print \"Message\", response.msg print \"Headers\", response.headers.dict print \"Content-type:\", response.headers.dict[\"content-type\"] print \"Content-length:\", response.headers.dict[\"content-length\"] Der Content-type im response-Header ist ein sehr interessanter Teil des Headers, er teilt uns mit, welches Datenformat \u00fcbertragen wird (der MIME-Type). Erl\u00e4uterung zu m\u00f6glichen Werten. Um dem request via GET einen Header mitzugeben, kann der Queryteil des URI benutzt werden: https://www.w3schools.com/action_page.php?fname=andreas&lname=mueller url = \"https://www.w3schools.com/action_page.php?fname=andreas&lname=mueller\" request = urllib2.Request(url) response = urllib2.urlopen(request) print response.read() Mehr zum Modul und seinen M\u00f6glichkeiten finden wir in der Python-Online Dokumentation","title":"Ablauf einer http-Kommunikation"},{"location":"ch02/internetkom.html#daten-aus-dem-response-objekt-speichern","text":"Mit read haben wir bereits eine Methode zum Lesen von Daten kennengelernt. Die so erhalten Daten k\u00f6nnen wir in Dateien speichern: import urllib2 url = \"https://www.uni-trier.de/fileadmin/_migrated/pics/Zugang_Kartographie.png\" request = urllib2.Request(url) response = urllib2.urlopen(request) data = response.read() f = open(r\"c:\\tmp\\campus2.png\", \"wb\") # bin\u00e4re Datei schreiben f.write(data) f.close() Falls das Lesen der Daten besser kontrolliert werden soll (um Fehler oder eine gro\u00dfe Datenmenge zu managen), kann auch blockweise (im Sinne von gepuffert) vorgegangen werden: import urllib2 url = \"https://ia902604.us.archive.org/4/items/BennyGoodman_795/BennyGoodman1.mp3\" def download(url, dest): file_name = url.split('/')[-1] response = urllib2.urlopen(url) f = open(dest + file_name, 'wb') file_size_dl = 0 block_sz = 8192 while True: buffer = response.read(block_sz) if not buffer: break file_size_dl += len(buffer) f.write(buffer) f.close() return file_size_dl download(url, \"c:\\\\tmp\\\\\")","title":"Daten aus dem Response-Objekt speichern"},{"location":"ch02/internetkom.html#lesen-komprimierter-daten","text":"Manche Dienste verlangen, dass angeforderte Daten in komprimierter Form \u00fcbertragen werden sollen. In diesem Fall k\u00f6nnen wir das Modul gzip verwenden, um den Datenstrom zu entpacken: import gzip from StringIO import StringIO import urllib2 def getFileResponse(url): request = urllib2.Request(url) # accept compressed data request.add_header('Accept-Encoding', 'gzip') # request was sent, get response response = urllib2.urlopen(request) # is response compressed? if response.info().get('Content-Encoding') == 'gzip': # read data and uncompress it buf = StringIO(response.read()) # StingIO makes it readable for gzip f = gzip.GzipFile(fileobj=buf) # again: uncompressed data is a stream else: f = response return f url = \"https://www.uni-trier.de/\" f = getFileResponse(url) print f.read()","title":"Lesen komprimierter Daten"},{"location":"ch02/internetkom.html#eine-universelle-struktur-zum-lesen-mit-http","text":"Wir erstellen ein Modul urlreader : import gzip from StringIO import StringIO import urllib2 def uncompressIO(file_like): \"\"\"read a compressed file like stream, uses gzip, return a file-object\"\"\" buf = StringIO(file_like.read()) f = gzip.GzipFile(fileobj=buf) return f def openURL(url): \"\"\"Send a request to url, return the response\"\"\" try: request = urllib2.Request(url) request.add_header('Accept-Encoding', 'gzip') response = urllib2.urlopen(request) return response except urllib2.HTTPError as e: print \"HTTP error reading url:\", url print \"Code\", e.code print \"Returns\", e.read() except urllib2.URLError as e: print \"URL error reading url:\", url print \"Reason:\", e.reason return None def getFileResponse(url): \"\"\"example: how to read from compressing url, return a file object\"\"\" response = openURL(url) # is response compressed? if response.info().get('Content-Encoding') == 'gzip': # read data and uncompress it buf = StringIO(response.read()) # StingIO makes it readable for gzip f = gzip.GzipFile(fileobj=buf) # again: uncompressed data as a stream else: f = response return f if __name__ == '__main__': url = \"https://www.uni-trier.de/\" f = getFileResponse(url) print f.read() Wir speichern dieses Modul als urlreader01.py!","title":"eine universelle Struktur zum Lesen mit http"},{"location":"ch02/internetkom.html#xml-und-json-daten","text":"Einige Internetdienste, wie z.B. auf dem REST-Protokoll basierende Datenbanken, liefern als Response xml- oder json-Daten. REST: [Representational State Transfer] ist ein Programmierparadigma f\u00fcr verteilte Systeme, insbesondere Webdienste zur Kommunikation zwischen Maschinen, URL wird als Datenbankanfrage verstanden, jede \"Information\" hat ihre eigene Adresse (URL) daraus lassen sich Meshups erstellen: Internetseiten, die aus verschiedenen Quellen neu zusammengestellt werden wird mit den http-Befehlen umgesetzt Http-Befehle als Datenbankabfrage: GET: read a resource (Abfrage liefert Daten) POST: create a new resource (Abfrage erzeugt Dateneintrag) PUT: update a resource (Abfrage aktualisiert Datensatz) DELETE: remove a resource (Abfrage l\u00f6scht einen Dateneintrag) Das json-Format (Javascript Object Notation) wurde als Ersatz zu XML entwickelt nutzt die Javascript-Syntax ein XML-Tag wird zu einem Javascript-Objekt aufeinanderfolgende gleiche Tags werden zu einer Javascript-Liste Beispiele ein Javascript-Objekt wird in Python zu einem Dictionary, eine Javascript-Liste zu einer Python-Liste Hier ein Beispiel zur Umwandlung des Inhalts einer json-Datei: import json strJson = \"\"\"{\"employees\":[ { \"firstName\":\"John\", \"lastName\":\"Doe\" }, { \"firstName\":\"Anna\", \"lastName\":\"Smith\" }, { \"firstName\":\"Peter\", \"lastName\":\"Jones\" } ]}\"\"\" data = json.loads(strJson) # liest aus einem String print data Um direkt aus einer Datei zu lesen, kann ein File-Objekt erstellt und der Methode json.load() \u00fcbergeben werden: import json f = open(\"trgastro.geojson\") data = json.load(f) # liest aus einer Datei print data.keys() f.close() Als Ergebnis erhalten wir den Inhalt eines GeoJson-Objekts. mehr zu GeoJson Es enth\u00e4lt drei Strukturen: crs: Coordinate Reference System: den Daten zugrunde liegendes Koordinatensystem type: Feature Type, Geometrietyp: Point, LineString, Polygon, MultiPoint, MultiLineString und MultiPolygon features: Die eigentlichen Daten mit Geometrie und Sachattributen Das n\u00e4chste Beispiel nutzt den Dienst Pegelonline, um das Stationsnetz der Pegelmessstellen an deutschen Fl\u00fcssen im json-Format abzufragen. Nun kommt auch das Modul urlreader wieder zum Einsatz. import urlreader01 as urlreader import json def readRestJson(url): \"\"\"load a json structure from a REST-URL, returns a list/dict python object\"\"\" # read from http with url response = urlreader.openURL(url) if response.info().get('Content-Encoding') == 'gzip': data = json.load(urlreader.uncompressIO(response)) else: data = json.load(response) response.close() return data url = \"http://www.pegelonline.wsv.de/webservices/rest-api/v2/stations.json\" jsdata = readRestJson(url) print \"Anzahl der Stationen:\", len(jsdata) print \"Attribute:\", jsdata[0].keys() Im Prinzip unterscheidet sich diese Abfrage nicht von einem Datei-Download, nur das wir die Daten aus dem json Format in Python-Datentypen umgewandelt bekommen. Ergebnis ist eine Liste der Stationen Jede Station entspricht einem Dictionary mit den Attributen als Schl\u00fcssel Wir \u00fcbertragen die neue Funktion readRestJson() in unser Modul urlreader und nennen die Funktion getJsonResponse()! \u00c4nderungen: Angabe urlreader. entf\u00e4llt! Nun probieren wir eine andere Abfrage: http://www.pegelonline.wsv.de/webservices/rest-api/v2/stations.json?waters=MOSEL,SAAR Hier benutzen wir den Query-Teil der URL, um die Abfrage der Stationen auf die Fl\u00fcsse Mosel und Saar zu begrenzen. Testen Sie die Abfragen auch im Browser! Um die Daten auszuwerten, erstellen wir daraus eine Tabelle (zweidimensionale Liste) und geben diese aus: import urlreader01 as urlreader def getDataTable(jsdata, columns=[]): table = [] for st in jsdata: row = [] for key in columns: row.append(st[key] if key in st.keys() else None) table.append(row) return table url = \"http://www.pegelonline.wsv.de/webservices/rest-api/v2/stations.json?waters=MOSEL,SAAR\" jsdata = urlreader.getJsonResponse(url) print \"Anzahl der Stationen:\", len(jsdata) print \"Attribute:\", jsdata[0].keys() table = getDataTable(jsdata, [\"number\", \"longname\", \"agency\", \"longitude\", \"latitude\"]) print \"\\t\".join(map(str, [\"number\", \"longname\", \"agency\", \"longitude\", \"latitude\"])) for st in table: print u\"\\t\".join(map(unicode, st)) Daten aus dem Netz sind h\u00e4ufig als unicode (UTF-8) codiert, hier m\u00fcssen wir immer aufpassen, da python2 nicht automatisch zwischen String und Unicode umwandelt! Andererseits werden Sonderzeichen, die in UTF-8 erlaubt sind in einer URL immer maskiert. Sonderzeichen URL-maskierung Leerzeichen %20 \u00d6 %C3%96 \u00f6 %C3%B6 \u00c4 %C3%84 \u00e4 %C3%A4 \u00dc %C3%9C \u00fc %C3%BC Vergleiche auch den Artikel bei Wikipedia Da bei den Namen in einer Abfrage Umlaute vorkommen k\u00f6nnen, m\u00fcssen wir sicherstellen, dass diese korrekt in die URL eingetragen werden. - Gleichzeitig ein Beispiel zur Abfrage des Wasserstands der Station K\u00f6ln . import urlreader01 as urlreader def maskURLString(urlstr): return urlstr.replace(u\" \", u'%20').replace(u'\u00d6',u'%C3%96').replace(u'\u00c4',u'%C3%84').replace(u'\u00dc', u'%C3%9C') url = u\"http://www.pegelonline.wsv.de/webservices/rest-api/v2/stations/K\u00d6LN/W/currentmeasurement.json\" murl = maskURLString(url) jsdata = urlreader.getJsonResponse(murl) print jsdata Alternative zu maskURLString: urllib.quote_plus()","title":"XML- und json-Daten"},{"location":"ch02/internetkom.html#ein-eigenes-modul-urlreader","text":"Im Modul urlreader02 fassen wir die Erkenntnisse zusammen. Es soll diese Funktionen umfassen: openURL(url): benutzt die urllib2, um ein response-Objekt zur\u00fcckzugeben getJsonResponse(url): analog zu getDataResponse, liest den Datenstrom und gibt das Ergebnis von json.load() zur\u00fcck Hilfsfunktionen: maskURLString(), uncompressIO(), Neue Funktionen: - getFileResponse(url): \u00c4nderung der vorhandenen Funktion, der Datenstrom wird in einer Datei gespeichert - getDataResponse(url): benutzt openURL, liest den Datenstrom und speichert diesen in einer Variablen, das Ergebnis wird zur\u00fcckgegeben \u00fcberlegen Sie, wie die Daten mit getFileResponse bzw. getDataResponse blockweise gelesen werden k\u00f6nnen! Hilfsfunktion zum Entpacken eines blocks : def uncompressBuffer(buffer): buf = StringIO(buffer) f = gzip.GzipFile(fileobj=buf) data = f.read() return data Die Funktion arbeitet wie uncompressIO, nur das die Daten eines Blocks (hier buffer ) hier schon gelesen und damit entpackt werden. Wie kann das Modul objektorientiert aufgebaut werden?","title":"Ein eigenes Modul: urlreader"},{"location":"ch02/p01_urlreader.html","text":"Pegelonline F\u00fcr unser QGIS-Plugin verwenden wir Daten vom Server der Wasserstra\u00dfen- und Schifffahrtsverwaltung des Bundes (WSV), um eine Analyse und Darstellung des Pegelmessnetzes f\u00fcr Deutschlands Fl\u00fcsse zu erm\u00f6glichen. Daf\u00fcr geeignet sind verschiedene Dienste, die auf der Seite angeboten werden: REST- und XML-basierte Webservices SOAP-Webservices Geographische Informationsdienste REST- und SOAP-Webservices weisen \u00e4hnliche Merkmale auf, w\u00e4hrend die GIS-Dienste die bekannten OpenGIS Web Services wie WMS und WFS umfassen. F\u00fcr das Plugin wollen wir den Rest-Service verwenden, um die Daten zu den Messstationen und Wasserst\u00e4nden verarbeiten zu k\u00f6nnen. REST steht f\u00fcr Representational State Transfer und erm\u00f6glicht einen Zugriff auf Datenbest\u00e4nde \u00fcber URL's, bzw. auf Basis des HTT-Protokolls mit seinen Befehlen GET, PUT, DELETE, POST. Der Abruf von Daten erfolgt \u00fcber die im Web gebr\u00e4uchlichen Formate XML oder JSON. Im Folgenden werden wir die Python-Werkzeuge kennenlernen, um die Daten abrufen zu k\u00f6nnen. Python f\u00fcr die Internetkommunikation urllib ist ein Python-Standardpackage zur Internetkommunikation \u00fcber das http-Protokoll. In der Standardbibliothek finden sich au\u00dferdem Module f\u00fcr alle anderen Zwecke der Internetkommunikation, wie ftplib, cgi oder smtpd - bis hin zum http-Server (SimpleHttpServer) urllib Einfache Verwendung \u00fcber urllib.request-Modul: import urllib.request with urllib.request.urlopen('http://python.org/') as response: html = response.read() ohne with : import urllib.request response = urllib.request.urlopen('http://python.org/') html = response.read() Der Aufruf von read() liest die Antwort komplett ein und gibt ein bytes-Objekt zur\u00fcck. Das Objekt ist einem String \u00e4hnlich, allerdings haben wir in python3 die Unterscheidung zwischen String (default: UTF-8) und Bytes (m\u00fcssen interpretiert werden, als Zahl oder mit Text-Codec). urlib-Aufruf mit urlopen genauer: urllib.request.urlopen(url, data=None, [timeout, ]*, cafile=None, capath=None, cadefault=False, context=None) gibt ein http.client.HTTPResponse-Objekt zur\u00fcck. Dokumentation URI: Uniform Request Identifier Internet-Adresse zum Zugriff auf \"Ressourcen\": html-Seiten, Bilder etc. Schema zum Aufbau eines URI's Fehlerbehandlung Tritt ein Fehler bei der Kommunikation auf, erzeugt das Modul verschiedene Ausnahmefehler, die wir abfangen k\u00f6nnen. URLError: Der Aufruf der Seite scheitert, es kam keine Verbindung zustande HTTPError: Der Server Antwortet, gibt aber einen Fehler-Code zur\u00fcck. Code 200: OK, kein Fehler (alle Codes zwischen 100-299) Code 404: Fehler, Seite nicht gefunden Code 403: Request wurde nicht akzeptiert weitere Codes definiert das Dokument RFC 2616 unter Kapitel 10 Bespiel f\u00fcr einen URLError : import urllib.request import urllib.error try: response = urllib.request.urlopen('http://pythonx.org/') # Fehlerhafte URL except urllib.error.URLError as e: print(e.reason) else: html = response.read() Beispiel f\u00fcr einen HTTPError: import urllib.request import urllib.error try: response = urllib.request.urlopen('http://www.python.org/fish.html') # unbekannte Ressource except urllib.error.HTTPError as e: print(e.code) print(e.read()) # Liest die Fehlermeldung else: html = response.read() Ablauf einer http-Kommunikation HTTP: Anwendungsschicht von Netzwerkprotokollen Funktionen f\u00fcr Anwendungen auf der h\u00f6chsten Ebene Zustandslos, zwischen Anfragen kann nichts gespeichert werden Ausnahmen durch andere Techniken: Sitzungen (mit Login), Cookies Nachrichten zwischen Server und Client als Anfrage und Antwort Request und Response mit Header und Body Schema der Kommunikation mit HTTP Quelle: Slideshare GET Schickt einen Request mit GET URI, um eine Ressource (Datei) anzufordern, Kein Body, Daten k\u00f6nnen \u00fcber die URI \u00fcbermittelt werden Beispiel: Abruf einer PDF-Datei von StudIP POST - Schickt einen Request mit POST URI + Daten an den Server, - Daten sind im POST-Body abgelegt und nicht begrenzt - Beispiel: Dateiupload in StudIP In diesem Beispiel trennen wir die Definition des Request vom Response-Ausruf urlopen, damit wir sehen, was der Request enth\u00e4lt, bevor wir ihn abschicken: req = urllib.request.Request('https://www.uni-trier.de/') print(\"URL\", req.full_url) print(\"HOST\", req.host) print(\"Method\", req.get_method()) response = urllib.request.urlopen(req) print(\"Code\", response.code) print(\"Message\", response.msg) print(\"Headers\", response.getheaders()) headers = dict(response.headers) print(\"Content-type:\", headers[\"Content-Type\"]) print(\"Content-length:\", headers[\"Content-Length\"]) URL mit Sonderzeichen Prinzipiell k\u00f6nnen in der URL auch Umlaute und andere Sonderzeichen vorhanden sein, sie m\u00fcssen nur korrekt umgewandelt werden. Die urllib erm\u00f6glicht dies \u00fcber eine Codierer/Decodierer: urllib.parse.quote und unquote # \"http://www.pegelonline.wsv.de/webservices/rest-api/v2/stations/K\u00d6LN/W/currentmeasurement.json\" url = \"http://www.pegelonline.wsv.de/webservices/rest-api/v2/stations/%s/W/currentmeasurement.json\" param = urllib.parse.quote(\"K\u00d6LN\") url = url%param print(url) print(urllib.parse.unquote(url)) Sonderzeichen URL-maskierung Leerzeichen %20 \u00d6 %C3%96 \u00f6 %C3%B6 \u00c4 %C3%84 \u00e4 %C3%A4 \u00dc %C3%9C \u00fc %C3%BC Vergleiche auch den Artikel bei Wikipedia Lesen komprimierter Daten Manche Dienste verlangen, dass angeforderte Daten in komprimierter Form \u00fcbertragen werden sollen. Gzip ist ein Format zur Datenkompression, normalerweise auf der Basis von Dateien, es wird aber auch f\u00fcr Datenstr\u00f6me eingesetzt. Pegelonline erwartet, dass die Daten komprimiert abgerufen werden, weil dadurch der Traffic , also das Datenvolumen, im Netz reduziert wird. In diesem Fall k\u00f6nnen wir das Python-Modul gzip verwenden, um den Datenstrom zu entpacken. Dokumentation Gzip funktioniert ananlog zum \u00d6ffnen einer Datei: import gzip fn = 'temp_1961-90.csv.gz' # benutzt gzip's open, f ist gzip-object with gzip.open(fn, 'rb') as f: file_content = f.read() # oder dasselbe in kurz file_content = gzip.open(fn, 'rb').read() # benutzt GzipFile file_content = gzip.GzipFile(fn).read() # benutzt normales open (f ist eine file object) # und dann GzipFile mit fileobj-Parameter with open(fn, 'rb') as f: file_content = gzip.GzipFile(fileobj=f).read() Streams, die \u00fcber ein response-Objekt gelesen werden, kann gzip dann auch verarbeiten. Der Parameter fileobj nutzt nun den response anstelle einer ge\u00f6ffneten Datei. import gzip url = \"https://www.pegelonline.wsv.de/webservices/rest-api/v2/stations.json\" req = urllib.request.Request(url) req.add_header('Accept-Encoding', 'gzip') data = None try: response = urllib.request.urlopen(req) if response.headers['Content-Encoding'] == 'gzip': data = gzip.GzipFile(fileobj=response).read() else: data = response.read() except urllib.error.URLError as e: print(e.reason) except urllib.error.HTTPError as e: print(e.code) Daten aus dem Response-Objekt speichern Mit read haben wir bereits eine Methode zum Lesen von Daten kennengelernt. Die so erhalten Daten k\u00f6nnen wir in Dateien speichern: response = urllib.request.urlopen('https://www.python.org/static/img/python-logo.png') data = response.read() f = open(r\"c:/tmp/python-logo.png\", \"wb\") # bin\u00e4re Datei schreiben f.write(data) f.close() Nicht immer kennen wir den Dateinamen, unter dem die Daten gespeichert werden k\u00f6nnen, sondern m\u00fcssen ihn aus der URL extrahieren - doch Vorsicht, er kann f\u00fcr das Betriebssystem ung\u00fcltige Zeichen enthalten! Empfohlen wird hier die URL in ihre Bestanteile zu zerlegen, mit urllib.parse.urlparse und os.path.basename k\u00f6nnen wir dies leicht umsetzen: import os import urllib.parse result = urllib.parse.urlparse('https://www.python.org/static/img/python-logo.png') print(result.path) print(os.path.basename(result.path)) Das os.path-Modul kann auch \u00fcberpr\u00fcfen, ob ein Pfad existiert (os.path.exists) oder einen Pfad aus mehreren Teilen zusammensetzen (os.path.join). Dokumentation Schnelldurchlauf von effbot.org Aufgabe zum Speichern Wir schreiben ein Script, dass eine Datei \u00fcber das HTTP-Protokoll liest und in einem vorgebenen Ort speichert. Hier der Rohbau: import os import urllib url = \"https://ia800302.us.archive.org/8/items/BennyGoodmanQuartetAndTrio/BodySoul-BennyGoodmanGeneKrupaTeddyWilsoncarnegieHall1938_64kb.mp3\" dest = \"C:/temp\" def download(url, dest): pass Daten in Form von XML- oder JSON-Strukturen umwandeln Daten\u00fcbertragung im Internet basiert h\u00e4ufig auf XML oder json-Formaten. F\u00fcr beide h\u00e4lt die Python-Stadardbibliothek Module bereit. Hier lernen wir das Modul json kennen. Mit json ist es m\u00f6glich, Python-Datenstrukturen aus Lists, Tuples, Dictionaries etc. im json-Textformat zu speichern bzw. umgekehrt json-Dateien zu lesen und in eine Python-Datenstruktur zu \u00fcbersetzen. Dokumentation Wikipedia-Artikel zu JSON Hier ein Beispiel zur Umwandlung von json nach Python: import json strJson = \"\"\"{\"employees\":[ { \"firstName\":\"John\", \"lastName\":\"Doe\" }, { \"firstName\":\"Anna\", \"lastName\":\"Smith\" }, { \"firstName\":\"Peter\", \"lastName\":\"Jones\" } ]}\"\"\" data = json.loads(strJson) # liest aus einem String print data Die Anwendung des json-Moduls ist sehr einfach, \u00fcber load() bzw loads() werden json-Daten gelesen und umgewandelt. Der umgekehrte Weg erfolgt durch dump() bzw dumps() . Dazu: ein Tutorial von realpython GeoJSON Die bereits bekannte Datei temp_1961-90 liegt in diesem Beispiel im geojson-Format vor. Geojson besitzt eine festgelegte Struktur, um Geodaten mit Geometrie und Sachdaten zu speichern. Beschreibung von GeoJSON { \"type\": \"FeatureCollection\", ... \"features\": [ { \"type\": \"Feature\", \"properties\": { \"ALIASNAME\": \"AACHEN (WEWA)\", \"H\u00f6he \u00fc NN\": \"202\", ... }, \"geometry\": { \"type\": \"Point\", \"coordinates\": [ 6.083333333333333, 50.783333333333331 ] } } ] } Umwandlung von GeoJSON import json fn = 'temp_1961-90.geojson' # ge\u00f6ffnete Datei wird von json.load() gelesen, interpretiert # und umgewandelt with open(fn, mode='r') as f: data = json.load(f) # ge\u00f6ffnete Datei wird als String gelesen # und anschlie\u00dfend umgewandelt: json.loads() 'load string' with open(fn, mode='r') as f: data_string = f.read() data = json.loads(data_string) Aufgabe Teil A: Wir schreiben ein objektorientiertes Modul, um Daten via urllib herunterzuladen F\u00fcr json-Daten benutzen wir die Umwandlung-Funktion des json-Moduls F\u00fcr Dateien sehen wir eine Speicherung in einer Datei vor Ein grober Entwurf f\u00fcr das Modul: class UrlReader(object): def __init__(self): pass def openUrl(self): pass def getDataResponse(self): pass def getJsonResponse(self): pass def getFileResponse(self): pass Anforderungen: openUrl: Erstellt ein request-Objekt und f\u00fcgt einen Header zur gzip-Komprimierung der Daten hinzu. Es \u00f6ffnet die Verbindung, testet auf Fehler und gibt bei Erfolg das response-Objekt zur\u00fcck. getDataResponse: ruft openURL auf und benutzt das zur\u00fcckgegenen Response-Objekt, um die Daten zu lesen. Wurden die Daten mit gzip komprimiert, wird der Datenstrom entpackt, die eingelesenen Daten werden anschlie\u00dfend zur\u00fcckgegeben. getJsonResponse: ruft getDataResponse, und wandelt die erhaltenen Daten mit mit dem json-Modul um. Das Ergebnis wird zur\u00fcckgegeben. getFileResponse: ruft getDataResponse, und schreibt die erhaltenen Daten in eine Datei. Dazu wird ein Dateiname erzeugt, dieser wird am Ende zur\u00fcckgegeben. \u00dcberlegen Sie, wie ein Ausgabepfad ber\u00fccksichtigt werden kann. Teil B: F\u00fcr die heruntergeladenen JSON-Daten von Pegelonline schreiben wir eine Funktion getDataTable(), die aus der Datenstruktur ein zweidimensionales Array (List) erzeugt. Anders ausgedr\u00fcckt, wir wollen die Daten in Form einer Tabelle vorliegen haben: def getDataTable(jsdata, columns): pass table = getDataTable(jsdata, [\"number\", \"longname\", \"agency\", \"longitude\", \"latitude\"]) Hierbei nutzen wir columns als keys f\u00fcr die Dictionaries und erzeugen eine Liste mit den Werten als Zeile userer Tabelle.","title":"Internetkommunikation"},{"location":"ch02/p01_urlreader.html#pegelonline","text":"F\u00fcr unser QGIS-Plugin verwenden wir Daten vom Server der Wasserstra\u00dfen- und Schifffahrtsverwaltung des Bundes (WSV), um eine Analyse und Darstellung des Pegelmessnetzes f\u00fcr Deutschlands Fl\u00fcsse zu erm\u00f6glichen. Daf\u00fcr geeignet sind verschiedene Dienste, die auf der Seite angeboten werden: REST- und XML-basierte Webservices SOAP-Webservices Geographische Informationsdienste REST- und SOAP-Webservices weisen \u00e4hnliche Merkmale auf, w\u00e4hrend die GIS-Dienste die bekannten OpenGIS Web Services wie WMS und WFS umfassen. F\u00fcr das Plugin wollen wir den Rest-Service verwenden, um die Daten zu den Messstationen und Wasserst\u00e4nden verarbeiten zu k\u00f6nnen. REST steht f\u00fcr Representational State Transfer und erm\u00f6glicht einen Zugriff auf Datenbest\u00e4nde \u00fcber URL's, bzw. auf Basis des HTT-Protokolls mit seinen Befehlen GET, PUT, DELETE, POST. Der Abruf von Daten erfolgt \u00fcber die im Web gebr\u00e4uchlichen Formate XML oder JSON. Im Folgenden werden wir die Python-Werkzeuge kennenlernen, um die Daten abrufen zu k\u00f6nnen.","title":"Pegelonline"},{"location":"ch02/p01_urlreader.html#python-fur-die-internetkommunikation","text":"urllib ist ein Python-Standardpackage zur Internetkommunikation \u00fcber das http-Protokoll. In der Standardbibliothek finden sich au\u00dferdem Module f\u00fcr alle anderen Zwecke der Internetkommunikation, wie ftplib, cgi oder smtpd - bis hin zum http-Server (SimpleHttpServer)","title":"Python f\u00fcr die Internetkommunikation"},{"location":"ch02/p01_urlreader.html#urllib","text":"Einfache Verwendung \u00fcber urllib.request-Modul: import urllib.request with urllib.request.urlopen('http://python.org/') as response: html = response.read() ohne with : import urllib.request response = urllib.request.urlopen('http://python.org/') html = response.read() Der Aufruf von read() liest die Antwort komplett ein und gibt ein bytes-Objekt zur\u00fcck. Das Objekt ist einem String \u00e4hnlich, allerdings haben wir in python3 die Unterscheidung zwischen String (default: UTF-8) und Bytes (m\u00fcssen interpretiert werden, als Zahl oder mit Text-Codec). urlib-Aufruf mit urlopen genauer: urllib.request.urlopen(url, data=None, [timeout, ]*, cafile=None, capath=None, cadefault=False, context=None) gibt ein http.client.HTTPResponse-Objekt zur\u00fcck. Dokumentation","title":"urllib"},{"location":"ch02/p01_urlreader.html#uri-uniform-request-identifier","text":"Internet-Adresse zum Zugriff auf \"Ressourcen\": html-Seiten, Bilder etc. Schema zum Aufbau eines URI's","title":"URI: Uniform Request Identifier"},{"location":"ch02/p01_urlreader.html#fehlerbehandlung","text":"Tritt ein Fehler bei der Kommunikation auf, erzeugt das Modul verschiedene Ausnahmefehler, die wir abfangen k\u00f6nnen. URLError: Der Aufruf der Seite scheitert, es kam keine Verbindung zustande HTTPError: Der Server Antwortet, gibt aber einen Fehler-Code zur\u00fcck. Code 200: OK, kein Fehler (alle Codes zwischen 100-299) Code 404: Fehler, Seite nicht gefunden Code 403: Request wurde nicht akzeptiert weitere Codes definiert das Dokument RFC 2616 unter Kapitel 10 Bespiel f\u00fcr einen URLError : import urllib.request import urllib.error try: response = urllib.request.urlopen('http://pythonx.org/') # Fehlerhafte URL except urllib.error.URLError as e: print(e.reason) else: html = response.read() Beispiel f\u00fcr einen HTTPError: import urllib.request import urllib.error try: response = urllib.request.urlopen('http://www.python.org/fish.html') # unbekannte Ressource except urllib.error.HTTPError as e: print(e.code) print(e.read()) # Liest die Fehlermeldung else: html = response.read()","title":"Fehlerbehandlung"},{"location":"ch02/p01_urlreader.html#ablauf-einer-http-kommunikation","text":"HTTP: Anwendungsschicht von Netzwerkprotokollen Funktionen f\u00fcr Anwendungen auf der h\u00f6chsten Ebene Zustandslos, zwischen Anfragen kann nichts gespeichert werden Ausnahmen durch andere Techniken: Sitzungen (mit Login), Cookies Nachrichten zwischen Server und Client als Anfrage und Antwort Request und Response mit Header und Body Schema der Kommunikation mit HTTP Quelle: Slideshare GET Schickt einen Request mit GET URI, um eine Ressource (Datei) anzufordern, Kein Body, Daten k\u00f6nnen \u00fcber die URI \u00fcbermittelt werden Beispiel: Abruf einer PDF-Datei von StudIP POST - Schickt einen Request mit POST URI + Daten an den Server, - Daten sind im POST-Body abgelegt und nicht begrenzt - Beispiel: Dateiupload in StudIP In diesem Beispiel trennen wir die Definition des Request vom Response-Ausruf urlopen, damit wir sehen, was der Request enth\u00e4lt, bevor wir ihn abschicken: req = urllib.request.Request('https://www.uni-trier.de/') print(\"URL\", req.full_url) print(\"HOST\", req.host) print(\"Method\", req.get_method()) response = urllib.request.urlopen(req) print(\"Code\", response.code) print(\"Message\", response.msg) print(\"Headers\", response.getheaders()) headers = dict(response.headers) print(\"Content-type:\", headers[\"Content-Type\"]) print(\"Content-length:\", headers[\"Content-Length\"])","title":"Ablauf einer http-Kommunikation"},{"location":"ch02/p01_urlreader.html#url-mit-sonderzeichen","text":"Prinzipiell k\u00f6nnen in der URL auch Umlaute und andere Sonderzeichen vorhanden sein, sie m\u00fcssen nur korrekt umgewandelt werden. Die urllib erm\u00f6glicht dies \u00fcber eine Codierer/Decodierer: urllib.parse.quote und unquote # \"http://www.pegelonline.wsv.de/webservices/rest-api/v2/stations/K\u00d6LN/W/currentmeasurement.json\" url = \"http://www.pegelonline.wsv.de/webservices/rest-api/v2/stations/%s/W/currentmeasurement.json\" param = urllib.parse.quote(\"K\u00d6LN\") url = url%param print(url) print(urllib.parse.unquote(url)) Sonderzeichen URL-maskierung Leerzeichen %20 \u00d6 %C3%96 \u00f6 %C3%B6 \u00c4 %C3%84 \u00e4 %C3%A4 \u00dc %C3%9C \u00fc %C3%BC Vergleiche auch den Artikel bei Wikipedia","title":"URL mit Sonderzeichen"},{"location":"ch02/p01_urlreader.html#lesen-komprimierter-daten","text":"Manche Dienste verlangen, dass angeforderte Daten in komprimierter Form \u00fcbertragen werden sollen. Gzip ist ein Format zur Datenkompression, normalerweise auf der Basis von Dateien, es wird aber auch f\u00fcr Datenstr\u00f6me eingesetzt. Pegelonline erwartet, dass die Daten komprimiert abgerufen werden, weil dadurch der Traffic , also das Datenvolumen, im Netz reduziert wird. In diesem Fall k\u00f6nnen wir das Python-Modul gzip verwenden, um den Datenstrom zu entpacken. Dokumentation Gzip funktioniert ananlog zum \u00d6ffnen einer Datei: import gzip fn = 'temp_1961-90.csv.gz' # benutzt gzip's open, f ist gzip-object with gzip.open(fn, 'rb') as f: file_content = f.read() # oder dasselbe in kurz file_content = gzip.open(fn, 'rb').read() # benutzt GzipFile file_content = gzip.GzipFile(fn).read() # benutzt normales open (f ist eine file object) # und dann GzipFile mit fileobj-Parameter with open(fn, 'rb') as f: file_content = gzip.GzipFile(fileobj=f).read() Streams, die \u00fcber ein response-Objekt gelesen werden, kann gzip dann auch verarbeiten. Der Parameter fileobj nutzt nun den response anstelle einer ge\u00f6ffneten Datei. import gzip url = \"https://www.pegelonline.wsv.de/webservices/rest-api/v2/stations.json\" req = urllib.request.Request(url) req.add_header('Accept-Encoding', 'gzip') data = None try: response = urllib.request.urlopen(req) if response.headers['Content-Encoding'] == 'gzip': data = gzip.GzipFile(fileobj=response).read() else: data = response.read() except urllib.error.URLError as e: print(e.reason) except urllib.error.HTTPError as e: print(e.code)","title":"Lesen komprimierter Daten"},{"location":"ch02/p01_urlreader.html#daten-aus-dem-response-objekt-speichern","text":"Mit read haben wir bereits eine Methode zum Lesen von Daten kennengelernt. Die so erhalten Daten k\u00f6nnen wir in Dateien speichern: response = urllib.request.urlopen('https://www.python.org/static/img/python-logo.png') data = response.read() f = open(r\"c:/tmp/python-logo.png\", \"wb\") # bin\u00e4re Datei schreiben f.write(data) f.close() Nicht immer kennen wir den Dateinamen, unter dem die Daten gespeichert werden k\u00f6nnen, sondern m\u00fcssen ihn aus der URL extrahieren - doch Vorsicht, er kann f\u00fcr das Betriebssystem ung\u00fcltige Zeichen enthalten! Empfohlen wird hier die URL in ihre Bestanteile zu zerlegen, mit urllib.parse.urlparse und os.path.basename k\u00f6nnen wir dies leicht umsetzen: import os import urllib.parse result = urllib.parse.urlparse('https://www.python.org/static/img/python-logo.png') print(result.path) print(os.path.basename(result.path)) Das os.path-Modul kann auch \u00fcberpr\u00fcfen, ob ein Pfad existiert (os.path.exists) oder einen Pfad aus mehreren Teilen zusammensetzen (os.path.join). Dokumentation Schnelldurchlauf von effbot.org","title":"Daten aus dem Response-Objekt speichern"},{"location":"ch02/p01_urlreader.html#aufgabe-zum-speichern","text":"Wir schreiben ein Script, dass eine Datei \u00fcber das HTTP-Protokoll liest und in einem vorgebenen Ort speichert. Hier der Rohbau: import os import urllib url = \"https://ia800302.us.archive.org/8/items/BennyGoodmanQuartetAndTrio/BodySoul-BennyGoodmanGeneKrupaTeddyWilsoncarnegieHall1938_64kb.mp3\" dest = \"C:/temp\" def download(url, dest): pass","title":"Aufgabe zum Speichern"},{"location":"ch02/p01_urlreader.html#daten-in-form-von-xml-oder-json-strukturen-umwandeln","text":"Daten\u00fcbertragung im Internet basiert h\u00e4ufig auf XML oder json-Formaten. F\u00fcr beide h\u00e4lt die Python-Stadardbibliothek Module bereit. Hier lernen wir das Modul json kennen. Mit json ist es m\u00f6glich, Python-Datenstrukturen aus Lists, Tuples, Dictionaries etc. im json-Textformat zu speichern bzw. umgekehrt json-Dateien zu lesen und in eine Python-Datenstruktur zu \u00fcbersetzen. Dokumentation Wikipedia-Artikel zu JSON Hier ein Beispiel zur Umwandlung von json nach Python: import json strJson = \"\"\"{\"employees\":[ { \"firstName\":\"John\", \"lastName\":\"Doe\" }, { \"firstName\":\"Anna\", \"lastName\":\"Smith\" }, { \"firstName\":\"Peter\", \"lastName\":\"Jones\" } ]}\"\"\" data = json.loads(strJson) # liest aus einem String print data Die Anwendung des json-Moduls ist sehr einfach, \u00fcber load() bzw loads() werden json-Daten gelesen und umgewandelt. Der umgekehrte Weg erfolgt durch dump() bzw dumps() . Dazu: ein Tutorial von realpython","title":"Daten in Form von XML- oder JSON-Strukturen umwandeln"},{"location":"ch02/p01_urlreader.html#geojson","text":"Die bereits bekannte Datei temp_1961-90 liegt in diesem Beispiel im geojson-Format vor. Geojson besitzt eine festgelegte Struktur, um Geodaten mit Geometrie und Sachdaten zu speichern. Beschreibung von GeoJSON { \"type\": \"FeatureCollection\", ... \"features\": [ { \"type\": \"Feature\", \"properties\": { \"ALIASNAME\": \"AACHEN (WEWA)\", \"H\u00f6he \u00fc NN\": \"202\", ... }, \"geometry\": { \"type\": \"Point\", \"coordinates\": [ 6.083333333333333, 50.783333333333331 ] } } ] }","title":"GeoJSON"},{"location":"ch02/p01_urlreader.html#umwandlung-von-geojson","text":"import json fn = 'temp_1961-90.geojson' # ge\u00f6ffnete Datei wird von json.load() gelesen, interpretiert # und umgewandelt with open(fn, mode='r') as f: data = json.load(f) # ge\u00f6ffnete Datei wird als String gelesen # und anschlie\u00dfend umgewandelt: json.loads() 'load string' with open(fn, mode='r') as f: data_string = f.read() data = json.loads(data_string)","title":"Umwandlung von GeoJSON"},{"location":"ch02/p01_urlreader.html#aufgabe","text":"Teil A: Wir schreiben ein objektorientiertes Modul, um Daten via urllib herunterzuladen F\u00fcr json-Daten benutzen wir die Umwandlung-Funktion des json-Moduls F\u00fcr Dateien sehen wir eine Speicherung in einer Datei vor Ein grober Entwurf f\u00fcr das Modul: class UrlReader(object): def __init__(self): pass def openUrl(self): pass def getDataResponse(self): pass def getJsonResponse(self): pass def getFileResponse(self): pass Anforderungen: openUrl: Erstellt ein request-Objekt und f\u00fcgt einen Header zur gzip-Komprimierung der Daten hinzu. Es \u00f6ffnet die Verbindung, testet auf Fehler und gibt bei Erfolg das response-Objekt zur\u00fcck. getDataResponse: ruft openURL auf und benutzt das zur\u00fcckgegenen Response-Objekt, um die Daten zu lesen. Wurden die Daten mit gzip komprimiert, wird der Datenstrom entpackt, die eingelesenen Daten werden anschlie\u00dfend zur\u00fcckgegeben. getJsonResponse: ruft getDataResponse, und wandelt die erhaltenen Daten mit mit dem json-Modul um. Das Ergebnis wird zur\u00fcckgegeben. getFileResponse: ruft getDataResponse, und schreibt die erhaltenen Daten in eine Datei. Dazu wird ein Dateiname erzeugt, dieser wird am Ende zur\u00fcckgegeben. \u00dcberlegen Sie, wie ein Ausgabepfad ber\u00fccksichtigt werden kann. Teil B: F\u00fcr die heruntergeladenen JSON-Daten von Pegelonline schreiben wir eine Funktion getDataTable(), die aus der Datenstruktur ein zweidimensionales Array (List) erzeugt. Anders ausgedr\u00fcckt, wir wollen die Daten in Form einer Tabelle vorliegen haben: def getDataTable(jsdata, columns): pass table = getDataTable(jsdata, [\"number\", \"longname\", \"agency\", \"longitude\", \"latitude\"]) Hierbei nutzen wir columns als keys f\u00fcr die Dictionaries und erzeugen eine Liste mit den Werten als Zeile userer Tabelle.","title":"Aufgabe"},{"location":"ch02/p02_jsonqgis.html","text":"Die Pegelonline Schnittstelle Auf Basis des Moduls urlreader lassen sich die Daten von Pegelonline herunterladen. Eine Betrachtung der Restschnittstelle zeigt verschiedene M\u00f6glichkeiten auf. Insbesondere ist es m\u00f6glich: alle Stationen, quasi als Stammdaten, mit diversen Attributen zu verwenden Station mit ID, Name, Ort, Gew\u00e4sser, Betreiber die an einer Station gemessenen Parameter (timeseries) Referenzwerte zur Klassifikation (characteristic values) aktuelle Messwerte aller Stationen, f\u00fcr jeden dort erhobenen Parameter zu erhalten (currentMeasurment) der h\u00e4ufigste gemessene Parameter ist der Wasserstand (timeseries=W) eine Zeitreihe f\u00fcr einen Parameter f\u00fcr eine einzelne Station, f\u00fcr maximal 30 Tage hier ist es m\u00f6glich, die Daten als Grafik oder im JSON-Format abzurufen. Abfragen verarbeiten Mit Ausnahme der stationsbezogenen Zeitreihen, m\u00fcsssen zwei Schritte durchlaufen werden, um die Daten von Pegelonline in QGIS als Karte anzuzeigen. Die JSON-Daten m\u00fcssen in eine Tabellenstruktur \u00fcberf\u00fchrt werden, bzw. nach Geometrie und Attributen getrennt werden. Aus den Angaben m\u00fcssen QGIS-Features erzeugt werden und diese in einem Layer gespeichert werden. Die dritte Abfragem\u00f6glichkeiten zu einzelnen Stationen k\u00f6nnen wir sp\u00e4ter im Plugin anzeigen. In der \u00dcbung der letzen Einheit haben wir bereits ein Modul geschrieben, auf dem die Datenverarbeitung aufbaut, den UrlReader. Auch haben wir bereits gesehen, wie die Daten in eine tabellarische Form gebracht werden k\u00f6nnen. Wir werden nun eine \u00fcbergeordnete Struktur schaffen, um die Funktionen zu strukturieren. Hierzu legen wir uns ein python-package an, dazu ben\u00f6tigen wir: einen Ordner mit einem sinnvollen Namen, darin eine Datei __init__.py und eine Kopie des Urlreaders Wir wollen entsprechend der M\u00f6glichkeiten von Pegelonline dort Module anlegen, und objektorientiert die zwei beschriebenen Schritte implementieren. Wir erstellen zun\u00e4chst: ein Modul f\u00fcr die Stationsabfrage mit Stammdaten ein Modul zur Erstellung der QGIS-Features f\u00fcr die Stationen Stationen: Abfrage mit stations.json lesen Geometrie aus 'longitude', 'latitude' und Attribute aus 'uuid', 'number', 'shortname', 'longname', 'km', 'agency', 'water' (water->shortname) Sp\u00e4ter implementieren wir analog die Abfrage den aktuellen Wasserst\u00e4nden mit entsprechenden Modulen, die Abfrage lautet dann stations.json?timeseries=W&includeTimeseries=true&includeCurrentMeasurement=true geometrie = 'longitude', 'latitude' attribute = 'uuid', 'shortname', 'time', 'value', 'trend', 'stateMnwMhw', 'stateNswHsw' alle ab timestamp: ['timeseries'][0]['currentMeasurement'] ['timestamp'] ... Der Ordner mit dem Python-Package + pomodules - __init__.py - urlreader.py - postations.py - poqgsstations.py Bei den Modul- und Klassennamen kann es sinnvoll sein einen gemeinsamen Pr\u00e4fix zu verwenden, hier wurde po for PegelOnline benutzt, ausserdem sollen die Namen kennzeichnen, f\u00fcr welche Teilaufgabe oder Datenbereich sie stehen, hier stations . Die Aufbereitung f\u00fcr QGIS wird dann mit qgs versehen. Viele Pythonprogrammierer schreiben Modulnamen einer Klasse klein und den Klassennamen dann in CamelCase . Die Datei __init__.py steht f\u00fcr die Initialisierung des Package und kann leer bleiben. Hier allerdings wurde die Variable poBaseURL definiert, die von mehreren Modulen genutzt wird und den Anfangsstring f\u00fcr jede PegelOnline-Abfrage beinhaltet. Das ist zudem praktisch, falls sich diese Adresse einmal \u00e4ndern sollte... # modul __init__ poBaseURL = 'https://www.pegelonline.wsv.de/webservices/rest-api/v2/' Modul der Stationsabfrage mit Stammdaten # modul postations from pomodules.urlreader import Urlreader class PoStations(object): def __init__(self): self.url = poBaseURL + 'stations.json' def getData(self): ur = Urlreader(self.url) json_data = ur.getJsonResponse() stations = [] # process all stations return stations Da wir sp\u00e4ter Geometrie und Attribute getrennt verarbeiten, bietet es sich an, dies schon auf dieser Ebene zu tun, z.B. als dictionary: station = { 'geometry': (d['longitude'], d['latitude']), 'attributes': ( d['uuid'], d['number'], d['shortname'], d['longname'], d['km'], d['agency'], d['water']['longname'] ) } Denken Sie daran, dass die Daten aus unserer Sicht Fehler enthalten k\u00f6nnen. So gibt es Stationen, die keine Eintr\u00e4ge f\u00fcr d['longitude'] und d['latitude'] haben. Die Abfrage oben f\u00fchrt zu einer eingeschr\u00e4nkten Anzahl an Attributen f\u00fcr die Stationen. Je nachdem, welche Verarbeitungen wir uns im QGIS vorstellen, kann es notwendig sein, die Attribute zu erweitern. Modul zur Erstellung von QGIS-Features Die empfangenen und aufbereiteten Daten werden nun in eine Liste mit QGIS-Features umgewandelt. Dazu ben\u00f6tigen wir auch eine Liste der Felddefinitionen als QgsFields-Objekt. Name Datentyp 'uuid' String 'number' Int 'shortname' String 'longname' String 'km' Double 'agency' String 'water' String Unsere Klasse PoQgsStations kann praktischerweise aus PoStations abgeleitet werden. # modul from pomodules.postations import PoStations class PoQgsStations(PoStations): def __init__(self): super(PoQgsStations, self).__init__() # oder # PoStations.__init__(self) self.fields = None self.crs = None def getFeatures(self): data = self.getData() # Diese Fields anlegen: fnames = ('uuid', 'number', 'shortname', 'longname', 'km', 'agency', 'water') self.fields = QgsFields() # ... # Verarbeitung features = [] for d in data: f = QgsFeature(self.fields) # f.setGeometry(...) # feature-attributes ist ein dictionary: f[attributname] = wert # attributes aus getData sind in Liste, ohne Namen # for-Schleife daher mit Index \u00fcber alle Namen for i in range(len(self.fnames)): a = self.fnames[i] # ... features.append(f) return features Fazit und weitere Module Diese Art der Strukturierung und Verarbeitung ist selbsverst\u00e4ndlich nicht zwingend. Es gibt zahllose, ebenso sinnvolle M\u00f6glichkeiten, eine Klassenstruktur zu bauen. Denken Sie \u00fcber die Struktur nach, wie h\u00e4tten Sie es aufgebaut und probieren Sie etwas anderes aus! Weitere Module zur Abfrage der aktuellen Messwerte heben wir uns f\u00fcr sp\u00e4ter auf, aber sie sollten grunds\u00e4tzlich den selben Aufbau besitzen: + pomodules - __init__.py - urlreader.py - postations.py - poqgsstations.py - pocurrentw.py => neu - poqgscurrentw.py => neu Processing-Scripts Processing Scripts bilden eine M\u00f6glichkeit in QGIS neue Funktionalit\u00e4t bereitzustellen. In Anlehnung an die ArcGIS-Terminologie ist das ProcessingScript ein Python-Tool. Denn ebenso wie ArcGIS listet QGIS alle Processing-Funktionen in einer Werkzeugkiste auf. Da die Tools miteinander kombinierbar sind und \u00fcber ein Eingabe-Dialog-Fenster verf\u00fcgen, funktionieren sie etwas anders, als wir es mit pyqgis und dem QgsVectorFileWriter -Objekt kennengelernt haben. ohne Processing-Script Damit wir die Unterschiede besser verstehen, schreiben wir zun\u00e4chst ein Script, das in der QGIS-Pythonkonsole ausgef\u00fchrt wird und den uns bekannten QgsVectorFileWriter benutzt. In der Konsole k\u00f6nnen eventuell keine imports durchgef\u00fchrt werden, die im Scriptverzeichnis liegen. In diesem Fall sollten wir folgend einf\u00fcgen: import sys, os d = r\"U:\\Mein\\script\\verzeichnis\" if not d in sys.path: sys.path.append(d) Die if-Abfrage verhindert, dass bei mehrfacher Ausf\u00fchrung des Scripts, die Angabe mehrfach in sys.path enthalten bleibt. from pomodules.poqgsstations import PoQgsStations po = PoQgsStations() features = po.getFeatures() fields = po.fields crs = po.crs writer = QgsVectorFileWriter(r\"C:\\temp\\postations.gpkg\", \"UTF-8\", fields, QgsWkbTypes.Point, srs=crs) if writer.hasError() != QgsVectorFileWriter.NoError: print(\"Error when creating shapefile: \", writer.errorMessage()) else: for f in features: writer.addFeature(fet) del writer QgsVectorFileWriter speichert die Daten in einem Datenformat f\u00fcr Geodaten, diese werden allerdings nicht automatisch in QGIS geladen. Wollen wir das, so m\u00fcssen wir einen Layer erstellen. Und genau f\u00fcr diesen Fall gibt es eine Kurzform, die ohne den QgsVectorFileWriter auskommt. # QgsVectorLayer benutzt eine URI layer_uri = \"Point?crs=%s\"%crs.authid() # layer erzeugen: im Arbeitsspeicher, tempor\u00e4r vl = QgsVectorLayer(layer_uri, \"Stations\", \"memory\") # Provider = Dateiebene pr = vl.dataProvider() pr.addAttributes(fields) pr.addFeatures(features) # layer-Informationen aktualisieren vl.updateFields() vl.updateExtents() print(\"fields:\", len(pr.fields())) print(\"features:\", pr.featureCount()) e = vl.extent() print(\"extent:\", e.xMinimum(), e.yMinimum(), e.xMaximum(), e.yMaximum()) # Layer anzeigen QgsProject.instance().addMapLayer(vl) Diese zweite Variante eignet sich auch f\u00fcr Plugins! als Processing-Script Processing-Script: Ein Werkzeug in QGIS als Python-Script (Processing Framework) Benutzer w\u00e4hlt Algorithmus in der Processing-Toolbox. Dokumentation Processing-Scripts haben eine eigene QGIS-Schnittstelle (processing) Sie kennen Parameter, die in Formularen Eingaben entgegennehmen Layer werden nicht \u00fcber die Standard-Layer-Funktionen erzeugt (Sie sind Teil von Input- und Output-Parametern) Bestehendes Script in QGIS einbinden: in der Toolbox toolbar Python-Icon und \"Create New Script\" Script schreiben oder von anderer Quelle kopieren und einf\u00fcgen Speicherort: %HOME%\\.qgis3, bzw. %APPDATA%\\QGIS\\QGIS3 + \\profiles\\default\\processing\\scripts Beispiele: In der Dokumentation Workshop von madmanwoo QGIS-Tutorial von Ujaval Gandhi Objektorientierter Aufbau: class MeinProcessingAlgorithmus(QgsProcessingAlgorithm) Schnittstelle muss eingehalten werden Methoden, die \u00fcberschrieben werden m\u00fcssen, beachten -> Template wichtige Methoden: def initAlgorithm() zur Festlegung der Parameter def processAlgorithm() zur Ausf\u00fchrung nach Klick auf RUN-Button wichtige Parameter: self.parameterAsSource(): liest Eingabefeld f\u00fcr InputLayer (QgsProcessingParameterFeatureSource) self.parameterAsSink(): liest Eingabefeld f\u00fcr OutputLayer (QgsProcessingParameterFeatureSink) Das Template-Script: ein einfacher Processing-Alorithmus leicht gek\u00fcrzt, das Processing Script Template aus QGIS: # -*- coding: utf-8 -*- from PyQt5.QtCore import QCoreApplication from qgis.core import (QgsProcessing, QgsFeatureSink, QgsProcessingException, QgsProcessingAlgorithm, QgsProcessingParameterFeatureSource, QgsProcessingParameterFeatureSink) import processing class ExampleProcessingAlgorithm(QgsProcessingAlgorithm): \"\"\" All Processing algorithms should extend the QgsProcessingAlgorithm class. \"\"\" # Constants used to refer to parameters and outputs. INPUT = 'INPUT' OUTPUT = 'OUTPUT' def tr(self, string): return QCoreApplication.translate('Processing', string) def createInstance(self): return ExampleProcessingAlgorithm() def name(self): return 'myscript' def displayName(self): return self.tr('My Script') def group(self): return self.tr('Example scripts') def groupId(self): return 'examplescripts' def shortHelpString(self): return self.tr(\"Example algorithm short description\") def initAlgorithm(self, config=None): \"\"\" Here we define the inputs and output of the algorithm, along with some other properties. \"\"\" # We add the input vector features source. It can have any kind of # geometry. self.addParameter( QgsProcessingParameterFeatureSource( self.INPUT, self.tr('Input layer'), [QgsProcessing.TypeVectorAnyGeometry] ) ) # We add a feature sink in which to store our processed features (this # usually takes the form of a newly created vector layer when the # algorithm is run in QGIS). self.addParameter( QgsProcessingParameterFeatureSink( self.OUTPUT, self.tr('Output layer') ) ) def processAlgorithm(self, parameters, context, feedback): \"\"\" Here is where the processing itself takes place. \"\"\" # Retrieve the feature source and sink. The 'dest_id' variable is used # to uniquely identify the feature sink, and must be included in the # dictionary returned by the processAlgorithm function. source = self.parameterAsSource( parameters, self.INPUT, context ) # If source was not found, throw an exception to indicate that the algorithm # encountered a fatal error. The exception text can be any string, but in this # case we use the pre-built invalidSourceError method to return a standard # helper text for when a source cannot be evaluated if source is None: raise QgsProcessingException(self.invalidSourceError(parameters, self.INPUT)) (sink, dest_id) = self.parameterAsSink( parameters, self.OUTPUT, context, source.fields(), source.wkbType(), source.sourceCrs() ) features = source.getFeatures() total = 100.0 / source.featureCount() if source.featureCount() else 0 for current, feature in enumerate(features): # Stop the algorithm if cancel button has been clicked if feedback.isCanceled(): break # Do something with the input feature # or it will just be copied to the sink # Add a feature in the sink sink.addFeature(feature, QgsFeatureSink.FastInsert) # Update the progress bar feedback.setProgress(int(current * total)) # Return the results of the algorithm. In this case our only result is # the feature sink which contains the processed features, but some # algorithms may return multiple feature sinks, calculated numeric # statistics, etc. These should all be included in the returned # dictionary, with keys matching the feature corresponding parameter # or output names. return {self.OUTPUT: dest_id} Aufgabe: Processing-Script mit pomodules Problem: packages im selben Ordner werden nicht ber\u00fccksichtigt, da sie nicht gefunden werden - sie stehen nicht im Python-Path einfache L\u00f6sung: Wir kopieren pomodules in das Script-Verzeichnis Dieses Verzeichnis f\u00fcgen wir beim Start des Processing-Scripts dem python path hinzu ge\u00e4ndertes Template von oben: from qgis.core import (QgsProcessing, QgsApplication, QgsFeatureSink, QgsProcessingException, QgsProcessingAlgorithm, QgsProcessingParameterFeatureSource, QgsProcessingParameterFeatureSink) import sys sys.path.append(QgsApplication.qgisSettingsDirPath() + '\\\\processing\\\\scripts') from pomodules.poqgsstations import PoQgsStations Im Script wurde unsere Klasse importiert und zus\u00e4tzlich QgsApplication. Dessen Methode qgisSettingsDirPath() gibt den Pfadnamen zum Benutzerprofil zur\u00fcck. Unser Input-Parameter ist keine vorhandene Datenquelle (QgsProcessingParameterFeatureSource), sondern resultiert aus dem Download von Pegelonline. Den Output wollen wir aber als QgsProcessingParameterFeatureSink speichern. Wir k\u00f6nnen einen Input-Parameter aus einem anderen Typ verwenden, hier als Auswahlliste. Auch die Konstanten passen wir an und importieren den dazu passenden Typ QgsProcessingParameterEnum: from qgis.core import QgsProcessingParameterEnum class PegelOnlineLoader(QgsProcessingAlgorithm): INPUT = 'Query' OUTPUT = 'Result' QUERY_OPTIONS = ['Stations', 'Waterlevels'] def initAlgorithm(self, config=None): \"\"\" Here we define the inputs and output of the algorithm, along with some other properties. \"\"\" self.addParameter( QgsProcessingParameterEnum(self.INPUT, self.tr(self.INPUT), self.QUERY_OPTIONS)) self.addParameter( QgsProcessingParameterFeatureSink(self.OUTPUT, self.tr('Output layer'), QgsProcessing.TypeVectorAnyGeometry)) Auch der Klassennamen wurde ver\u00e4ndert, weitere Strings in den Methoden wir tr, name oder group k\u00f6nnen wir entsprechend anpassen. Der Benutzer kann jetzt im Dialog zwischen Stations oder Waterlevels w\u00e4hlen. Unser pomodules unterst\u00fctzen aber zun\u00e4chst nur die Stations-Abfrage von Pegelonline. Das bringt uns bereits zur Ausf\u00fchrungs-Methode processAlgorithm(). Hier werten wir zun\u00e4chst den Query-Parameter aus und besorgen uns den ausgew\u00e4hlten Abfragenamen. def processAlgorithm(self, parameters, context, feedback): \"\"\" Here is where the processing itself takes place. \"\"\" # Input parameter qx = self.parameterAsInt(parameters, self.INPUT, context) query = self.QUERY_OPTIONS[qx] feedback.pushInfo(query) # we're loading from PegelOnline if query == 'Stations': poQuery = PoQgsStations() # not implemented yet # elif query == 'Waterlevels': # poQuery = PoQgsCurrentW() else: feedback.pushInfo(\"This query is not implemented yet\") # stop and return with empty dict return {} feedback.pushInfo(\"Downloading %s ...\"%query) features = poQuery.getFeatures() # field and crs definitions from query fields = poQuery.fields crs = poQuery.crs feedback.pushInfo(\"Download done!\") Wir setzen unser Modul ein, um die Daten von Pegelonline zu laden und als QGIS-Features bereitzustellen. Ausserdem haben wir die Liste der Felder erzeugt sowie das Koordinatensystem. Das besondere ist nun, mit dem sink-Objekt zu arbeiten, um die Ergebnisse in QGIS anzuzeigen. Im Template-Script wurde der Geometrietyp aus dem Inputlayer \u00fcbernommen, was in diesem Fall nicht m\u00f6glich ist. Daher importieren wir QgsWkbTypes und \u00fcbergeben dann QgsWkbTypes.Point an parameterAsSink(): # Im Kopfteil: from qgis.core import (QgsProcessingParameterEnum, QgsWkbTypes) ## in processAlgorithm ## hinter feedback.pushInfo(\"Download done!\") # our output to qgis sink, dest_id = self.parameterAsSink(parameters, self.OUTPUT, context, fields, QgsWkbTypes.Point, crs) for f in features: sink.addFeature(f, QgsFeatureSink.FastInsert) return {self.OUTPUT: dest_id} Wir nutzen das sink-Objekt, um unsere QGIS-Features zu speichern und geben mit return das dictionary mit den erforderlichen Daten an QGIS zur\u00fcck. Weitere M\u00f6glichkeiten mit Processing-Scripts mit Python starten (z.B. um ein weiteres processing script einzubinden), Anleitung in der QGIS-Dokumentation , bzw. im QGIS-Script-Template selbst wird dies demonstriert. als Plugin installieren (zur Verbreitung, Vorteil: funktioniert mit packages ), Anleitung in der QGIS-Dokumentation","title":"QGIS mit Pegelonline-Daten"},{"location":"ch02/p02_jsonqgis.html#die-pegelonline-schnittstelle","text":"Auf Basis des Moduls urlreader lassen sich die Daten von Pegelonline herunterladen. Eine Betrachtung der Restschnittstelle zeigt verschiedene M\u00f6glichkeiten auf. Insbesondere ist es m\u00f6glich: alle Stationen, quasi als Stammdaten, mit diversen Attributen zu verwenden Station mit ID, Name, Ort, Gew\u00e4sser, Betreiber die an einer Station gemessenen Parameter (timeseries) Referenzwerte zur Klassifikation (characteristic values) aktuelle Messwerte aller Stationen, f\u00fcr jeden dort erhobenen Parameter zu erhalten (currentMeasurment) der h\u00e4ufigste gemessene Parameter ist der Wasserstand (timeseries=W) eine Zeitreihe f\u00fcr einen Parameter f\u00fcr eine einzelne Station, f\u00fcr maximal 30 Tage hier ist es m\u00f6glich, die Daten als Grafik oder im JSON-Format abzurufen.","title":"Die Pegelonline Schnittstelle"},{"location":"ch02/p02_jsonqgis.html#abfragen-verarbeiten","text":"Mit Ausnahme der stationsbezogenen Zeitreihen, m\u00fcsssen zwei Schritte durchlaufen werden, um die Daten von Pegelonline in QGIS als Karte anzuzeigen. Die JSON-Daten m\u00fcssen in eine Tabellenstruktur \u00fcberf\u00fchrt werden, bzw. nach Geometrie und Attributen getrennt werden. Aus den Angaben m\u00fcssen QGIS-Features erzeugt werden und diese in einem Layer gespeichert werden. Die dritte Abfragem\u00f6glichkeiten zu einzelnen Stationen k\u00f6nnen wir sp\u00e4ter im Plugin anzeigen. In der \u00dcbung der letzen Einheit haben wir bereits ein Modul geschrieben, auf dem die Datenverarbeitung aufbaut, den UrlReader. Auch haben wir bereits gesehen, wie die Daten in eine tabellarische Form gebracht werden k\u00f6nnen. Wir werden nun eine \u00fcbergeordnete Struktur schaffen, um die Funktionen zu strukturieren. Hierzu legen wir uns ein python-package an, dazu ben\u00f6tigen wir: einen Ordner mit einem sinnvollen Namen, darin eine Datei __init__.py und eine Kopie des Urlreaders Wir wollen entsprechend der M\u00f6glichkeiten von Pegelonline dort Module anlegen, und objektorientiert die zwei beschriebenen Schritte implementieren. Wir erstellen zun\u00e4chst: ein Modul f\u00fcr die Stationsabfrage mit Stammdaten ein Modul zur Erstellung der QGIS-Features f\u00fcr die Stationen Stationen: Abfrage mit stations.json lesen Geometrie aus 'longitude', 'latitude' und Attribute aus 'uuid', 'number', 'shortname', 'longname', 'km', 'agency', 'water' (water->shortname) Sp\u00e4ter implementieren wir analog die Abfrage den aktuellen Wasserst\u00e4nden mit entsprechenden Modulen, die Abfrage lautet dann stations.json?timeseries=W&includeTimeseries=true&includeCurrentMeasurement=true geometrie = 'longitude', 'latitude' attribute = 'uuid', 'shortname', 'time', 'value', 'trend', 'stateMnwMhw', 'stateNswHsw' alle ab timestamp: ['timeseries'][0]['currentMeasurement'] ['timestamp'] ... Der Ordner mit dem Python-Package + pomodules - __init__.py - urlreader.py - postations.py - poqgsstations.py Bei den Modul- und Klassennamen kann es sinnvoll sein einen gemeinsamen Pr\u00e4fix zu verwenden, hier wurde po for PegelOnline benutzt, ausserdem sollen die Namen kennzeichnen, f\u00fcr welche Teilaufgabe oder Datenbereich sie stehen, hier stations . Die Aufbereitung f\u00fcr QGIS wird dann mit qgs versehen. Viele Pythonprogrammierer schreiben Modulnamen einer Klasse klein und den Klassennamen dann in CamelCase . Die Datei __init__.py steht f\u00fcr die Initialisierung des Package und kann leer bleiben. Hier allerdings wurde die Variable poBaseURL definiert, die von mehreren Modulen genutzt wird und den Anfangsstring f\u00fcr jede PegelOnline-Abfrage beinhaltet. Das ist zudem praktisch, falls sich diese Adresse einmal \u00e4ndern sollte... # modul __init__ poBaseURL = 'https://www.pegelonline.wsv.de/webservices/rest-api/v2/'","title":"Abfragen verarbeiten"},{"location":"ch02/p02_jsonqgis.html#modul-der-stationsabfrage-mit-stammdaten","text":"# modul postations from pomodules.urlreader import Urlreader class PoStations(object): def __init__(self): self.url = poBaseURL + 'stations.json' def getData(self): ur = Urlreader(self.url) json_data = ur.getJsonResponse() stations = [] # process all stations return stations Da wir sp\u00e4ter Geometrie und Attribute getrennt verarbeiten, bietet es sich an, dies schon auf dieser Ebene zu tun, z.B. als dictionary: station = { 'geometry': (d['longitude'], d['latitude']), 'attributes': ( d['uuid'], d['number'], d['shortname'], d['longname'], d['km'], d['agency'], d['water']['longname'] ) } Denken Sie daran, dass die Daten aus unserer Sicht Fehler enthalten k\u00f6nnen. So gibt es Stationen, die keine Eintr\u00e4ge f\u00fcr d['longitude'] und d['latitude'] haben. Die Abfrage oben f\u00fchrt zu einer eingeschr\u00e4nkten Anzahl an Attributen f\u00fcr die Stationen. Je nachdem, welche Verarbeitungen wir uns im QGIS vorstellen, kann es notwendig sein, die Attribute zu erweitern.","title":"Modul der Stationsabfrage mit Stammdaten"},{"location":"ch02/p02_jsonqgis.html#modul-zur-erstellung-von-qgis-features","text":"Die empfangenen und aufbereiteten Daten werden nun in eine Liste mit QGIS-Features umgewandelt. Dazu ben\u00f6tigen wir auch eine Liste der Felddefinitionen als QgsFields-Objekt. Name Datentyp 'uuid' String 'number' Int 'shortname' String 'longname' String 'km' Double 'agency' String 'water' String Unsere Klasse PoQgsStations kann praktischerweise aus PoStations abgeleitet werden. # modul from pomodules.postations import PoStations class PoQgsStations(PoStations): def __init__(self): super(PoQgsStations, self).__init__() # oder # PoStations.__init__(self) self.fields = None self.crs = None def getFeatures(self): data = self.getData() # Diese Fields anlegen: fnames = ('uuid', 'number', 'shortname', 'longname', 'km', 'agency', 'water') self.fields = QgsFields() # ... # Verarbeitung features = [] for d in data: f = QgsFeature(self.fields) # f.setGeometry(...) # feature-attributes ist ein dictionary: f[attributname] = wert # attributes aus getData sind in Liste, ohne Namen # for-Schleife daher mit Index \u00fcber alle Namen for i in range(len(self.fnames)): a = self.fnames[i] # ... features.append(f) return features","title":"Modul zur Erstellung von QGIS-Features"},{"location":"ch02/p02_jsonqgis.html#fazit-und-weitere-module","text":"Diese Art der Strukturierung und Verarbeitung ist selbsverst\u00e4ndlich nicht zwingend. Es gibt zahllose, ebenso sinnvolle M\u00f6glichkeiten, eine Klassenstruktur zu bauen. Denken Sie \u00fcber die Struktur nach, wie h\u00e4tten Sie es aufgebaut und probieren Sie etwas anderes aus! Weitere Module zur Abfrage der aktuellen Messwerte heben wir uns f\u00fcr sp\u00e4ter auf, aber sie sollten grunds\u00e4tzlich den selben Aufbau besitzen: + pomodules - __init__.py - urlreader.py - postations.py - poqgsstations.py - pocurrentw.py => neu - poqgscurrentw.py => neu","title":"Fazit und weitere Module"},{"location":"ch02/p02_jsonqgis.html#processing-scripts","text":"Processing Scripts bilden eine M\u00f6glichkeit in QGIS neue Funktionalit\u00e4t bereitzustellen. In Anlehnung an die ArcGIS-Terminologie ist das ProcessingScript ein Python-Tool. Denn ebenso wie ArcGIS listet QGIS alle Processing-Funktionen in einer Werkzeugkiste auf. Da die Tools miteinander kombinierbar sind und \u00fcber ein Eingabe-Dialog-Fenster verf\u00fcgen, funktionieren sie etwas anders, als wir es mit pyqgis und dem QgsVectorFileWriter -Objekt kennengelernt haben.","title":"Processing-Scripts"},{"location":"ch02/p02_jsonqgis.html#ohne-processing-script","text":"Damit wir die Unterschiede besser verstehen, schreiben wir zun\u00e4chst ein Script, das in der QGIS-Pythonkonsole ausgef\u00fchrt wird und den uns bekannten QgsVectorFileWriter benutzt. In der Konsole k\u00f6nnen eventuell keine imports durchgef\u00fchrt werden, die im Scriptverzeichnis liegen. In diesem Fall sollten wir folgend einf\u00fcgen: import sys, os d = r\"U:\\Mein\\script\\verzeichnis\" if not d in sys.path: sys.path.append(d) Die if-Abfrage verhindert, dass bei mehrfacher Ausf\u00fchrung des Scripts, die Angabe mehrfach in sys.path enthalten bleibt. from pomodules.poqgsstations import PoQgsStations po = PoQgsStations() features = po.getFeatures() fields = po.fields crs = po.crs writer = QgsVectorFileWriter(r\"C:\\temp\\postations.gpkg\", \"UTF-8\", fields, QgsWkbTypes.Point, srs=crs) if writer.hasError() != QgsVectorFileWriter.NoError: print(\"Error when creating shapefile: \", writer.errorMessage()) else: for f in features: writer.addFeature(fet) del writer QgsVectorFileWriter speichert die Daten in einem Datenformat f\u00fcr Geodaten, diese werden allerdings nicht automatisch in QGIS geladen. Wollen wir das, so m\u00fcssen wir einen Layer erstellen. Und genau f\u00fcr diesen Fall gibt es eine Kurzform, die ohne den QgsVectorFileWriter auskommt. # QgsVectorLayer benutzt eine URI layer_uri = \"Point?crs=%s\"%crs.authid() # layer erzeugen: im Arbeitsspeicher, tempor\u00e4r vl = QgsVectorLayer(layer_uri, \"Stations\", \"memory\") # Provider = Dateiebene pr = vl.dataProvider() pr.addAttributes(fields) pr.addFeatures(features) # layer-Informationen aktualisieren vl.updateFields() vl.updateExtents() print(\"fields:\", len(pr.fields())) print(\"features:\", pr.featureCount()) e = vl.extent() print(\"extent:\", e.xMinimum(), e.yMinimum(), e.xMaximum(), e.yMaximum()) # Layer anzeigen QgsProject.instance().addMapLayer(vl) Diese zweite Variante eignet sich auch f\u00fcr Plugins!","title":"ohne Processing-Script"},{"location":"ch02/p02_jsonqgis.html#als-processing-script","text":"Processing-Script: Ein Werkzeug in QGIS als Python-Script (Processing Framework) Benutzer w\u00e4hlt Algorithmus in der Processing-Toolbox. Dokumentation Processing-Scripts haben eine eigene QGIS-Schnittstelle (processing) Sie kennen Parameter, die in Formularen Eingaben entgegennehmen Layer werden nicht \u00fcber die Standard-Layer-Funktionen erzeugt (Sie sind Teil von Input- und Output-Parametern) Bestehendes Script in QGIS einbinden: in der Toolbox toolbar Python-Icon und \"Create New Script\" Script schreiben oder von anderer Quelle kopieren und einf\u00fcgen Speicherort: %HOME%\\.qgis3, bzw. %APPDATA%\\QGIS\\QGIS3 + \\profiles\\default\\processing\\scripts Beispiele: In der Dokumentation Workshop von madmanwoo QGIS-Tutorial von Ujaval Gandhi Objektorientierter Aufbau: class MeinProcessingAlgorithmus(QgsProcessingAlgorithm) Schnittstelle muss eingehalten werden Methoden, die \u00fcberschrieben werden m\u00fcssen, beachten -> Template wichtige Methoden: def initAlgorithm() zur Festlegung der Parameter def processAlgorithm() zur Ausf\u00fchrung nach Klick auf RUN-Button wichtige Parameter: self.parameterAsSource(): liest Eingabefeld f\u00fcr InputLayer (QgsProcessingParameterFeatureSource) self.parameterAsSink(): liest Eingabefeld f\u00fcr OutputLayer (QgsProcessingParameterFeatureSink)","title":"als Processing-Script"},{"location":"ch02/p02_jsonqgis.html#das-template-script-ein-einfacher-processing-alorithmus","text":"leicht gek\u00fcrzt, das Processing Script Template aus QGIS: # -*- coding: utf-8 -*- from PyQt5.QtCore import QCoreApplication from qgis.core import (QgsProcessing, QgsFeatureSink, QgsProcessingException, QgsProcessingAlgorithm, QgsProcessingParameterFeatureSource, QgsProcessingParameterFeatureSink) import processing class ExampleProcessingAlgorithm(QgsProcessingAlgorithm): \"\"\" All Processing algorithms should extend the QgsProcessingAlgorithm class. \"\"\" # Constants used to refer to parameters and outputs. INPUT = 'INPUT' OUTPUT = 'OUTPUT' def tr(self, string): return QCoreApplication.translate('Processing', string) def createInstance(self): return ExampleProcessingAlgorithm() def name(self): return 'myscript' def displayName(self): return self.tr('My Script') def group(self): return self.tr('Example scripts') def groupId(self): return 'examplescripts' def shortHelpString(self): return self.tr(\"Example algorithm short description\") def initAlgorithm(self, config=None): \"\"\" Here we define the inputs and output of the algorithm, along with some other properties. \"\"\" # We add the input vector features source. It can have any kind of # geometry. self.addParameter( QgsProcessingParameterFeatureSource( self.INPUT, self.tr('Input layer'), [QgsProcessing.TypeVectorAnyGeometry] ) ) # We add a feature sink in which to store our processed features (this # usually takes the form of a newly created vector layer when the # algorithm is run in QGIS). self.addParameter( QgsProcessingParameterFeatureSink( self.OUTPUT, self.tr('Output layer') ) ) def processAlgorithm(self, parameters, context, feedback): \"\"\" Here is where the processing itself takes place. \"\"\" # Retrieve the feature source and sink. The 'dest_id' variable is used # to uniquely identify the feature sink, and must be included in the # dictionary returned by the processAlgorithm function. source = self.parameterAsSource( parameters, self.INPUT, context ) # If source was not found, throw an exception to indicate that the algorithm # encountered a fatal error. The exception text can be any string, but in this # case we use the pre-built invalidSourceError method to return a standard # helper text for when a source cannot be evaluated if source is None: raise QgsProcessingException(self.invalidSourceError(parameters, self.INPUT)) (sink, dest_id) = self.parameterAsSink( parameters, self.OUTPUT, context, source.fields(), source.wkbType(), source.sourceCrs() ) features = source.getFeatures() total = 100.0 / source.featureCount() if source.featureCount() else 0 for current, feature in enumerate(features): # Stop the algorithm if cancel button has been clicked if feedback.isCanceled(): break # Do something with the input feature # or it will just be copied to the sink # Add a feature in the sink sink.addFeature(feature, QgsFeatureSink.FastInsert) # Update the progress bar feedback.setProgress(int(current * total)) # Return the results of the algorithm. In this case our only result is # the feature sink which contains the processed features, but some # algorithms may return multiple feature sinks, calculated numeric # statistics, etc. These should all be included in the returned # dictionary, with keys matching the feature corresponding parameter # or output names. return {self.OUTPUT: dest_id}","title":"Das Template-Script: ein einfacher Processing-Alorithmus"},{"location":"ch02/p02_jsonqgis.html#aufgabe-processing-script-mit-pomodules","text":"Problem: packages im selben Ordner werden nicht ber\u00fccksichtigt, da sie nicht gefunden werden - sie stehen nicht im Python-Path einfache L\u00f6sung: Wir kopieren pomodules in das Script-Verzeichnis Dieses Verzeichnis f\u00fcgen wir beim Start des Processing-Scripts dem python path hinzu ge\u00e4ndertes Template von oben: from qgis.core import (QgsProcessing, QgsApplication, QgsFeatureSink, QgsProcessingException, QgsProcessingAlgorithm, QgsProcessingParameterFeatureSource, QgsProcessingParameterFeatureSink) import sys sys.path.append(QgsApplication.qgisSettingsDirPath() + '\\\\processing\\\\scripts') from pomodules.poqgsstations import PoQgsStations Im Script wurde unsere Klasse importiert und zus\u00e4tzlich QgsApplication. Dessen Methode qgisSettingsDirPath() gibt den Pfadnamen zum Benutzerprofil zur\u00fcck. Unser Input-Parameter ist keine vorhandene Datenquelle (QgsProcessingParameterFeatureSource), sondern resultiert aus dem Download von Pegelonline. Den Output wollen wir aber als QgsProcessingParameterFeatureSink speichern. Wir k\u00f6nnen einen Input-Parameter aus einem anderen Typ verwenden, hier als Auswahlliste. Auch die Konstanten passen wir an und importieren den dazu passenden Typ QgsProcessingParameterEnum: from qgis.core import QgsProcessingParameterEnum class PegelOnlineLoader(QgsProcessingAlgorithm): INPUT = 'Query' OUTPUT = 'Result' QUERY_OPTIONS = ['Stations', 'Waterlevels'] def initAlgorithm(self, config=None): \"\"\" Here we define the inputs and output of the algorithm, along with some other properties. \"\"\" self.addParameter( QgsProcessingParameterEnum(self.INPUT, self.tr(self.INPUT), self.QUERY_OPTIONS)) self.addParameter( QgsProcessingParameterFeatureSink(self.OUTPUT, self.tr('Output layer'), QgsProcessing.TypeVectorAnyGeometry)) Auch der Klassennamen wurde ver\u00e4ndert, weitere Strings in den Methoden wir tr, name oder group k\u00f6nnen wir entsprechend anpassen. Der Benutzer kann jetzt im Dialog zwischen Stations oder Waterlevels w\u00e4hlen. Unser pomodules unterst\u00fctzen aber zun\u00e4chst nur die Stations-Abfrage von Pegelonline. Das bringt uns bereits zur Ausf\u00fchrungs-Methode processAlgorithm(). Hier werten wir zun\u00e4chst den Query-Parameter aus und besorgen uns den ausgew\u00e4hlten Abfragenamen. def processAlgorithm(self, parameters, context, feedback): \"\"\" Here is where the processing itself takes place. \"\"\" # Input parameter qx = self.parameterAsInt(parameters, self.INPUT, context) query = self.QUERY_OPTIONS[qx] feedback.pushInfo(query) # we're loading from PegelOnline if query == 'Stations': poQuery = PoQgsStations() # not implemented yet # elif query == 'Waterlevels': # poQuery = PoQgsCurrentW() else: feedback.pushInfo(\"This query is not implemented yet\") # stop and return with empty dict return {} feedback.pushInfo(\"Downloading %s ...\"%query) features = poQuery.getFeatures() # field and crs definitions from query fields = poQuery.fields crs = poQuery.crs feedback.pushInfo(\"Download done!\") Wir setzen unser Modul ein, um die Daten von Pegelonline zu laden und als QGIS-Features bereitzustellen. Ausserdem haben wir die Liste der Felder erzeugt sowie das Koordinatensystem. Das besondere ist nun, mit dem sink-Objekt zu arbeiten, um die Ergebnisse in QGIS anzuzeigen. Im Template-Script wurde der Geometrietyp aus dem Inputlayer \u00fcbernommen, was in diesem Fall nicht m\u00f6glich ist. Daher importieren wir QgsWkbTypes und \u00fcbergeben dann QgsWkbTypes.Point an parameterAsSink(): # Im Kopfteil: from qgis.core import (QgsProcessingParameterEnum, QgsWkbTypes) ## in processAlgorithm ## hinter feedback.pushInfo(\"Download done!\") # our output to qgis sink, dest_id = self.parameterAsSink(parameters, self.OUTPUT, context, fields, QgsWkbTypes.Point, crs) for f in features: sink.addFeature(f, QgsFeatureSink.FastInsert) return {self.OUTPUT: dest_id} Wir nutzen das sink-Objekt, um unsere QGIS-Features zu speichern und geben mit return das dictionary mit den erforderlichen Daten an QGIS zur\u00fcck.","title":"Aufgabe: Processing-Script mit pomodules"},{"location":"ch02/p02_jsonqgis.html#weitere-moglichkeiten-mit-processing-scripts","text":"mit Python starten (z.B. um ein weiteres processing script einzubinden), Anleitung in der QGIS-Dokumentation , bzw. im QGIS-Script-Template selbst wird dies demonstriert. als Plugin installieren (zur Verbreitung, Vorteil: funktioniert mit packages ), Anleitung in der QGIS-Dokumentation","title":"Weitere M\u00f6glichkeiten mit Processing-Scripts"},{"location":"ch02/p03_pyqt5.html","text":"Graphische Benutzeroberf\u00e4chen Einf\u00fchrung GUI-Programmierung Eine Anwendung mit graphischer Benutzeroberfl\u00e4che (GUI) programmieren Ein GUI setzt sich aus Fensterelementen zusammen (Widgets): Men\u00fc, Statusleiste, Formulare, Listenfelder, Textfelder, etc Elemente werden in Bibliotheken vorgehalten Oft vom Betriebssystem abh\u00e4ngig: Windows, Mac, aber auch: Plattform\u00fcbergreifende WidgetSets, integrieren sich in ein Gast-System (z.B. Windows) QGIS benutzt die Qt-Widgets f\u00fcr das eigene GUI F\u00fcr Python existiert das Modulpaket PyQt5 Plugins f\u00fcr QGIS werden mit pyqt5 entwickelt eine simple und minimale Anwendung Begriffe aus der GUI-Welt Widget = Window Gadget: Ein \"Fensterdingsbums\", kleinster Teil eines GUI Dialog = ein aus 1..n Widgets bestehende GUI zur Realisierung einer spezifischen Nutzerinteraktion, oft auch als Formular bezeichnet (s. Abb.) MainWindow = Hauptfenster einer Applikation, mit Buttons und Men\u00fcs, welche bestimmte Funktionen ausf\u00fchren oder Dialoge aufrufen (s. QGIS) GUI = Graphical User Interface: Graphische Benutzerschnittstelle; Oberbegriff Maus+Tastatur+Bildschirm (oder andere Eingaben mit graphischer R\u00fcckmeldung) Ereignis-Programmierung: Fensterobjekte\u2013 Datenobjekte \u2013 Eingabeobjekte interagieren miteinander und manipulieren sich gegenseitig H\u00e4ufig verwendete QtGUI-Widgets in Dialogen Qt arbeitet auch der Basis von Events nach Signal-Slot-Schema . Es werden hierbei Nachrichten von Fensterelementen (Signal) an einen festen Adressaten (Slot) gesendet, der Adressat ist in der Regel eine Funktion/Methode Qt5-Dokumentation . Erfolgt eine Steuerung z.B. \u00fcber touch-sensitive Ger\u00e4te, so werden zu den Widgets passende Events benutzt, die auf die Ber\u00fchung mit Fingern reagieren. Dokumentation PyQt5 Reference Guide Qt5-Dokumentation \u00dcbersicht python.org Aufbau einer PyQt5-Anwendung Hello World Ben\u00f6tigte Module importieren und Funktion main() einrichten import sys from PyQt5.QtWidgets import * def main(argv): pass if __name__ == '__main__': main(sys.argv) Die Anwendung kann auch Kommandozeilenargumente verarbeiten, daher wird sys.argv \u00fcbergeben. Jede PyQt-GUI-Anwendung ben\u00f6tigt ein QApplication Objekt. Dieses stellt allgemeine Informationen wie z.B. das Anwendungsdirectory, Bildschirmparameter und v.A. den Event-Loop zur Verf\u00fcgung. import sys from PyQt5.QtWidgets import QApplication, QTextEdit def main(argv): # each Qt-Programm needs an application object app = QApplication(argv) # to show the string Hello World in a window textEdit = QTextEdit() textEdit.setText(\"Hello World\") # show window textEdit.show() app.exec_() if __name__ == '__main__': main(sys.argv) Ein QTextEdit Widget wird erstellt: In PyQt kann jedes Widget als Top-Level Fenster dienen. Ist dies der Fall, wird ihm automatisch die typische Titelzeile und u.a. der X-Button verliehen. Nachfolgend wird ein \"paint event\" zur Anzeige des Widgets in den Event-Loop eingesetzt. Damit steht die Anzeige des Widgets in der Warteschleife. Schlie\u00dflich muss man den Event-Loop starten, das Widget erscheint am Bildschirm, bis X gedr\u00fcckt wird. textEdit.resize(250, 450) textEdit.move(300, 300) textEdit.setWindowTitle('Simple') # show window textEdit.show() app.exec_() Ein QTextEdit als top level widget erlaubt es, Parameter des Fensters zu setzen Objektorientierung Ein Dialog-Fenster mit Textfeld wird als Klasse definiert: import sys from PyQt5.QtWidgets import (QApplication, QDialog, QTextEdit, QVBoxLayout) class MyForm(QDialog): def __init__(self): QDialog.__init__(self) self.textEdit = QTextEdit('Hello World!') self.textEdit.selectAll() layout = QVBoxLayout() layout.addWidget(self.textEdit) self.setLayout(layout) app = QApplication(sys.argv) form = MyForm() form.show() app.exec_() self ist das Dialogobjekt ein QVBoxLayout-Objekt ordnet andere Widgets vertikal an setLayout() ist eine Methode, um in dem Dialog self ein QTextFeld anzuzeigen self.textEdit: unter dieser Variable bleibt das Textfeld ansprechbar Events mit Signals and Slots :Herk\u00f6mmliches und Event-basiertes Programm Events als Nachrichten zwischen Objekten Jedes Widget kennt eigene Events und kann eine Funktion vorsehen, um diese zu verarbeiten Signals and Slots, als Konzept, definiert ein Signal, etwa 'clicked()' f\u00fcr ein QPushButton, das einen Slot in einem anderen Objekt (dem Empf\u00e4nger) belegt, und dort eine Funktion ausf\u00fchrt. Die Basis hierf\u00fcr ist die Funktion connect, die jedes Qt-Objekt ausf\u00fchren kann QObject.[signal_name].connect(function) z.B. das Push-Button-Widget pbOK soll ein click-Event ausl\u00f6sen und \u00fcber die Funktion doOK() verarbeiten: pbOK.clicked.connect(doOK) 'Hello World' mit OK-Button import sys from PyQt5.QtWidgets import (QApplication, QDialog, QTextEdit, QVBoxLayout, QPushButton) # new class MyForm(QDialog): def __init__(self): QDialog.__init__(self) self.textEdit = QTextEdit('Hello World!') self.textEdit.selectAll() self.buttonOK = QPushButton() # new self.buttonOK.setText('OK') layout = QVBoxLayout() layout.addWidget(self.textEdit) layout.addWidget(self.buttonOK) #new self.setLayout(layout) self.buttonOK.clicked.connect(self.doOK) # new def doOK(self): # new self.textEdit.setText(\"Hello PyQt5!\") app = QApplication(sys.argv) form = MyForm() form.show() app.exec_() Noch ein Signal and Slot? Wir nehmen den Button zum Schlie\u00dfen des Fensters: self.buttonOK.clicked.connect(self.doOK) # den Button haben wir schon... self.pbOK.clicked.connect(self.close) # QDialog besitzt bereits einen Slot 'close' In einer Class referenziert self immer das aus der Klasse abgeleitete Objekt. self.close wurde zwar nicht in der class MyForm definiert, aber in der vererbenden Klasse QDialog . Zus\u00e4tzlich k\u00f6nnen wir aber auch die Methode close des QDialogs \u00fcberschreiben: def close(self): print(self.textEdit.toPlainText()) QDialog.close(self) https://pythonspot.com/gui/ Qt-Layout Sehr umfangreiche Layout-Einstellungen QVBoxLayout und QHBoxLayout oder QGridLayout bieten grundlegende M\u00f6glichkeiten zum Layout erweitertes Beispiel zu Hello World zeigt den Einsatz Layout k\u00f6nnen auch geschachtelt werden, d.h. ein layout kann ein anderes enthalten def __init__(self): # Widgets self.textEdit = QTextEdit('Hello World!') self.textEdit.selectAll() self.lblText = QLabel() self.lblText.setText(\"Editor\") self.buttonOK = QPushButton() self.buttonOK.setText('OK') self.buttonEsc = QPushButton() self.buttonEsc.setText('Beenden') # \u00fcbergeordnetes Layout erstellen self.vlayout = QVBoxLayout(self) self.hlayout = QHBoxLayout() self.vlayout.addWidget(self.lblText) self.vlayout.addWidget(self.textEdit) # Button horizontal darunter anordnen self.hlayout.addWidget(self.buttonOK) self.hlayout.addWidget(self.buttonEsc) # hor. layout zu vert layout hinzuf\u00fcgen self.vlayout.addLayout(self.hlayout) self.buttonOK.clicked.connect(self.doOK) self.buttonEsc.clicked.connect(self.close) Dialoge Wir unterscheiden: Dialogboxen, die bereits als Klassen bestehen: Nachricht mit Ja/Nein, File Save/File Open, Farbwahl, Eingabezeile etc. Dokumentation Eigene Formulare und Dialoge auf Basis von QDialog sind an ein anderes Widget (z.B. MainWindow) gebunden k\u00f6nnen modal oder unabh\u00e4ngig sein geben einen Wert zur\u00fcck Schema eines modalen Dialogs Bestehende Dialoge Ein Dialog f\u00fcr eine Eingabe: def doOK(self): # new # open Input-Dialog text, ok = QInputDialog.getText(self, 'Editor', 'Neuer Text:') if ok: self.textEdit.setText(text) else: self.textEdit.setText(\"Hello PyQt5!\") liefert einen String zur\u00fcck und au\u00dferdem den Wert f\u00fcr OK mit true bzw. false, je nachdem, ob der Benutzer OK geklickt hat, ober nicht. Ein kleines Beispiel zum Aufruf eines MessageBox-Dialogs import sys from PyQt5.QtWidgets import * def callDialog(): result = QMessageBox.question(w, 'Message', \"Do you like Python?\", QMessageBox.Yes | QMessageBox.No, QMessageBox.No) if result == QMessageBox.Yes: print(\"yes\") else: print(\"no\") app = QApplication(sys.argv) w = QPushButton('Ask me...') w.clicked.connect(callDialog) w.show() app.exec_() Ein Beispiel f\u00fcr den Aufruf verschiedener Dialoge aus dem ZetCode PyQt4 tutorial von Jan Bodnar und pythonspot : import sys from PyQt5.QtWidgets import QApplication, QWidget, QInputDialog, QLineEdit from PyQt5.QtGui import QIcon class App(QWidget): def __init__(self): super().__init__() self.title = 'PyQt5 input dialogs - pythonspot.com' self.left = 10 self.top = 10 self.width = 640 self.height = 480 self.initUI() def initUI(self): self.setWindowTitle(self.title) self.setGeometry(self.left, self.top, self.width, self.height) self.getInteger() self.getText() self.getDouble() self.getChoice() self.show() def getInteger(self): i, okPressed = QInputDialog.getInt(self, \"Get integer\",\"Percentage:\", 28, 0, 100, 1) if okPressed: print(i) def getDouble(self): d, okPressed = QInputDialog.getDouble(self, \"Get double\",\"Value:\", 10.50, 0, 100, 10) if okPressed: print( d) def getChoice(self): items = (\"Red\",\"Blue\",\"Green\") item, okPressed = QInputDialog.getItem(self, \"Get item\",\"Color:\", items, 0, False) if ok and item: print(item) def getText(self): text, okPressed = QInputDialog.getText(self, \"Get text\",\"Your name:\", QLineEdit.Normal, \"\") if okPressed and text != '': print(text) if __name__ == '__main__': app = QApplication(sys.argv) ex = App() sys.exit(app.exec_()) Die einzelnen Dialoge sind auch konfigurierbar. Hier die Varianten f\u00fcr den QFileDialog import sys from PyQt5.QtWidgets import QApplication, QWidget, QInputDialog, QLineEdit, QFileDialog from PyQt5.QtGui import QIcon class App(QWidget): def __init__(self): super().__init__() self.title = 'PyQt5 file dialogs - pythonspot.com' self.left = 10 self.top = 10 self.width = 640 self.height = 480 self.initUI() def initUI(self): self.setWindowTitle(self.title) self.setGeometry(self.left, self.top, self.width, self.height) self.openFileNameDialog() self.openFileNamesDialog() self.saveFileDialog() self.show() def openFileNameDialog(self): options = QFileDialog.Options() options |= QFileDialog.DontUseNativeDialog fileName, _ = QFileDialog.getOpenFileName(self,\"QFileDialog.getOpenFileName()\", \"\",\"All Files (*);;Python Files (*.py)\", options=options) if fileName: print(fileName) def openFileNamesDialog(self): options = QFileDialog.Options() options |= QFileDialog.DontUseNativeDialog files, _ = QFileDialog.getOpenFileNames(self,\"QFileDialog.getOpenFileNames()\", \"\",\"All Files (*);;Python Files (*.py)\", options=options) if files: print(files) def saveFileDialog(self): options = QFileDialog.Options() options |= QFileDialog.DontUseNativeDialog fileName, _ = QFileDialog.getSaveFileName(self,\"QFileDialog.getSaveFileName()\",\"\",\"All Files (*);;Text Files (*.txt)\", options=options) if fileName: print(fileName) if __name__ == '__main__': app = QApplication(sys.argv) ex = App() sys.exit(app.exec_()) Aufgabe ein eigenes Widget zur Anzeige des Pegelverlaufs Eigenes Widget zur Darstellung des Pegelverlaufs Das Widget ist eigentlich eine Kombination aus bestehenden Qt-Widgets. Allerdings soll es einen sehr speziellen Zweck erf\u00fcllen: Der Benutzer soll mit diesem Widget eine Station \u00fcber ihren Namen ausw\u00e4hlen k\u00f6nnen und das Widget l\u00e4dt anschlie\u00dfend die entsprechende Graphik in das Fenster. Es basiert auf einer Abfrage von Pegelonline in dieser Form: stations/BONN/W/measurements.png?start=P15D Der Vorteil eines eigenen Widgets: Es k\u00f6nnen Funktion und Bedienung festgelegt werden und in eine gr\u00f6\u00dfere Anwendung, ein GUI, integriert werden. Hierbei legen wir eine Schnittstelle fest, mit der das Widget gesteuert werden kann. Dies kann im einfachsten Fall das Eintagen der Stationsnamen sein. Das Widget selbst importiert unser Modul Urlreader, um die Graphiken zu einer Station zu laden. Hier ein Entwurf f\u00fcr das PoGraphDisplay-Widget als Python-Code: import sys from PyQt5 import QtWidgets from PyQt5 import QtCore, QtGui from pomodules.urlreader import Urlreader, quote from pomodules import poBaseURL class PoGraphDisplay(QWidget): def __init__(self): super().__init__() # Aufbau der Elemente im Widget self.initUI() def initUI(self): pass # Slot def doLoadGraph(self): pass # Schnittstelle def setStations(self, stations): pass # Test if __name__ == '__main__': ur = Urlreader(poBaseURL + \"/stations.json\") data = ur.getJsonResponse() app = QApplication(sys.argv) w = PoGraphDisplay() w.setStations(data) w.show() sys.exit(app.exec_()) Die Widgets im Widget Das oben gezeigte Fenster mit dem PoGraphDisplay-Widget besitzt neben einigen QLabel-Widgets eine QComboBox um eine Station auszuw\u00e4hlen, eine QSpinBox um die Anzahl der Tage festzulegen, f\u00fcr die das Diagramm ausgegeben wird (max. sind es 30 Tage...), einen QPushButton um die Eingaben umzusetzen und die Graphik anzuzeigen, und darunter ein weiters QLabel-Widget zur Anzeige der Graphik. Als Layout bietet sich auch hier eine Kombination aus vertikalem und horizontalen Layouts an. def setupUI(self): # \u00fcbergeordnetes Layout self.verticalLayout = QtWidgets.QVBoxLayout(self) # erste Zeile self.horizontalLayout = QtWidgets.QHBoxLayout() # mehrere Widget horizontal ... self.verticalLayout.addLayout(self.horizontalLayout) # zweite Zeile # nur ein Label widget self.lbGraph = QtWidgets.QLabel() self.verticalLayout.addWidget(self.lbGraph) # dritte Zeile: Spacer! # dritte Zeile spacerItem = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding) self.verticalLayout.addItem(spacerItem) Die Box-Layouts versuchen stets die gesamte zur Verf\u00fcgung stehende Fl\u00e4che ausf\u00fcllen, das QVBoxLayout in der H\u00f6he und das QHBoxLayout in der Beite. F\u00fcgen Sie der ersten Zeile (also dem horizontalLayout ) die Widgets zu, um den Effekt zu sehen. In der dritten Zeile habe ich ein QSpacerItem eingesetzt, dieser sorgt daf\u00fcr, dass in der vertikalen Richtung die Zeilen zusammengeschoben werden. Im folgenden habe ich den Widgets folgende Variablennamen gegeben: self.lbStation, zeigt Text \"Station\" an self.comboBox, f\u00fcr Stationsnamen self.lbTage, zeigt Text \"Tage\" an self.sbDays, die SpinBox, Anzahl der Tage, Min.: 5, Max.: 30, vorgegeben: 14 self.pbLoad, der PushButton mit dem Text \"Laden\". self.lbGraph, zeigt nichts an, bis eine Graphik geladen wurde Anzeige der Stationsnamen Im Widget stehen die Stationsnamen in der ComboBox, die \u00fcber setStations bef\u00fcllt werden kann: def setStations(self, stations): self.comboBox.clear() for e in stations: name = e['shortname'] self.comboBox.addItem(name) self.comboBox.setCurrentIndex(0) Neben der \u00dcbergabe der json-Daten als Liste mit Dictionarys, sollten wir auch eine Liste mit Strings akzeptieren. Entweder als weitere Variante von setStations oder durch ein if-Statement innerhalb der Methode. Geeignet w\u00e4re z.B. die Funktion isinstance() , die True zur\u00fcckgibt, wenn ein Objekt aus der angegebenen Klasse abgeleitet wurde: if isinstance(e, dict): pass elif isinstance(e, str): pass else: pass Signal-Slots im PoGraphDisplay-Widget Wir ben\u00f6tigen nur ein Event, dass ausgel\u00f6st wird, wenn der Nutzer den pbLoad-Button anklickt. Daf\u00fcr ist es wichtig, dass die ComboBox und die sbDays g\u00fcltige Werte haben, denn diese werden innerhalb des slots ausgelesen. Ich habe den Slot mit der Methode doLoadGraph belegt: # einf\u00fcgen in initUI: self.pbLoad.clicked.connect(self.doLoadGraph) def doLoadGraph(self): # Anzahl der Tage in der SpinBox days = days = self.sbDays.value() # Name der Station aus der ComboBox station = quote(self.comboBox.currentText()) # benutze quote() f\u00fcr die url print(\"Lade den Graphen\") # url zusammenbauen # Urlreader mit getDataResponse # Fehler-Code abfragen (es gibt Stationen ohne Wasserstandsdaten) # wenn ok, dann Graphik einsetzen pixmap = QtGui.QPixmap() pixmap.loadFromData(img_data) # img_data als Ergebnis von getDataResponse self.lbGraph.setPixmap(pixmap) self.lbGraph.resize(pixmap.width(), pixmap.height()) Die Anweisungen zur Anzeige der Graphik gehen davon aus, dass sie eine g\u00fclige Grafik zugewiesen bekommen. Die Anzeige im lbGraph-Widget wird entsprechend der Gr\u00f6\u00dfe der Grafik angepasst. Ansonsten m\u00fcssen zun\u00e4chst eine g\u00fcltige url gebildet, diese mit dem Urlreader abgerufen und ein Fehlercode abgefragt werden (Es gibt immer einen Code, Fehler liegen im Zahlenbereich > 299) QtDesigner Mit dem Qt-Designer k\u00f6nnen GUI's und Widgets interaktiv erstellt werden. Hier gibt eine kurze Einf\u00fchrung . Der QtDesigner ist Teil der PyQt-Installation. :Aufruf des QtDesigners","title":"Python und Qt"},{"location":"ch02/p03_pyqt5.html#graphische-benutzeroberfachen","text":"","title":"Graphische Benutzeroberf\u00e4chen"},{"location":"ch02/p03_pyqt5.html#einfuhrung","text":"","title":"Einf\u00fchrung"},{"location":"ch02/p03_pyqt5.html#gui-programmierung","text":"Eine Anwendung mit graphischer Benutzeroberfl\u00e4che (GUI) programmieren Ein GUI setzt sich aus Fensterelementen zusammen (Widgets): Men\u00fc, Statusleiste, Formulare, Listenfelder, Textfelder, etc Elemente werden in Bibliotheken vorgehalten Oft vom Betriebssystem abh\u00e4ngig: Windows, Mac, aber auch: Plattform\u00fcbergreifende WidgetSets, integrieren sich in ein Gast-System (z.B. Windows) QGIS benutzt die Qt-Widgets f\u00fcr das eigene GUI F\u00fcr Python existiert das Modulpaket PyQt5 Plugins f\u00fcr QGIS werden mit pyqt5 entwickelt eine simple und minimale Anwendung","title":"GUI-Programmierung"},{"location":"ch02/p03_pyqt5.html#begriffe-aus-der-gui-welt","text":"Widget = Window Gadget: Ein \"Fensterdingsbums\", kleinster Teil eines GUI Dialog = ein aus 1..n Widgets bestehende GUI zur Realisierung einer spezifischen Nutzerinteraktion, oft auch als Formular bezeichnet (s. Abb.) MainWindow = Hauptfenster einer Applikation, mit Buttons und Men\u00fcs, welche bestimmte Funktionen ausf\u00fchren oder Dialoge aufrufen (s. QGIS) GUI = Graphical User Interface: Graphische Benutzerschnittstelle; Oberbegriff Maus+Tastatur+Bildschirm (oder andere Eingaben mit graphischer R\u00fcckmeldung) Ereignis-Programmierung: Fensterobjekte\u2013 Datenobjekte \u2013 Eingabeobjekte interagieren miteinander und manipulieren sich gegenseitig H\u00e4ufig verwendete QtGUI-Widgets in Dialogen Qt arbeitet auch der Basis von Events nach Signal-Slot-Schema . Es werden hierbei Nachrichten von Fensterelementen (Signal) an einen festen Adressaten (Slot) gesendet, der Adressat ist in der Regel eine Funktion/Methode Qt5-Dokumentation . Erfolgt eine Steuerung z.B. \u00fcber touch-sensitive Ger\u00e4te, so werden zu den Widgets passende Events benutzt, die auf die Ber\u00fchung mit Fingern reagieren.","title":"Begriffe aus der GUI-Welt"},{"location":"ch02/p03_pyqt5.html#dokumentation","text":"PyQt5 Reference Guide Qt5-Dokumentation \u00dcbersicht python.org","title":"Dokumentation"},{"location":"ch02/p03_pyqt5.html#aufbau-einer-pyqt5-anwendung","text":"","title":"Aufbau einer PyQt5-Anwendung"},{"location":"ch02/p03_pyqt5.html#hello-world","text":"Ben\u00f6tigte Module importieren und Funktion main() einrichten import sys from PyQt5.QtWidgets import * def main(argv): pass if __name__ == '__main__': main(sys.argv) Die Anwendung kann auch Kommandozeilenargumente verarbeiten, daher wird sys.argv \u00fcbergeben. Jede PyQt-GUI-Anwendung ben\u00f6tigt ein QApplication Objekt. Dieses stellt allgemeine Informationen wie z.B. das Anwendungsdirectory, Bildschirmparameter und v.A. den Event-Loop zur Verf\u00fcgung. import sys from PyQt5.QtWidgets import QApplication, QTextEdit def main(argv): # each Qt-Programm needs an application object app = QApplication(argv) # to show the string Hello World in a window textEdit = QTextEdit() textEdit.setText(\"Hello World\") # show window textEdit.show() app.exec_() if __name__ == '__main__': main(sys.argv) Ein QTextEdit Widget wird erstellt: In PyQt kann jedes Widget als Top-Level Fenster dienen. Ist dies der Fall, wird ihm automatisch die typische Titelzeile und u.a. der X-Button verliehen. Nachfolgend wird ein \"paint event\" zur Anzeige des Widgets in den Event-Loop eingesetzt. Damit steht die Anzeige des Widgets in der Warteschleife. Schlie\u00dflich muss man den Event-Loop starten, das Widget erscheint am Bildschirm, bis X gedr\u00fcckt wird. textEdit.resize(250, 450) textEdit.move(300, 300) textEdit.setWindowTitle('Simple') # show window textEdit.show() app.exec_() Ein QTextEdit als top level widget erlaubt es, Parameter des Fensters zu setzen","title":"Hello World"},{"location":"ch02/p03_pyqt5.html#objektorientierung","text":"Ein Dialog-Fenster mit Textfeld wird als Klasse definiert: import sys from PyQt5.QtWidgets import (QApplication, QDialog, QTextEdit, QVBoxLayout) class MyForm(QDialog): def __init__(self): QDialog.__init__(self) self.textEdit = QTextEdit('Hello World!') self.textEdit.selectAll() layout = QVBoxLayout() layout.addWidget(self.textEdit) self.setLayout(layout) app = QApplication(sys.argv) form = MyForm() form.show() app.exec_() self ist das Dialogobjekt ein QVBoxLayout-Objekt ordnet andere Widgets vertikal an setLayout() ist eine Methode, um in dem Dialog self ein QTextFeld anzuzeigen self.textEdit: unter dieser Variable bleibt das Textfeld ansprechbar","title":"Objektorientierung"},{"location":"ch02/p03_pyqt5.html#events-mit-signals-and-slots","text":":Herk\u00f6mmliches und Event-basiertes Programm Events als Nachrichten zwischen Objekten Jedes Widget kennt eigene Events und kann eine Funktion vorsehen, um diese zu verarbeiten Signals and Slots, als Konzept, definiert ein Signal, etwa 'clicked()' f\u00fcr ein QPushButton, das einen Slot in einem anderen Objekt (dem Empf\u00e4nger) belegt, und dort eine Funktion ausf\u00fchrt. Die Basis hierf\u00fcr ist die Funktion connect, die jedes Qt-Objekt ausf\u00fchren kann QObject.[signal_name].connect(function) z.B. das Push-Button-Widget pbOK soll ein click-Event ausl\u00f6sen und \u00fcber die Funktion doOK() verarbeiten: pbOK.clicked.connect(doOK)","title":"Events mit Signals and Slots"},{"location":"ch02/p03_pyqt5.html#hello-world-mit-ok-button","text":"import sys from PyQt5.QtWidgets import (QApplication, QDialog, QTextEdit, QVBoxLayout, QPushButton) # new class MyForm(QDialog): def __init__(self): QDialog.__init__(self) self.textEdit = QTextEdit('Hello World!') self.textEdit.selectAll() self.buttonOK = QPushButton() # new self.buttonOK.setText('OK') layout = QVBoxLayout() layout.addWidget(self.textEdit) layout.addWidget(self.buttonOK) #new self.setLayout(layout) self.buttonOK.clicked.connect(self.doOK) # new def doOK(self): # new self.textEdit.setText(\"Hello PyQt5!\") app = QApplication(sys.argv) form = MyForm() form.show() app.exec_() Noch ein Signal and Slot? Wir nehmen den Button zum Schlie\u00dfen des Fensters: self.buttonOK.clicked.connect(self.doOK) # den Button haben wir schon... self.pbOK.clicked.connect(self.close) # QDialog besitzt bereits einen Slot 'close' In einer Class referenziert self immer das aus der Klasse abgeleitete Objekt. self.close wurde zwar nicht in der class MyForm definiert, aber in der vererbenden Klasse QDialog . Zus\u00e4tzlich k\u00f6nnen wir aber auch die Methode close des QDialogs \u00fcberschreiben: def close(self): print(self.textEdit.toPlainText()) QDialog.close(self) https://pythonspot.com/gui/","title":"'Hello World' mit OK-Button"},{"location":"ch02/p03_pyqt5.html#qt-layout","text":"Sehr umfangreiche Layout-Einstellungen QVBoxLayout und QHBoxLayout oder QGridLayout bieten grundlegende M\u00f6glichkeiten zum Layout erweitertes Beispiel zu Hello World zeigt den Einsatz Layout k\u00f6nnen auch geschachtelt werden, d.h. ein layout kann ein anderes enthalten def __init__(self): # Widgets self.textEdit = QTextEdit('Hello World!') self.textEdit.selectAll() self.lblText = QLabel() self.lblText.setText(\"Editor\") self.buttonOK = QPushButton() self.buttonOK.setText('OK') self.buttonEsc = QPushButton() self.buttonEsc.setText('Beenden') # \u00fcbergeordnetes Layout erstellen self.vlayout = QVBoxLayout(self) self.hlayout = QHBoxLayout() self.vlayout.addWidget(self.lblText) self.vlayout.addWidget(self.textEdit) # Button horizontal darunter anordnen self.hlayout.addWidget(self.buttonOK) self.hlayout.addWidget(self.buttonEsc) # hor. layout zu vert layout hinzuf\u00fcgen self.vlayout.addLayout(self.hlayout) self.buttonOK.clicked.connect(self.doOK) self.buttonEsc.clicked.connect(self.close)","title":"Qt-Layout"},{"location":"ch02/p03_pyqt5.html#dialoge","text":"Wir unterscheiden: Dialogboxen, die bereits als Klassen bestehen: Nachricht mit Ja/Nein, File Save/File Open, Farbwahl, Eingabezeile etc. Dokumentation Eigene Formulare und Dialoge auf Basis von QDialog sind an ein anderes Widget (z.B. MainWindow) gebunden k\u00f6nnen modal oder unabh\u00e4ngig sein geben einen Wert zur\u00fcck Schema eines modalen Dialogs","title":"Dialoge"},{"location":"ch02/p03_pyqt5.html#bestehende-dialoge","text":"Ein Dialog f\u00fcr eine Eingabe: def doOK(self): # new # open Input-Dialog text, ok = QInputDialog.getText(self, 'Editor', 'Neuer Text:') if ok: self.textEdit.setText(text) else: self.textEdit.setText(\"Hello PyQt5!\") liefert einen String zur\u00fcck und au\u00dferdem den Wert f\u00fcr OK mit true bzw. false, je nachdem, ob der Benutzer OK geklickt hat, ober nicht. Ein kleines Beispiel zum Aufruf eines MessageBox-Dialogs import sys from PyQt5.QtWidgets import * def callDialog(): result = QMessageBox.question(w, 'Message', \"Do you like Python?\", QMessageBox.Yes | QMessageBox.No, QMessageBox.No) if result == QMessageBox.Yes: print(\"yes\") else: print(\"no\") app = QApplication(sys.argv) w = QPushButton('Ask me...') w.clicked.connect(callDialog) w.show() app.exec_() Ein Beispiel f\u00fcr den Aufruf verschiedener Dialoge aus dem ZetCode PyQt4 tutorial von Jan Bodnar und pythonspot : import sys from PyQt5.QtWidgets import QApplication, QWidget, QInputDialog, QLineEdit from PyQt5.QtGui import QIcon class App(QWidget): def __init__(self): super().__init__() self.title = 'PyQt5 input dialogs - pythonspot.com' self.left = 10 self.top = 10 self.width = 640 self.height = 480 self.initUI() def initUI(self): self.setWindowTitle(self.title) self.setGeometry(self.left, self.top, self.width, self.height) self.getInteger() self.getText() self.getDouble() self.getChoice() self.show() def getInteger(self): i, okPressed = QInputDialog.getInt(self, \"Get integer\",\"Percentage:\", 28, 0, 100, 1) if okPressed: print(i) def getDouble(self): d, okPressed = QInputDialog.getDouble(self, \"Get double\",\"Value:\", 10.50, 0, 100, 10) if okPressed: print( d) def getChoice(self): items = (\"Red\",\"Blue\",\"Green\") item, okPressed = QInputDialog.getItem(self, \"Get item\",\"Color:\", items, 0, False) if ok and item: print(item) def getText(self): text, okPressed = QInputDialog.getText(self, \"Get text\",\"Your name:\", QLineEdit.Normal, \"\") if okPressed and text != '': print(text) if __name__ == '__main__': app = QApplication(sys.argv) ex = App() sys.exit(app.exec_()) Die einzelnen Dialoge sind auch konfigurierbar. Hier die Varianten f\u00fcr den QFileDialog import sys from PyQt5.QtWidgets import QApplication, QWidget, QInputDialog, QLineEdit, QFileDialog from PyQt5.QtGui import QIcon class App(QWidget): def __init__(self): super().__init__() self.title = 'PyQt5 file dialogs - pythonspot.com' self.left = 10 self.top = 10 self.width = 640 self.height = 480 self.initUI() def initUI(self): self.setWindowTitle(self.title) self.setGeometry(self.left, self.top, self.width, self.height) self.openFileNameDialog() self.openFileNamesDialog() self.saveFileDialog() self.show() def openFileNameDialog(self): options = QFileDialog.Options() options |= QFileDialog.DontUseNativeDialog fileName, _ = QFileDialog.getOpenFileName(self,\"QFileDialog.getOpenFileName()\", \"\",\"All Files (*);;Python Files (*.py)\", options=options) if fileName: print(fileName) def openFileNamesDialog(self): options = QFileDialog.Options() options |= QFileDialog.DontUseNativeDialog files, _ = QFileDialog.getOpenFileNames(self,\"QFileDialog.getOpenFileNames()\", \"\",\"All Files (*);;Python Files (*.py)\", options=options) if files: print(files) def saveFileDialog(self): options = QFileDialog.Options() options |= QFileDialog.DontUseNativeDialog fileName, _ = QFileDialog.getSaveFileName(self,\"QFileDialog.getSaveFileName()\",\"\",\"All Files (*);;Text Files (*.txt)\", options=options) if fileName: print(fileName) if __name__ == '__main__': app = QApplication(sys.argv) ex = App() sys.exit(app.exec_())","title":"Bestehende Dialoge"},{"location":"ch02/p03_pyqt5.html#aufgabe-ein-eigenes-widget-zur-anzeige-des-pegelverlaufs","text":"Eigenes Widget zur Darstellung des Pegelverlaufs Das Widget ist eigentlich eine Kombination aus bestehenden Qt-Widgets. Allerdings soll es einen sehr speziellen Zweck erf\u00fcllen: Der Benutzer soll mit diesem Widget eine Station \u00fcber ihren Namen ausw\u00e4hlen k\u00f6nnen und das Widget l\u00e4dt anschlie\u00dfend die entsprechende Graphik in das Fenster. Es basiert auf einer Abfrage von Pegelonline in dieser Form: stations/BONN/W/measurements.png?start=P15D Der Vorteil eines eigenen Widgets: Es k\u00f6nnen Funktion und Bedienung festgelegt werden und in eine gr\u00f6\u00dfere Anwendung, ein GUI, integriert werden. Hierbei legen wir eine Schnittstelle fest, mit der das Widget gesteuert werden kann. Dies kann im einfachsten Fall das Eintagen der Stationsnamen sein. Das Widget selbst importiert unser Modul Urlreader, um die Graphiken zu einer Station zu laden. Hier ein Entwurf f\u00fcr das PoGraphDisplay-Widget als Python-Code: import sys from PyQt5 import QtWidgets from PyQt5 import QtCore, QtGui from pomodules.urlreader import Urlreader, quote from pomodules import poBaseURL class PoGraphDisplay(QWidget): def __init__(self): super().__init__() # Aufbau der Elemente im Widget self.initUI() def initUI(self): pass # Slot def doLoadGraph(self): pass # Schnittstelle def setStations(self, stations): pass # Test if __name__ == '__main__': ur = Urlreader(poBaseURL + \"/stations.json\") data = ur.getJsonResponse() app = QApplication(sys.argv) w = PoGraphDisplay() w.setStations(data) w.show() sys.exit(app.exec_())","title":"Aufgabe ein eigenes Widget zur Anzeige des Pegelverlaufs"},{"location":"ch02/p03_pyqt5.html#die-widgets-im-widget","text":"Das oben gezeigte Fenster mit dem PoGraphDisplay-Widget besitzt neben einigen QLabel-Widgets eine QComboBox um eine Station auszuw\u00e4hlen, eine QSpinBox um die Anzahl der Tage festzulegen, f\u00fcr die das Diagramm ausgegeben wird (max. sind es 30 Tage...), einen QPushButton um die Eingaben umzusetzen und die Graphik anzuzeigen, und darunter ein weiters QLabel-Widget zur Anzeige der Graphik. Als Layout bietet sich auch hier eine Kombination aus vertikalem und horizontalen Layouts an. def setupUI(self): # \u00fcbergeordnetes Layout self.verticalLayout = QtWidgets.QVBoxLayout(self) # erste Zeile self.horizontalLayout = QtWidgets.QHBoxLayout() # mehrere Widget horizontal ... self.verticalLayout.addLayout(self.horizontalLayout) # zweite Zeile # nur ein Label widget self.lbGraph = QtWidgets.QLabel() self.verticalLayout.addWidget(self.lbGraph) # dritte Zeile: Spacer! # dritte Zeile spacerItem = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding) self.verticalLayout.addItem(spacerItem) Die Box-Layouts versuchen stets die gesamte zur Verf\u00fcgung stehende Fl\u00e4che ausf\u00fcllen, das QVBoxLayout in der H\u00f6he und das QHBoxLayout in der Beite. F\u00fcgen Sie der ersten Zeile (also dem horizontalLayout ) die Widgets zu, um den Effekt zu sehen. In der dritten Zeile habe ich ein QSpacerItem eingesetzt, dieser sorgt daf\u00fcr, dass in der vertikalen Richtung die Zeilen zusammengeschoben werden. Im folgenden habe ich den Widgets folgende Variablennamen gegeben: self.lbStation, zeigt Text \"Station\" an self.comboBox, f\u00fcr Stationsnamen self.lbTage, zeigt Text \"Tage\" an self.sbDays, die SpinBox, Anzahl der Tage, Min.: 5, Max.: 30, vorgegeben: 14 self.pbLoad, der PushButton mit dem Text \"Laden\". self.lbGraph, zeigt nichts an, bis eine Graphik geladen wurde","title":"Die Widgets im Widget"},{"location":"ch02/p03_pyqt5.html#anzeige-der-stationsnamen","text":"Im Widget stehen die Stationsnamen in der ComboBox, die \u00fcber setStations bef\u00fcllt werden kann: def setStations(self, stations): self.comboBox.clear() for e in stations: name = e['shortname'] self.comboBox.addItem(name) self.comboBox.setCurrentIndex(0) Neben der \u00dcbergabe der json-Daten als Liste mit Dictionarys, sollten wir auch eine Liste mit Strings akzeptieren. Entweder als weitere Variante von setStations oder durch ein if-Statement innerhalb der Methode. Geeignet w\u00e4re z.B. die Funktion isinstance() , die True zur\u00fcckgibt, wenn ein Objekt aus der angegebenen Klasse abgeleitet wurde: if isinstance(e, dict): pass elif isinstance(e, str): pass else: pass","title":"Anzeige der Stationsnamen"},{"location":"ch02/p03_pyqt5.html#signal-slots-im-pographdisplay-widget","text":"Wir ben\u00f6tigen nur ein Event, dass ausgel\u00f6st wird, wenn der Nutzer den pbLoad-Button anklickt. Daf\u00fcr ist es wichtig, dass die ComboBox und die sbDays g\u00fcltige Werte haben, denn diese werden innerhalb des slots ausgelesen. Ich habe den Slot mit der Methode doLoadGraph belegt: # einf\u00fcgen in initUI: self.pbLoad.clicked.connect(self.doLoadGraph) def doLoadGraph(self): # Anzahl der Tage in der SpinBox days = days = self.sbDays.value() # Name der Station aus der ComboBox station = quote(self.comboBox.currentText()) # benutze quote() f\u00fcr die url print(\"Lade den Graphen\") # url zusammenbauen # Urlreader mit getDataResponse # Fehler-Code abfragen (es gibt Stationen ohne Wasserstandsdaten) # wenn ok, dann Graphik einsetzen pixmap = QtGui.QPixmap() pixmap.loadFromData(img_data) # img_data als Ergebnis von getDataResponse self.lbGraph.setPixmap(pixmap) self.lbGraph.resize(pixmap.width(), pixmap.height()) Die Anweisungen zur Anzeige der Graphik gehen davon aus, dass sie eine g\u00fclige Grafik zugewiesen bekommen. Die Anzeige im lbGraph-Widget wird entsprechend der Gr\u00f6\u00dfe der Grafik angepasst. Ansonsten m\u00fcssen zun\u00e4chst eine g\u00fcltige url gebildet, diese mit dem Urlreader abgerufen und ein Fehlercode abgefragt werden (Es gibt immer einen Code, Fehler liegen im Zahlenbereich > 299)","title":"Signal-Slots im PoGraphDisplay-Widget"},{"location":"ch02/p03_pyqt5.html#qtdesigner","text":"Mit dem Qt-Designer k\u00f6nnen GUI's und Widgets interaktiv erstellt werden. Hier gibt eine kurze Einf\u00fchrung . Der QtDesigner ist Teil der PyQt-Installation. :Aufruf des QtDesigners","title":"QtDesigner"},{"location":"ch02/pyqgis.html","text":"QGIS und Python Innerhalb von QGIS existiert eine umfangreiche Python-Schnitstelle. Ausgangspunkt ist das Modul \"qgis\". Um die Funktionen nutzen zu k\u00f6nnen, kann zwar auch eine reine Python-Anwendung geschrieben werden. \u00dcblicherweise wird aber mit der Python-Shell innerhalb von QGIS gearbeitet. QGIS unterst\u00fctzt dar\u00fcber hinaus Erweiterungen in Form von PlugIns oder als Verarbeitungswerkzeug (Processing-Scrpte). Ressourcen Umfangreiches Cookbook . Beschreibung der API - C++ Speziell aufbereitet f\u00fcr [Python] (http://geoapis.sourcepole.com/qgispyapi/) Code-Beispiele f\u00fcr Python-Classes der API Das pyqgis-Modul (qgis) Ein Modul mit Untermodulen f\u00fcr den den Zugang der QGIS-Funktionen und Benutzeroberf\u00e4che, aufgeteilt in die Untermodule core gui utils analysis weitere ... qgis.utils.iface entspricht dabei einer Schnittstelle zu den aktiven Elementen von QGIS, etwa zum Kartenfenster und den dort angezeigten Layern. Beispiele f\u00fcr das QGIS-Python-Fenster >>> qgis.utils.iface >>> iface >>> aLayer = qgis.utils.iface.activeLayer() >>> aLayer.name >>> aLayer.name() >>> help(aLayer) Zugriff auf das Kartenfenster (canvas: Leinwand ) >>> canvas = qgis.utils.iface.mapCanvas() >>> cLayer = canvas.currentLayer() >>> print cLayer.name() >>> canvas.layer(0) Kartendaten laden >>> iface.addVectorLayer(r\"fluss_gwk4_utm32.shp\", \"Fluss\", \"ogr\") >>> iface.addRasterLayer(r\"brd_dgm_utm.tif\", \"DGM\", \"gdal\") Die Add-Funktionen geben das Layer-Objekt zur\u00fcck! Cookbook-Kapitel zu Vektorlayern und Rasterlayern ! Layer-Informationen und Datenzugriff Die for-Schleife durchl\u00e4uft alle geladenen Layer und gibt Informationen zu jedem einzelnen aus: for layer in qgis.utils.iface.mapCanvas().layers(): if type(layer) == qgis.core.QgsVectorLayer: print \"--- vector\", layer.name() print \"--- geometry type:\", layer.wkbType() elif type(layer) == qgis.core.QgsRasterLayer: print \"--- raster\", layer.name() print \"--- raster type\", layer.rasterType() Der WKB-Typ entspricht der Definition der Simple-Features f\u00fcr Vektordaten, dabei wird jeder Typ durch eine Zahl angegeben. Eine vergleichbare Angane bei Rasterdaten ist der Raster-Typ, auch dieser ist durch Zahlen angegeben. Diese Tabelle zeigt die m\u00f6glichen Werte: wkbType() -> Zahl: rasterType() -> Zahl: QGis.WKBPoint ->(1) Single band ->(0), QGis.WKBLineString ->(2) Single band (Palette) ->(1) QGis.WKBPolygon ->(3) Multiband ->(2) QGis.WKBMultiPoint ->(4) QGis.WKBMultiLineString ->(5) QGis.WKBMultiPolygon ->(6) Der Data-Provider bietet Zugriff auf den Layer und dessen Daten. Der Zugriff ist davon abh\u00e4ngig, welcher Provider benutzt wurde. (Im Beispiel 'ogr' f\u00fcr Shapefiles, anders sieht das z.B. f\u00fcr Tabellen in einer Datenbank aus...) provider = iface.mapCanvas().layer(0).dataProvider() print provider.name() for feat in provider.getFeatures(): # wir tun irgendwas mit dem Feature pass # oder kurz und \u00fcber iface aLayer = qgis.utils.iface.activeLayer() for feat in aLayer.getFeatures(): # wir tun irgendwas mit dem Feature pass Die for-Schleifen durchlaufen jeweils alle Features eines Layers. Das funktioniert, wie im zweiten Fall gezeigt, auch ohne data provider . Ein Beispiel f\u00fcr Raster-Layer: \u00dcber den Provider fragen wir den Pixel-Wert (z-Wert im DGM) an einer Punkt-Koordinate ab: # Rasterlayer in Legende markiert: canvas = iface.mapCanvas() rlayer = canvas.currentLayer() # Lage und Ausdehnung des Rasters print rlayer.extent().toString() # Koordinate innerhalb des Rasters x = 571000 y = 5697000 res = rlayer.dataProvider().identify(QgsPoint(x, y), QgsRaster.IdentifyFormatValue) print res.results() Wir benutzen die Funktion identify(), um auf Rasterwerte an einer Koordinate zuzugreifen\u2026 Feature-Objekte Vektordaten benutzen Features als Objekte. Features eines Datensatzes verf\u00fcgen daher \u00fcber eine Geometrie: feature.geometry() -> gibt ein Geometrieobjekt zur\u00fcck \u00fcber Attribute: feature.attributes() -> gibt eine Liste mit Werten zur\u00fcck Geometrien unterst\u00fctzen die Grundtypen Point, Line und Polygon, die letzten beiden k\u00f6nnen aber intern als MultiLine oder MultiPolygon gespeichert sein! geom.type(): Typ einer Geometrie, wird als Zahl ausgedr\u00fcckt. Die Konstanten QGis.Point, QGis.Line und QGis.Polygon k\u00f6nnen zum Vergleich benutzt werden. geom.wkbType(): Typ nach WKB-Norm, besser differenziert, mit MultiPart-Typen geom.asXXX(): Methode zur Umwandlung in Listen, z.B. asPolyline() -> Liste mit Punkten ( Hinweis: Punkte erscheinen wie Tuple, sind aber Punkt-Objekte: z.B.: type(geom.asPolyline()[0]) -> Attribute k\u00f6nnen auch im Stil eines Dictionary zugegriffen werden: z.B.: feature['NAME'] , wenn NAME ein Feld des Layers ist. Beispiel # vector layer is selected layer = iface.activeLayer() iter = layer.getFeatures() # wir geben nur die ersten 10 Features aus stop = 10 i = 0 for feature in iter: if i >= stop: break else: i+=1 # retrieve every feature with its geometry and attributes # fetch geometry geom = feature.geometry() print \"Feature ID %d: \" % feature.id(), \"Geometry: %d-%d\"% (geom.type(), geom.wkbType()) das Script greift im weiteren Verlauf auf die Geometrie zu: # inside the for loop # show some information about the feature if geom.type() == QGis.Point: x = geom.asPoint() print \"Point: \" + str(x) elif geom.type() == QGis.Line: # check according to wkbType x = geom.asPolyline() # asMultiPolyline() # we count number of points numPts = len(x) ##numPts = 0 # if wkb says MultiPolyline ##for lstring in x: ## numPts += len(lstring) print \"Line: %d points\" % numPts elif geom.type() == QGis.Polygon: x = geom.asPolygon() # could also be a MultiPolygon: see MultiPolyline numPts = 0 for ring in x: numPts += len(ring) print \"Polygon: %d rings with %d points\" % (len(x), numPts) else: print \"Unknown\" # fetch attributes attrs = feature.attributes() # attrs is a list. It contains all the attribute values of this feature print attrs Koordinatensysteme und Transformation Beispiel f\u00fcr eine Transformation zwischen Koordinatensystemen: crsSrc = QgsCoordinateReferenceSystem(4326) # WGS 84 crsDest = QgsCoordinateReferenceSystem(32633) # WGS 84 / UTM zone 33N xform = QgsCoordinateTransform(crsSrc, crsDest) # forward transformation: src -> dest pt1 = xform.transform(QgsPoint(18,5)) print \"Transformed point:\", pt1 # inverse transformation: dest -> src pt2 = xform.transform(pt1, QgsCoordinateTransform.ReverseTransform) print \"Transformed back:\", pt2 Aufgabe 1: Z-Wert einer Station aus dem DGM ermitteln Abfrage des z-Werts aus dem Raster zur Koordinate einer Station (Stationsh\u00f6he), dazu transformieren wir die Punktangabe (WGS84) zun\u00e4chst in das System des DGM (EPSG-Code 25832 f\u00fcr die UTM-Zone 32(ETRS)) Aufgabe 2: Z-Werte eines Flusses Wir wollen f\u00fcr einen Fluss feststellen, welche Z-Werte er hat. Dazu vergleichen wir die Koordinaten seiner St\u00fctzpunkte mit den Rasterwerten des DGM an den entsprechenden Positionen. Beide Layer \u00f6ffnen wir zuvor in QGIS, mit dem Vektoren als ersten und dem DGM als zweiten Layer. Zugriff auf einen Fluss Beispielsweise testen wir den Fluss Nette . Dieses Script selektiert die einzelnen Features mit dem Namen Nette. Der Ausdruck zur Suche setzt die Spaltennamen in doppelte Hochkommata, Strings in einfache Hochkommata. Daher verwenden wir die Python-Notation f\u00fcr ganzen Suchausdruck als Python-String in dreifache Hochkommata... sLayer = iface.mapCanvas().layers()[0] expr = QgsExpression( \"\"\"\"NAM\\\"='Nette'\"\"\") sel = sLayer.getFeatures( QgsFeatureRequest( expr ) ) ids = [i.id() for i in sel] sLayer.setSelectedFeatures(ids) das zur\u00fcckgegebene Objekt sel beinhaltet eine Aufz\u00e4hlung (QgsFeatureIterator), welche wir in einer for-Schleife abarbeiten k\u00f6nnen! Wie wir sehen, ist der Name nicht eindeutig, hier benutzen wir stattdessen die offizielle Gew\u00e4sserkennziffer: sLayer = iface.mapCanvas().layers()[0] expr = QgsExpression( \"\"\"\"GWK\"=2714000000000000000\"\"\" ) sel = sLayer.getFeatures( QgsFeatureRequest( expr ) ) sLayer.setSelectedFeatures(ids) # Zoom auf die Bounding-Box des Flusses box = sLayer.boundingBoxOfSelected() iface.mapCanvas().setExtent(box) iface.mapCanvas().refresh() Wir durchlaufen die Selektion for feat in sel: g = feat.geometry() l = g.Polyline() print l Anstelle von print l realisieren Sie den Zugriff auf alle Punkte, ermitteln deren z-Werte durch Zugriff auf das Raster und geben x,y,z auf der Konsole aus. Spatialite Layer Wir greifen auf unseres Spatialite Datenbank zu: dbname = r\"C:/temp/station.sqlite\" uri = QgsDataSourceURI() uri.setDatabase(dbname) schema = '' table = 'poStation' geom_column = 'geom' uri.setDataSource(schema, table, geom_column) # eine 'uri' f\u00fcr den Zugriff display_name = 'Stationen' self.vlayer = QgsVectorLayer(uri.uri(), display_name, 'spatialite') QgsMapLayerRegistry.instance().addMapLayer(self.vlayer) Ein Zugriff \u00fcber eine SQL-Abfrage Diese Abfrage setzt die beiden Tabellen f\u00fcr Stationen und aktuelle Werte voraus, die \u00fcber ihre uuid \"gejoint\" werden. Anstelle des Tabellennamens setzen wir eine SQL-Abfrage ein. Siehe auch den Post auf stackexchange . dbname = r\"C:\\temp\\station.sqlite\" sConnect = \"dbname='\" + dbname +\"'\" table = \"SELECT poStation.number, pgolCurrentW.uuid, poStation.geom, \" + \\ \"pgolCurrentW.timestamp, pgolCurrentW.value, pgolCurrentW.trend \" + \\ \"FROM pgolCurrentW, poStation \" + \"WHERE pgolCurrentW.uuid == poStation.uuid\" uri = sConnect + \" key='number'\" + \"table=\\\"(%s)\\\" (geom) sql=\" % table display_name = 'Stationen' print \"loading:%s as %s\" % (sConnect, display_name) print uri vlayer = QgsVectorLayer(uri, display_name, 'spatialite') if vlayer.isValid(): QgsMapLayerRegistry.instance().addMapLayer(vlayer) else: print \"can't add layer!\" Darstellung eines Layers ver\u00e4ndern Ein Beispiel zur \u00c4nderung der Graphik eines Layers. Wir orientieren uns an den Daten von Pegelonline und richten ein Render-Objekt vom Typ QgsCategorizedSymbolRendererV2 ein, um die Pegelst\u00e4nde nach dem Attribute Trend zu unterscheiden. Der Wert \"-1\" steht f\u00fcr fallend und bekommt die F\u00fcllfarbe \"green\", der Wert \"0\", konstant , bekommt die Farbe \"blue\" und der Wert \"1\", steigend , die Farbe \"red\" zugeordnet. Der QgsCategorizedSymbolRendererV2 benutzt dazu eine Liste von QgsRendererCategoryV2-Objekten, die aus der Angabe eines Werts und einem QgsSymbolV2 mit der entsprechenden F\u00fcllfarbe (in unserem Fall) bestehen. Diese Werte der Kategorien werden mit den Werten eines Layers verglichen und die Grafik zugeordnet. Mit einem refresh des Kartenfensters werden die neuen Einstellungen dann angezeigt. from PyQt4.QtGui import QColor # Layer zugreifen lay = iface.mapCanvas().layers()[0] # Kategorien festlegen pegel = { -1:(\"green\", \"fallend\"), 0:(\"blue\", \"konstant\"), 1:(\"red\", \"steigend\")} # Grafikeigenschaften festlegen cat = [] for value, (color, label) in pegel.items(): sym = QgsSymbolV2.defaultSymbol(lay.geometryType()) sym.setColor(QColor(color)) category = QgsRendererCategoryV2(value, sym, label) cat.append(category) # Auf Layer anwenden field = \"trend\" renderer = QgsCategorizedSymbolRendererV2(field, cat) lay.setRendererV2(renderer) # QgsMapLayerRegistry.instance().addMapLayer(lay) iface.mapCanvas().refresh() iface.legendInterface().refreshLayerSymbology(lay)","title":"QGIS und Python"},{"location":"ch02/pyqgis.html#qgis-und-python","text":"Innerhalb von QGIS existiert eine umfangreiche Python-Schnitstelle. Ausgangspunkt ist das Modul \"qgis\". Um die Funktionen nutzen zu k\u00f6nnen, kann zwar auch eine reine Python-Anwendung geschrieben werden. \u00dcblicherweise wird aber mit der Python-Shell innerhalb von QGIS gearbeitet. QGIS unterst\u00fctzt dar\u00fcber hinaus Erweiterungen in Form von PlugIns oder als Verarbeitungswerkzeug (Processing-Scrpte).","title":"QGIS und Python"},{"location":"ch02/pyqgis.html#ressourcen","text":"Umfangreiches Cookbook . Beschreibung der API - C++ Speziell aufbereitet f\u00fcr [Python] (http://geoapis.sourcepole.com/qgispyapi/) Code-Beispiele f\u00fcr Python-Classes der API","title":"Ressourcen"},{"location":"ch02/pyqgis.html#das-pyqgis-modul-qgis","text":"Ein Modul mit Untermodulen f\u00fcr den den Zugang der QGIS-Funktionen und Benutzeroberf\u00e4che, aufgeteilt in die Untermodule core gui utils analysis weitere ... qgis.utils.iface entspricht dabei einer Schnittstelle zu den aktiven Elementen von QGIS, etwa zum Kartenfenster und den dort angezeigten Layern.","title":"Das pyqgis-Modul (qgis)"},{"location":"ch02/pyqgis.html#beispiele-fur-das-qgis-python-fenster","text":">>> qgis.utils.iface >>> iface >>> aLayer = qgis.utils.iface.activeLayer() >>> aLayer.name >>> aLayer.name() >>> help(aLayer)","title":"Beispiele f\u00fcr das QGIS-Python-Fenster"},{"location":"ch02/pyqgis.html#zugriff-auf-das-kartenfenster-canvasleinwand","text":">>> canvas = qgis.utils.iface.mapCanvas() >>> cLayer = canvas.currentLayer() >>> print cLayer.name() >>> canvas.layer(0)","title":"Zugriff auf das Kartenfenster (canvas:Leinwand)"},{"location":"ch02/pyqgis.html#kartendaten-laden","text":">>> iface.addVectorLayer(r\"fluss_gwk4_utm32.shp\", \"Fluss\", \"ogr\") >>> iface.addRasterLayer(r\"brd_dgm_utm.tif\", \"DGM\", \"gdal\") Die Add-Funktionen geben das Layer-Objekt zur\u00fcck! Cookbook-Kapitel zu Vektorlayern und Rasterlayern !","title":"Kartendaten laden"},{"location":"ch02/pyqgis.html#layer-informationen-und-datenzugriff","text":"Die for-Schleife durchl\u00e4uft alle geladenen Layer und gibt Informationen zu jedem einzelnen aus: for layer in qgis.utils.iface.mapCanvas().layers(): if type(layer) == qgis.core.QgsVectorLayer: print \"--- vector\", layer.name() print \"--- geometry type:\", layer.wkbType() elif type(layer) == qgis.core.QgsRasterLayer: print \"--- raster\", layer.name() print \"--- raster type\", layer.rasterType() Der WKB-Typ entspricht der Definition der Simple-Features f\u00fcr Vektordaten, dabei wird jeder Typ durch eine Zahl angegeben. Eine vergleichbare Angane bei Rasterdaten ist der Raster-Typ, auch dieser ist durch Zahlen angegeben. Diese Tabelle zeigt die m\u00f6glichen Werte: wkbType() -> Zahl: rasterType() -> Zahl: QGis.WKBPoint ->(1) Single band ->(0), QGis.WKBLineString ->(2) Single band (Palette) ->(1) QGis.WKBPolygon ->(3) Multiband ->(2) QGis.WKBMultiPoint ->(4) QGis.WKBMultiLineString ->(5) QGis.WKBMultiPolygon ->(6) Der Data-Provider bietet Zugriff auf den Layer und dessen Daten. Der Zugriff ist davon abh\u00e4ngig, welcher Provider benutzt wurde. (Im Beispiel 'ogr' f\u00fcr Shapefiles, anders sieht das z.B. f\u00fcr Tabellen in einer Datenbank aus...) provider = iface.mapCanvas().layer(0).dataProvider() print provider.name() for feat in provider.getFeatures(): # wir tun irgendwas mit dem Feature pass # oder kurz und \u00fcber iface aLayer = qgis.utils.iface.activeLayer() for feat in aLayer.getFeatures(): # wir tun irgendwas mit dem Feature pass Die for-Schleifen durchlaufen jeweils alle Features eines Layers. Das funktioniert, wie im zweiten Fall gezeigt, auch ohne data provider . Ein Beispiel f\u00fcr Raster-Layer: \u00dcber den Provider fragen wir den Pixel-Wert (z-Wert im DGM) an einer Punkt-Koordinate ab: # Rasterlayer in Legende markiert: canvas = iface.mapCanvas() rlayer = canvas.currentLayer() # Lage und Ausdehnung des Rasters print rlayer.extent().toString() # Koordinate innerhalb des Rasters x = 571000 y = 5697000 res = rlayer.dataProvider().identify(QgsPoint(x, y), QgsRaster.IdentifyFormatValue) print res.results() Wir benutzen die Funktion identify(), um auf Rasterwerte an einer Koordinate zuzugreifen\u2026","title":"Layer-Informationen und Datenzugriff"},{"location":"ch02/pyqgis.html#feature-objekte","text":"Vektordaten benutzen Features als Objekte. Features eines Datensatzes verf\u00fcgen daher \u00fcber eine Geometrie: feature.geometry() -> gibt ein Geometrieobjekt zur\u00fcck \u00fcber Attribute: feature.attributes() -> gibt eine Liste mit Werten zur\u00fcck Geometrien unterst\u00fctzen die Grundtypen Point, Line und Polygon, die letzten beiden k\u00f6nnen aber intern als MultiLine oder MultiPolygon gespeichert sein! geom.type(): Typ einer Geometrie, wird als Zahl ausgedr\u00fcckt. Die Konstanten QGis.Point, QGis.Line und QGis.Polygon k\u00f6nnen zum Vergleich benutzt werden. geom.wkbType(): Typ nach WKB-Norm, besser differenziert, mit MultiPart-Typen geom.asXXX(): Methode zur Umwandlung in Listen, z.B. asPolyline() -> Liste mit Punkten ( Hinweis: Punkte erscheinen wie Tuple, sind aber Punkt-Objekte: z.B.: type(geom.asPolyline()[0]) -> Attribute k\u00f6nnen auch im Stil eines Dictionary zugegriffen werden: z.B.: feature['NAME'] , wenn NAME ein Feld des Layers ist.","title":"Feature-Objekte"},{"location":"ch02/pyqgis.html#beispiel","text":"# vector layer is selected layer = iface.activeLayer() iter = layer.getFeatures() # wir geben nur die ersten 10 Features aus stop = 10 i = 0 for feature in iter: if i >= stop: break else: i+=1 # retrieve every feature with its geometry and attributes # fetch geometry geom = feature.geometry() print \"Feature ID %d: \" % feature.id(), \"Geometry: %d-%d\"% (geom.type(), geom.wkbType()) das Script greift im weiteren Verlauf auf die Geometrie zu: # inside the for loop # show some information about the feature if geom.type() == QGis.Point: x = geom.asPoint() print \"Point: \" + str(x) elif geom.type() == QGis.Line: # check according to wkbType x = geom.asPolyline() # asMultiPolyline() # we count number of points numPts = len(x) ##numPts = 0 # if wkb says MultiPolyline ##for lstring in x: ## numPts += len(lstring) print \"Line: %d points\" % numPts elif geom.type() == QGis.Polygon: x = geom.asPolygon() # could also be a MultiPolygon: see MultiPolyline numPts = 0 for ring in x: numPts += len(ring) print \"Polygon: %d rings with %d points\" % (len(x), numPts) else: print \"Unknown\" # fetch attributes attrs = feature.attributes() # attrs is a list. It contains all the attribute values of this feature print attrs","title":"Beispiel"},{"location":"ch02/pyqgis.html#koordinatensysteme-und-transformation","text":"Beispiel f\u00fcr eine Transformation zwischen Koordinatensystemen: crsSrc = QgsCoordinateReferenceSystem(4326) # WGS 84 crsDest = QgsCoordinateReferenceSystem(32633) # WGS 84 / UTM zone 33N xform = QgsCoordinateTransform(crsSrc, crsDest) # forward transformation: src -> dest pt1 = xform.transform(QgsPoint(18,5)) print \"Transformed point:\", pt1 # inverse transformation: dest -> src pt2 = xform.transform(pt1, QgsCoordinateTransform.ReverseTransform) print \"Transformed back:\", pt2","title":"Koordinatensysteme und Transformation"},{"location":"ch02/pyqgis.html#aufgabe-1-z-wert-einer-station-aus-dem-dgm-ermitteln","text":"Abfrage des z-Werts aus dem Raster zur Koordinate einer Station (Stationsh\u00f6he), dazu transformieren wir die Punktangabe (WGS84) zun\u00e4chst in das System des DGM (EPSG-Code 25832 f\u00fcr die UTM-Zone 32(ETRS))","title":"Aufgabe 1: Z-Wert einer Station aus dem DGM ermitteln"},{"location":"ch02/pyqgis.html#aufgabe-2-z-werte-eines-flusses","text":"Wir wollen f\u00fcr einen Fluss feststellen, welche Z-Werte er hat. Dazu vergleichen wir die Koordinaten seiner St\u00fctzpunkte mit den Rasterwerten des DGM an den entsprechenden Positionen. Beide Layer \u00f6ffnen wir zuvor in QGIS, mit dem Vektoren als ersten und dem DGM als zweiten Layer.","title":"Aufgabe 2: Z-Werte eines Flusses"},{"location":"ch02/pyqgis.html#zugriff-auf-einen-fluss","text":"Beispielsweise testen wir den Fluss Nette . Dieses Script selektiert die einzelnen Features mit dem Namen Nette. Der Ausdruck zur Suche setzt die Spaltennamen in doppelte Hochkommata, Strings in einfache Hochkommata. Daher verwenden wir die Python-Notation f\u00fcr ganzen Suchausdruck als Python-String in dreifache Hochkommata... sLayer = iface.mapCanvas().layers()[0] expr = QgsExpression( \"\"\"\"NAM\\\"='Nette'\"\"\") sel = sLayer.getFeatures( QgsFeatureRequest( expr ) ) ids = [i.id() for i in sel] sLayer.setSelectedFeatures(ids) das zur\u00fcckgegebene Objekt sel beinhaltet eine Aufz\u00e4hlung (QgsFeatureIterator), welche wir in einer for-Schleife abarbeiten k\u00f6nnen! Wie wir sehen, ist der Name nicht eindeutig, hier benutzen wir stattdessen die offizielle Gew\u00e4sserkennziffer: sLayer = iface.mapCanvas().layers()[0] expr = QgsExpression( \"\"\"\"GWK\"=2714000000000000000\"\"\" ) sel = sLayer.getFeatures( QgsFeatureRequest( expr ) ) sLayer.setSelectedFeatures(ids) # Zoom auf die Bounding-Box des Flusses box = sLayer.boundingBoxOfSelected() iface.mapCanvas().setExtent(box) iface.mapCanvas().refresh() Wir durchlaufen die Selektion for feat in sel: g = feat.geometry() l = g.Polyline() print l Anstelle von print l realisieren Sie den Zugriff auf alle Punkte, ermitteln deren z-Werte durch Zugriff auf das Raster und geben x,y,z auf der Konsole aus.","title":"Zugriff auf einen Fluss"},{"location":"ch02/pyqgis.html#spatialite-layer","text":"Wir greifen auf unseres Spatialite Datenbank zu: dbname = r\"C:/temp/station.sqlite\" uri = QgsDataSourceURI() uri.setDatabase(dbname) schema = '' table = 'poStation' geom_column = 'geom' uri.setDataSource(schema, table, geom_column) # eine 'uri' f\u00fcr den Zugriff display_name = 'Stationen' self.vlayer = QgsVectorLayer(uri.uri(), display_name, 'spatialite') QgsMapLayerRegistry.instance().addMapLayer(self.vlayer)","title":"Spatialite Layer"},{"location":"ch02/pyqgis.html#ein-zugriff-uber-eine-sql-abfrage","text":"Diese Abfrage setzt die beiden Tabellen f\u00fcr Stationen und aktuelle Werte voraus, die \u00fcber ihre uuid \"gejoint\" werden. Anstelle des Tabellennamens setzen wir eine SQL-Abfrage ein. Siehe auch den Post auf stackexchange . dbname = r\"C:\\temp\\station.sqlite\" sConnect = \"dbname='\" + dbname +\"'\" table = \"SELECT poStation.number, pgolCurrentW.uuid, poStation.geom, \" + \\ \"pgolCurrentW.timestamp, pgolCurrentW.value, pgolCurrentW.trend \" + \\ \"FROM pgolCurrentW, poStation \" + \"WHERE pgolCurrentW.uuid == poStation.uuid\" uri = sConnect + \" key='number'\" + \"table=\\\"(%s)\\\" (geom) sql=\" % table display_name = 'Stationen' print \"loading:%s as %s\" % (sConnect, display_name) print uri vlayer = QgsVectorLayer(uri, display_name, 'spatialite') if vlayer.isValid(): QgsMapLayerRegistry.instance().addMapLayer(vlayer) else: print \"can't add layer!\"","title":"Ein Zugriff \u00fcber eine SQL-Abfrage"},{"location":"ch02/pyqgis.html#darstellung-eines-layers-verandern","text":"Ein Beispiel zur \u00c4nderung der Graphik eines Layers. Wir orientieren uns an den Daten von Pegelonline und richten ein Render-Objekt vom Typ QgsCategorizedSymbolRendererV2 ein, um die Pegelst\u00e4nde nach dem Attribute Trend zu unterscheiden. Der Wert \"-1\" steht f\u00fcr fallend und bekommt die F\u00fcllfarbe \"green\", der Wert \"0\", konstant , bekommt die Farbe \"blue\" und der Wert \"1\", steigend , die Farbe \"red\" zugeordnet. Der QgsCategorizedSymbolRendererV2 benutzt dazu eine Liste von QgsRendererCategoryV2-Objekten, die aus der Angabe eines Werts und einem QgsSymbolV2 mit der entsprechenden F\u00fcllfarbe (in unserem Fall) bestehen. Diese Werte der Kategorien werden mit den Werten eines Layers verglichen und die Grafik zugeordnet. Mit einem refresh des Kartenfensters werden die neuen Einstellungen dann angezeigt. from PyQt4.QtGui import QColor # Layer zugreifen lay = iface.mapCanvas().layers()[0] # Kategorien festlegen pegel = { -1:(\"green\", \"fallend\"), 0:(\"blue\", \"konstant\"), 1:(\"red\", \"steigend\")} # Grafikeigenschaften festlegen cat = [] for value, (color, label) in pegel.items(): sym = QgsSymbolV2.defaultSymbol(lay.geometryType()) sym.setColor(QColor(color)) category = QgsRendererCategoryV2(value, sym, label) cat.append(category) # Auf Layer anwenden field = \"trend\" renderer = QgsCategorizedSymbolRendererV2(field, cat) lay.setRendererV2(renderer) # QgsMapLayerRegistry.instance().addMapLayer(lay) iface.mapCanvas().refresh() iface.legendInterface().refreshLayerSymbology(lay)","title":"Darstellung eines Layers ver\u00e4ndern"},{"location":"ch02/pyqt4.html","text":"Graphische Benutzeroberf\u00e4chen Einf\u00fchrung GUI-Programmierung Eine Anwendung mit graphischer Benutzeroberfl\u00e4che (GUI) programmieren Ein GUI setzt sich aus Fensterelementen zusammen (Widgets): Men\u00fc, Statusleiste, Formulare, Listenfelder, Textfelder, etc Elemente werden in Bibliotheken vorgehalten Oft vom Betriebssystem abh\u00e4ngig: Windows, Mac, aber auch: Plattform\u00fcbergreifende WidgetSets, integrieren sich in ein Gast-System (z.B. Windows) QGIS benutzt die Qt4-Widgets f\u00fcr das eigene GUI F\u00fcr Python existiert das Modulpaket PyQt4 Plugins f\u00fcr QGIS werden mit pyqt4 entwickelt eine simple und minimale Anwendung Begriffe aus der GUI-Welt Widget = Window Gadget: Ein \"Fensterdingsbums\", kleinster Teil eines GUI Dialog = ein aus 1..n Widgets bestehende GUI zur Realisierung einer spezifischen Nutzerinteraktion, oft auch als Formular bezeichnet (s. Abb.) MainWindow = Hauptfenster einer Applikation, mit Buttons und Men\u00fcs, welche bestimmte Funktionen ausf\u00fchren oder Dialoge aufrufen (s. QGIS) GUI = Graphical User Interface: Graphische Benutzerschnittstelle; Oberbegriff Maus+Tastatur+Bildschirm (oder andere Eingaben mit Graphischer Entsprechung) Ereignis-Programmierung: Fensterobjekte\u2013 Datenobjekte \u2013 Eingabeobjekte interagieren miteinander und manipulieren sich gegenseitig H\u00e4ufig verwendete QtGUI-Widgets in Dialogen Dokumentation PyQt4 auf sourceforge Aufbau einer PyQt4-Anwendung Hello World Ben\u00f6tigte Module importieren und Funktion main() einrichten import sys from PyQt4.QtCore import * from PyQt4.QtGui import * def main(argv): pass if __name__ == '__main__': main(sys.argv) Die Anwendung kann auch Kommandozeilenargumente verarbeiten, daher wird sys.argv \u00fcbergeben. Jede PyQt-GUI-Anwendung ben\u00f6tigt ein QApplication Objekt. Dieses stellt allgemeine Informationen wie z.B. das Anwendungs-directory, Bildschirmparameter und v.A. den Event-Loop zur Verf\u00fcgung. def main(argv): # each Qt-Programm needs an application object app = QApplication(argv) # to show the string Hello World in a window textEdit = QTextEdit() textEdit.setText(\"Hello World\") # show window textEdit.show() app.exec_() Ein QTextEdit Widget wird erstellt: In PyQt kann jedes Widget als Top-Level Fenster dienen. Ist dies der Fall, wird ihm automatisch die typische Titelzeile und u.a. der X-Button verliehen. Nachfolgend wird ein \"paint event\" zur Anzeige des Widgets in den Event-Loop eingesetzt. Damit steht die Anzeige des Widgets in der Warteschleife. Schlie\u00dflich muss man den Event-Loop starten, das Widget erscheint am Bildschirm, bis X gedr\u00fcckt wird. textEdit.resize(250, 450) textEdit.move(300, 300) textEdit.setWindowTitle('Simple') # show window textEdit.show() app.exec_() Ein QTextEdit als top level widget erlaubt es, Parameter des Fensters zu setzen Der Qt-Event-Loop :Herk\u00f6mmliches und Event-basiertes Programm Objektorientierung Ein Dialog-Fenster mit Textfeld wird als Klasse definiert: import sys from PyQt4.QtCore import * from PyQt4.QtGui import * class MyForm(QDialog): def __init__(self): QDialog.__init__(self) self.textEdit = QTextEdit('Hello World!') self.textEdit.selectAll() layout = QVBoxLayout() layout.addWidget(self.textEdit) self.setLayout(layout) app = QApplication(sys.argv) form = MyForm() form.show() app.exec_() self ist das Dialogobjekt ein QVBoxLayout-Objekt ordnet andere Widgets vertikal an setLayout() ist eine Methode, um in dem Dialog self ein QTextFeld anzuzeigen self.textEdit: unter dieser Variable bleibt das Textfeld ansprechbar Events mit Signals and Slots Events als Nachrichten zwischen Objekten Jedes Widget kennt eigene Events und kann eine Funktion vorsehen, um diese zu verarbeiten Signals and Slots, als Konzept, definiert ein Signal, etwa 'clicked()' f\u00fcr ein QPushButton, das einen Slot in einem anderen Objekt (dem Empf\u00e4nger) belegt, und dort eine Funktion ausf\u00fchrt. Die Basis hierf\u00fcr ist die Funktion connect, die jedes Qt-Object ausf\u00fchren kann QtCore.QObject.connect(<sender_widget>, SIGNAL(<signal_received>), <action/methods>) # z.B.: self ist ein QDialog self.connect(self.buttonOK, # eine Schaltfl\u00e4che im Dialog SIGNAL((\"clicked()\"), # ein Event (als String!) self.doActionOK()) # ein Slot (eine Methode des Dialogs) 'Hello World' mit OK-Button import sys from PyQt4.QtCore import * from PyQt4.QtGui import * class MyForm(QDialog): def __init__(self): QDialog.__init__(self) self.textEdit = QTextEdit('Hello World!') self.textEdit.selectAll() self.buttonOK = QPushButton() self.buttonOK.setText('OK') layout = QVBoxLayout() layout.addWidget(self.textEdit) layout.addWidget(self.buttonOK) self.setLayout(layout) self.connect(self.buttonOK, # eine Schaltfl\u00e4che im Dialog SIGNAL(\"clicked()\"), # ein Event (als String!) self.doActionOK) # ein Slot (eine Methode des Dialogs) def doActionOK(self): self.textEdit.setText(\"Hello PyQt4!\") app = QApplication(sys.argv) form = MyForm() form.show() app.exec_() Noch ein Signal and Slot? Wir nehmen einen eigenen Button zum Schlie\u00dfen des Fensters: class MyForm(QDialog): def __init__(self): QDialog.__init__(self) self.textEdit = QTextEdit('Hello World!') self.textEdit.selectAll() self.buttonOK = QPushButton() self.buttonOK.setText('OK') self.buttonClose = QPushButton() self.buttonClose.setText('Close') layout = QVBoxLayout() layout.addWidget(self.textEdit) layout.addWidget(self.buttonOK) layout.addWidget(self.buttonClose) self.setLayout(layout) self.connect(self.buttonOK, SIGNAL(\"clicked()\"), self.doActionOK) self.connect(self.buttonClose, SIGNAL(\"clicked()\"), self.close) # QDialog besitzt bereits einen Slot close def doActionOK(self): self.textEdit.setText(\"Hello PyQt4!\") # oder wir \u00fcberschreiben die Methode def close(self): print self.textEdit.toPlainText() QDialog.close(self) Beispiel Tabellenwidget Ein QtTableWidget zur Anzeige tabelarischer Daten. from PyQt4.QtGui import * from PyQt4.QtCore import * import sys data = ((1,2,3),(4,5,6),(7,8,9),(10,11,12)) class MyTable(QTableWidget): def __init__(self): QTableWidget.__init__(self) def setData(self, data): nrows = len(data) ncols = len(data[0]) self.setRowCount(nrows) self.setColumnCount(ncols) for rn in range(nrows): for cn in range(ncols): newitem = QTableWidgetItem() val = data[rn][cn] newitem.setText(val if isinstance(val, basestring) else str(val)) self.setItem(rn, cn, newitem) def main(args): app = QApplication(args) table = MyTable() table.setData(data) table.resize(400, 250) table.show() sys.exit(app.exec_()) if __name__ == '__main__': main(sys.argv) Signals eines QTableWidget QtTableWidget-Dokumentation Wir erweitern das Table-Widget-Beispiel um einen Signal and Slot Mechanismus. Uns interessiert, weche Zelle angeklickt wurde... class MyTable(QTableWidget): def __init__(self): QTableWidget.__init__(self) self.connect(self, SIGNAL('cellClicked (int,int)'), self.doActionCell) # alternativ # self.cellClicked.connect(self.doActionCell) def setData(self, data): nrows = len(data) ncols = len(data[0]) self.setRowCount(nrows) self.setColumnCount(ncols) for rn in range(nrows): for cn in range(ncols): newitem = QTableWidgetItem() val = data[rn][cn] newitem.setText(val if isinstance(val, basestring) else str(val)) self.setItem(rn, cn, newitem) def doActionCell(self, row, column): item = self.item(row, column) print row, column, item.text() Das besondere hier ist, dass in diesem Signal zus\u00e4tzliche Parameter \u00fcbergeben werden. Es sind die beiden Zahlenangaben, die Zeile und Spalte der Zelle angeben. Dokumentation Alternativ besteht die M\u00f6glichkeit einen connect in einer neuen Art zu definieren. Dieser ist k\u00fcrzer und mehr an Python angelegt (Qt Widgets werden in C++ programmiert): self.cellClicked.connect(self.doActionCell) Qt-Layout Sehr umfangreiche Layout-Einstellungen QVBoxLayout und QHBoxLayout oder QGridLayout bieten grundlegende M\u00f6glichkeiten zum Layout erweitertes Beispiel zu Hello World zeigt den Einsatz Layout k\u00f6nnen auch geschachtelt werden, d.h. ein layout kann ein anderes enthalten Beispiel eines Layouts f\u00fcr eine navigierbare Tabelle Unsere Tabelle wird erg\u00e4nzt durch eine Button-Leiste mit Navigations-Schaltfl\u00e4chen (\"Zum Anfang\", \"Ein zur\u00fcck\", \"Ein vor\" und \"Zum Ende\"). Die Buttons werden horizontal angeordnet und sollen unter der Tabelle angzeigt werden. Skizze: QVBoxLayout mit enthaltenem QHBoxLayout Umsetzung: from PyQt4.QtGui import * from PyQt4.QtCore import * import sys data = ((1,2,3),(4,5,6),(7,8,9),(10,11,12)) class NavTable(QWidget): def __init__(self): QWidget.__init__(self) self.table = QTableWidget() self.title = QLabel() buttonbar = QHBoxLayout() self.btnFirst = QPushButton() self.btnFirst.setText(\"<< First\") self.btnBack = QPushButton() self.btnBack.setText(\"< Back\") self.btnNext = QPushButton() self.btnNext.setText(\"> Next\") self.btnEnd = QPushButton() self.btnEnd.setText(\">> Last\") buttonbar.addWidget(self.btnFirst) buttonbar.addWidget(self.btnBack) buttonbar.addWidget(self.btnNext) buttonbar.addWidget(self.btnEnd) layout = QVBoxLayout() layout.addWidget(self.title) layout.addWidget(self.table) layout.addLayout(buttonbar) self.setLayout(layout) def setTitel(self, titel): self.title.setText(titel) def setData(self, data): nrows = len(data) ncols = len(data[0]) self.setRowCount(nrows) self.setColumnCount(ncols) for rn in range(nrows): for cn in range(ncols): newitem = QTableWidgetItem() val = data[rn][cn] newitem.setText(val if isinstance(val, basestring) else str(val)) self.setItem(rn, cn, newitem) def main(args): app = QApplication(args) table = NavTable() table.setTitel(\"Meine Tabelle\") table.setData(data) table.resize(400, 250) table.show() sys.exit(app.exec_()) if __name__ == '__main__': main(sys.argv) Signals and Slots f\u00fcr die Tabellennavigation Zun\u00e4chst passen wir init an und erstellen diese Eigenschaften: selectedRow: merkt sich die markierte Zeile, default = 0 rowCount: merkt sich Anzahl der Zeilen, wird in setData ermittelt class NavTable(QWidget): def __init__(self): QWidget.__init__(self) self.selectedRow = 0 self.rowCount = 0 und die \u00c4nderung in der Methode setData: def setData(self, data): nrows = len(data) ncols = len(data[0]) # new: self.rowCount = nrows Dann erstellen wir den Signal-Slot-Mechanismus f\u00fcr die Navigation mit den folgenden neuen Methoden: def makeEvents(self): self.btnFirst.clicked.connect(self.goFirst) self.btnBack.clicked.connect(self.goBack) self.btnNext.clicked.connect(self.goNext) self.btnEnd.clicked.connect(self.goLast) def goFirst(self): self.table.selectRow(0) self.selectedRow = 0 def goLast(self): self.table.selectRow(self.rowCount-1) self.selectedRow = self.rowCount-1 def goNext(self): self.selectedRow = self.selectedRow + 1 \\ if self.selectedRow < self.rowCount -1 \\ else self.rowCount -1 self.table.selectRow(self.selectedRow) def goBack(self): self.selectedRow = self.selectedRow - 1 \\ if self.selectedRow > 0 \\ else 0 self.table.selectRow(self.selectedRow) Hinweis: makeEvents sollte eigentlich Bestandteil von init sein, dies w\u00e4re f\u00fcr das Beispiel aber mehr Einf\u00fcge-Arbeit... Aber so sieht dann main() aus: def main(args): app = QApplication(args) table = NavTable() table.setTitel(\"Meine Tabelle\") table.setData(data) table.resize(400, 250) # new table.makeEvents() table.show() sys.exit(app.exec_()) Aufgabe: Eine Tabelle f\u00fcr Pegelonline Zeigen Sie die Daten von Pegelonline in der Navigations-Tabelle an. Testdaten erhalten wir aus der Spatialite Datenbank: from pyspatialite import dbapi2 as db def readData(): dbname = r\"C:\\temp\\station.sqlite\" conn = db.connect(dbname) cur = conn.cursor() cur.execute(\"SELECT * FROM poStation WHERE water='MOSEL'\") data = cur.fetchall() return data und main \u00e4ndert sich ein weiteres Mal: def main(args): app = QApplication(args) table = NavTable() # new table.setTitel(\"Stationen von Pegelonline\") data = readData() table.setData(data) table.resize(400, 250) table.makeEvents() table.show() sys.exit(app.exec_()) Dialoge Wir unterscheiden: Dialogboxen, die bereits als Klassen bestehen: Nachricht mit Ja/Nein, File Save/File Open, Farbwahl, Eingabezeile etc. Dokumentation Eigene Formulare und Dialoge auf Basis von Qdialog sind an ein anderes Widget (z.B. MainWindow) gebunden k\u00f6nnen modal oder unabh\u00e4ngig sein geben einen Wert zur\u00fcck Schema eines modalen Dialogs Bestehende Dialoge Ein Dialog f\u00fcr eine Eingabe: text, ok = QInputDialog.getText(self, 'Titel', 'Eingabeaufforderung') liefert einen String zur\u00fcck und au\u00dferdem den Wert f\u00fcr OK mit true bzw. false, je nachdem, ob der Benutzer OK geklickt hat, ober nicht. Aufgerufen wird der Dialog von einem anderen Widget via Signal/Slot: # self is a QDialog self.btn = QtGui.QPushButton('Dialog', self) self.btn.clicked.connect(self.showInputDialog) def showInputDialog(self): text, ok = QtGui.QInputDialog.getText(self, 'Input Dialog', 'Enter your name:') if ok: print text Ein funktionierendes Beispiel zum Aufruf eines MessageBox-Dialogs import sys from PyQt4.QtCore import * from PyQt4.QtGui import * app = QApplication(sys.argv) w = QWidget() result = QMessageBox.question(w, 'Message', \"Do you like Python?\", QMessageBox.Yes | QMessageBox.No, QMessageBox.No) if result == QMessageBox.Yes: print \"yes\" else: print \"no\" w.show() app.exec_() Ein Beispiel f\u00fcr den Aufruf verschiedener Dialoge aus dem ZetCode PyQt4 tutorial von Jan Bodnar und pythonspot : (Jan Bodnar importiert das Modul QtGui anstelle von from PyQt4.QtGui import * ) import sys from PyQt4 import QtGui examples = [\"input\", \"color\", \"fileopen\"] class Example(QtGui.QWidget): def __init__(self, example): super(Example, self).__init__() self.initUI(example) def initUI(self, example): self.btn = QtGui.QPushButton('Dialog', self) self.btn.move(20, 20) if example in examples: if example == \"input\": self.btn.clicked.connect(self.showInputDialog) elif example == \"color\": self.btn.clicked.connect(self.showColorDialog) elif example == \"fileopen\": self.btn.clicked.connect(self.showFileOpenDialog) else: self.btn.clicked.connect(self.showMessageDialog) self.le = QtGui.QLineEdit(self) self.le.move(130, 22) self.setGeometry(300, 300, 290, 150) self.setWindowTitle('Input dialog') self.show() def showInputDialog(self): text, ok = QtGui.QInputDialog.getText(self, 'Input Dialog', 'Enter your name:') if ok: self.le.setText(str(text)) def showColorDialog(self): col = QtGui.QColorDialog.getColor() if col.isValid(): self.setStyleSheet(\"QWidget { background-color: %s }\" % col.name()) def showFileOpenDialog(self): fname = QtGui.QFileDialog.getOpenFileName(self, 'Open file', '.') self.le.setText(fname) def showMessageDialog(self): result = QtGui.QMessageBox.question(self, 'Message', \"Do you like Qt?\", QtGui.QMessageBox.Yes | QtGui.QMessageBox.No, QtGui.QMessageBox.No) if result == QtGui.QMessageBox.Yes: self.le.setText(\"Ja\") else: self.le.setText(\"Nein\") def main(): app = QtGui.QApplication(sys.argv) ex = Example(\"\") sys.exit(app.exec_()) if __name__ == '__main__': main() Zum Testen der Dialoge setzen wir f\u00fcr das Argument in Example(\"\") einen Wert aus der Liste ein: examples = [\"input\", \"color\", \"fileopen\"] , ein leerer String \u00f6ffnet einen Ja/Nein-Dialog. Die einzelnen Dialoge sind auch konfigurierbar. Hier die Varianten f\u00fcr den QFileDialog Kann Selektionen von einer oder mehreren Dateien beim Laden, Verzeichniswahl beim Speichern von Dateien etc. vornehmen Standardpfad und Dateifilter k\u00f6nnen u.a. \u00fcbergeben werden Unter der Vielzahl an Methoden des QFileDialog, sind die folgenden fast selbsterkl\u00e4rend: Methoden aus der Qt- C++-Dokumentation eigene Dialoge Eigene Dialoge sind stets Kinder von QDialog Ein eigener Dialog wird in einer eigenen Klasse definiert, meist in einem eigenen Modul (Wiederverwertbarkeit!) Fast alle Dialoge ben\u00f6tigen Buttons zum Abschluss einer Eingabe Alle anderen erforderlichen Widgets k\u00f6nnen \u00fcber Layouts eingebunden werden der Dialog ist in der Regel von einem anderen Fenster abh\u00e4ngig (parent-Eigenschaft) Buttons eines Dialogs einrichten: die klassische Kombination aus \u201eOK/Cancel\u201c Buttons kann als einzelnes Widget umgesetzt werden Hierdurch bleibt die Reihenfolge der Buttons stets konform mit den Gepflogenheiten der jeweiligen Plattform (GNOME und MacOS X benutzen \u201eCancel/OK\u201c) buttonBox = QDialogButtonBox(QDialogButtonBox.Ok|QDialogButtonBox.Cancel) Die Buttonbox definiert eigene Signals f\u00fcr die Buttons: self.connect(self.buttonBox, SIGNAL(\"accepted()\"), self.accept) self.connect(self.buttonBox, SIGNAL(\"rejected()\"), self.reject) Um den Dialog aufzurufen, wird eine zus\u00e4tzliche Event-Schleife benutzt. Beispiel: Fr\u00fcchtedialog import sys from PyQt4.QtGui import * from PyQt4.QtCore import * class DialogFruits(QDialog): def __init__(self, parent=None): super(DialogFruits,self).__init__() self.value = \"\" self.setupUI(parent) def setupUI(self, parent=None): dialogLayout = QVBoxLayout() radioLayout = QHBoxLayout() self.b1 = QRadioButton(\"Apple\") self.b1.toggled.connect(lambda:self.btnstate(self.b1)) self.b1.setChecked(True) self.btnstate(self.b1) radioLayout.addWidget(self.b1) self.b2 = QRadioButton(\"Banana\") self.b2.toggled.connect(lambda:self.btnstate(self.b2)) radioLayout.addWidget(self.b2) self.b3 = QRadioButton(\"Orange\") self.b3.toggled.connect(lambda:self.btnstate(self.b3)) radioLayout.addWidget(self.b3) dialogLayout.addLayout(radioLayout) b1 = QPushButton(\"ok\") b1.clicked.connect(lambda:self.close()) dialogLayout.addWidget(b1) self.setLayout(dialogLayout) self.setWindowTitle(\"Fruits\") self.setWindowModality(Qt.ApplicationModal) def btnstate(self,b): self.value = b.text() def getValue(self): return self.value if __name__ == '__main__': app = QApplication(sys.argv) test = DialogFruits() test.show() app.exec_() print test.getValue() Ein Fr\u00fcchtedialog mit Testaufruf. Wir speichern es als eigenes Modul dialogfruits.py In einem Hauptfenster rufen wir den Dialog auf. Hierzu \u00fcbernehmen wir das Hauptfenster aus dem Beispiels der Standarddialoge und passen es etwas an: import sys from PyQt4 import QtGui from dialogfruits import DialogFruits class Example(QtGui.QWidget): def __init__(self, example): super(Example, self).__init__() self.initUI(example) def initUI(self, example): self.btn = QtGui.QPushButton('Fruits', self) self.btn.move(20, 20) self.btn.clicked.connect(self.showFruitsDialog) self.le = QtGui.QLineEdit(self) self.le.move(130, 22) self.setGeometry(300, 300, 290, 150) self.setWindowTitle('Choose a Fruit!') self.show() def showFruitsDialog(self): dlg = DialogFruits(self) dlg.exec_() v = dlg.getValue() self.le.setText(v) Ein Connect richtet das Event ein, in dem der Dialog aufgerufen wird. In showFruitsDialog() sehen wir, dass das Dialogfenster eine eigene Event-Loop bekommt. Eine weitere Erleichterung ergibt sich durch eine eigene Methode um den Event-Loop mit dlg.exec_() zu verbergen. H\u00e4ufig wird hierf\u00fcr der Name run() oder open() gew\u00e4hlt: # in der Dialog-Klasse: def run(self): self.exec_() return self.getValue() und so wird der Dialog dann aufgerufen: def showFruitsDialog(self): dlg = DialogFruits(self) # alt: # dlg.exec_() # v = dlg.getValue() # neu: v = dlg.run() self.le.setText(v) Bildanzeige import urlreader3 import sys from PyQt4.QtGui import * def showimage(imgData, mylabel): pixmap = QPixmap() pixmap.loadFromData(imgData) mylabel.setPixmap(pixmap) mylabel.resize(pixmap.width(), pixmap.height()) app = QApplication(sys.argv) # to show the string Hello World in a window aLabel = QLabel() url = u\"http://pegelonline.wsv.de/webservices/rest-api/v2/stations/BONN/W/measurements.png?start=P15D&width=925&height=220\" imgdata = urlreader3.getDataResponse(url) showimage(imgdata, aLabel) # show window aLabel.show() app.exec_() QtDesigner Mit dem Qt-Designer k\u00f6nnen GUI's und Widgets interaktiv erstellt werden. Hier gibt eine kurze Einf\u00fchrung . Der QtDesigner ist Teil der PyQt-Installation. :Aufruf des QtDesigners","title":"Graphische Benutzeroberf\u00e4chen"},{"location":"ch02/pyqt4.html#graphische-benutzeroberfachen","text":"","title":"Graphische Benutzeroberf\u00e4chen"},{"location":"ch02/pyqt4.html#einfuhrung","text":"","title":"Einf\u00fchrung"},{"location":"ch02/pyqt4.html#gui-programmierung","text":"Eine Anwendung mit graphischer Benutzeroberfl\u00e4che (GUI) programmieren Ein GUI setzt sich aus Fensterelementen zusammen (Widgets): Men\u00fc, Statusleiste, Formulare, Listenfelder, Textfelder, etc Elemente werden in Bibliotheken vorgehalten Oft vom Betriebssystem abh\u00e4ngig: Windows, Mac, aber auch: Plattform\u00fcbergreifende WidgetSets, integrieren sich in ein Gast-System (z.B. Windows) QGIS benutzt die Qt4-Widgets f\u00fcr das eigene GUI F\u00fcr Python existiert das Modulpaket PyQt4 Plugins f\u00fcr QGIS werden mit pyqt4 entwickelt eine simple und minimale Anwendung","title":"GUI-Programmierung"},{"location":"ch02/pyqt4.html#begriffe-aus-der-gui-welt","text":"Widget = Window Gadget: Ein \"Fensterdingsbums\", kleinster Teil eines GUI Dialog = ein aus 1..n Widgets bestehende GUI zur Realisierung einer spezifischen Nutzerinteraktion, oft auch als Formular bezeichnet (s. Abb.) MainWindow = Hauptfenster einer Applikation, mit Buttons und Men\u00fcs, welche bestimmte Funktionen ausf\u00fchren oder Dialoge aufrufen (s. QGIS) GUI = Graphical User Interface: Graphische Benutzerschnittstelle; Oberbegriff Maus+Tastatur+Bildschirm (oder andere Eingaben mit Graphischer Entsprechung) Ereignis-Programmierung: Fensterobjekte\u2013 Datenobjekte \u2013 Eingabeobjekte interagieren miteinander und manipulieren sich gegenseitig H\u00e4ufig verwendete QtGUI-Widgets in Dialogen","title":"Begriffe aus der GUI-Welt"},{"location":"ch02/pyqt4.html#dokumentation","text":"PyQt4 auf sourceforge","title":"Dokumentation"},{"location":"ch02/pyqt4.html#aufbau-einer-pyqt4-anwendung","text":"","title":"Aufbau einer PyQt4-Anwendung"},{"location":"ch02/pyqt4.html#hello-world","text":"Ben\u00f6tigte Module importieren und Funktion main() einrichten import sys from PyQt4.QtCore import * from PyQt4.QtGui import * def main(argv): pass if __name__ == '__main__': main(sys.argv) Die Anwendung kann auch Kommandozeilenargumente verarbeiten, daher wird sys.argv \u00fcbergeben. Jede PyQt-GUI-Anwendung ben\u00f6tigt ein QApplication Objekt. Dieses stellt allgemeine Informationen wie z.B. das Anwendungs-directory, Bildschirmparameter und v.A. den Event-Loop zur Verf\u00fcgung. def main(argv): # each Qt-Programm needs an application object app = QApplication(argv) # to show the string Hello World in a window textEdit = QTextEdit() textEdit.setText(\"Hello World\") # show window textEdit.show() app.exec_() Ein QTextEdit Widget wird erstellt: In PyQt kann jedes Widget als Top-Level Fenster dienen. Ist dies der Fall, wird ihm automatisch die typische Titelzeile und u.a. der X-Button verliehen. Nachfolgend wird ein \"paint event\" zur Anzeige des Widgets in den Event-Loop eingesetzt. Damit steht die Anzeige des Widgets in der Warteschleife. Schlie\u00dflich muss man den Event-Loop starten, das Widget erscheint am Bildschirm, bis X gedr\u00fcckt wird. textEdit.resize(250, 450) textEdit.move(300, 300) textEdit.setWindowTitle('Simple') # show window textEdit.show() app.exec_() Ein QTextEdit als top level widget erlaubt es, Parameter des Fensters zu setzen","title":"Hello World"},{"location":"ch02/pyqt4.html#der-qt-event-loop","text":":Herk\u00f6mmliches und Event-basiertes Programm","title":"Der Qt-Event-Loop"},{"location":"ch02/pyqt4.html#objektorientierung","text":"Ein Dialog-Fenster mit Textfeld wird als Klasse definiert: import sys from PyQt4.QtCore import * from PyQt4.QtGui import * class MyForm(QDialog): def __init__(self): QDialog.__init__(self) self.textEdit = QTextEdit('Hello World!') self.textEdit.selectAll() layout = QVBoxLayout() layout.addWidget(self.textEdit) self.setLayout(layout) app = QApplication(sys.argv) form = MyForm() form.show() app.exec_() self ist das Dialogobjekt ein QVBoxLayout-Objekt ordnet andere Widgets vertikal an setLayout() ist eine Methode, um in dem Dialog self ein QTextFeld anzuzeigen self.textEdit: unter dieser Variable bleibt das Textfeld ansprechbar","title":"Objektorientierung"},{"location":"ch02/pyqt4.html#events-mit-signals-and-slots","text":"Events als Nachrichten zwischen Objekten Jedes Widget kennt eigene Events und kann eine Funktion vorsehen, um diese zu verarbeiten Signals and Slots, als Konzept, definiert ein Signal, etwa 'clicked()' f\u00fcr ein QPushButton, das einen Slot in einem anderen Objekt (dem Empf\u00e4nger) belegt, und dort eine Funktion ausf\u00fchrt. Die Basis hierf\u00fcr ist die Funktion connect, die jedes Qt-Object ausf\u00fchren kann QtCore.QObject.connect(<sender_widget>, SIGNAL(<signal_received>), <action/methods>) # z.B.: self ist ein QDialog self.connect(self.buttonOK, # eine Schaltfl\u00e4che im Dialog SIGNAL((\"clicked()\"), # ein Event (als String!) self.doActionOK()) # ein Slot (eine Methode des Dialogs)","title":"Events mit Signals and Slots"},{"location":"ch02/pyqt4.html#hello-world-mit-ok-button","text":"import sys from PyQt4.QtCore import * from PyQt4.QtGui import * class MyForm(QDialog): def __init__(self): QDialog.__init__(self) self.textEdit = QTextEdit('Hello World!') self.textEdit.selectAll() self.buttonOK = QPushButton() self.buttonOK.setText('OK') layout = QVBoxLayout() layout.addWidget(self.textEdit) layout.addWidget(self.buttonOK) self.setLayout(layout) self.connect(self.buttonOK, # eine Schaltfl\u00e4che im Dialog SIGNAL(\"clicked()\"), # ein Event (als String!) self.doActionOK) # ein Slot (eine Methode des Dialogs) def doActionOK(self): self.textEdit.setText(\"Hello PyQt4!\") app = QApplication(sys.argv) form = MyForm() form.show() app.exec_() Noch ein Signal and Slot? Wir nehmen einen eigenen Button zum Schlie\u00dfen des Fensters: class MyForm(QDialog): def __init__(self): QDialog.__init__(self) self.textEdit = QTextEdit('Hello World!') self.textEdit.selectAll() self.buttonOK = QPushButton() self.buttonOK.setText('OK') self.buttonClose = QPushButton() self.buttonClose.setText('Close') layout = QVBoxLayout() layout.addWidget(self.textEdit) layout.addWidget(self.buttonOK) layout.addWidget(self.buttonClose) self.setLayout(layout) self.connect(self.buttonOK, SIGNAL(\"clicked()\"), self.doActionOK) self.connect(self.buttonClose, SIGNAL(\"clicked()\"), self.close) # QDialog besitzt bereits einen Slot close def doActionOK(self): self.textEdit.setText(\"Hello PyQt4!\") # oder wir \u00fcberschreiben die Methode def close(self): print self.textEdit.toPlainText() QDialog.close(self)","title":"'Hello World' mit OK-Button"},{"location":"ch02/pyqt4.html#beispiel-tabellenwidget","text":"Ein QtTableWidget zur Anzeige tabelarischer Daten. from PyQt4.QtGui import * from PyQt4.QtCore import * import sys data = ((1,2,3),(4,5,6),(7,8,9),(10,11,12)) class MyTable(QTableWidget): def __init__(self): QTableWidget.__init__(self) def setData(self, data): nrows = len(data) ncols = len(data[0]) self.setRowCount(nrows) self.setColumnCount(ncols) for rn in range(nrows): for cn in range(ncols): newitem = QTableWidgetItem() val = data[rn][cn] newitem.setText(val if isinstance(val, basestring) else str(val)) self.setItem(rn, cn, newitem) def main(args): app = QApplication(args) table = MyTable() table.setData(data) table.resize(400, 250) table.show() sys.exit(app.exec_()) if __name__ == '__main__': main(sys.argv)","title":"Beispiel Tabellenwidget"},{"location":"ch02/pyqt4.html#signals-eines-qtablewidget","text":"QtTableWidget-Dokumentation Wir erweitern das Table-Widget-Beispiel um einen Signal and Slot Mechanismus. Uns interessiert, weche Zelle angeklickt wurde... class MyTable(QTableWidget): def __init__(self): QTableWidget.__init__(self) self.connect(self, SIGNAL('cellClicked (int,int)'), self.doActionCell) # alternativ # self.cellClicked.connect(self.doActionCell) def setData(self, data): nrows = len(data) ncols = len(data[0]) self.setRowCount(nrows) self.setColumnCount(ncols) for rn in range(nrows): for cn in range(ncols): newitem = QTableWidgetItem() val = data[rn][cn] newitem.setText(val if isinstance(val, basestring) else str(val)) self.setItem(rn, cn, newitem) def doActionCell(self, row, column): item = self.item(row, column) print row, column, item.text() Das besondere hier ist, dass in diesem Signal zus\u00e4tzliche Parameter \u00fcbergeben werden. Es sind die beiden Zahlenangaben, die Zeile und Spalte der Zelle angeben. Dokumentation Alternativ besteht die M\u00f6glichkeit einen connect in einer neuen Art zu definieren. Dieser ist k\u00fcrzer und mehr an Python angelegt (Qt Widgets werden in C++ programmiert): self.cellClicked.connect(self.doActionCell)","title":"Signals eines QTableWidget"},{"location":"ch02/pyqt4.html#qt-layout","text":"Sehr umfangreiche Layout-Einstellungen QVBoxLayout und QHBoxLayout oder QGridLayout bieten grundlegende M\u00f6glichkeiten zum Layout erweitertes Beispiel zu Hello World zeigt den Einsatz Layout k\u00f6nnen auch geschachtelt werden, d.h. ein layout kann ein anderes enthalten","title":"Qt-Layout"},{"location":"ch02/pyqt4.html#beispiel-eines-layouts-fur-eine-navigierbare-tabelle","text":"Unsere Tabelle wird erg\u00e4nzt durch eine Button-Leiste mit Navigations-Schaltfl\u00e4chen (\"Zum Anfang\", \"Ein zur\u00fcck\", \"Ein vor\" und \"Zum Ende\"). Die Buttons werden horizontal angeordnet und sollen unter der Tabelle angzeigt werden. Skizze: QVBoxLayout mit enthaltenem QHBoxLayout Umsetzung: from PyQt4.QtGui import * from PyQt4.QtCore import * import sys data = ((1,2,3),(4,5,6),(7,8,9),(10,11,12)) class NavTable(QWidget): def __init__(self): QWidget.__init__(self) self.table = QTableWidget() self.title = QLabel() buttonbar = QHBoxLayout() self.btnFirst = QPushButton() self.btnFirst.setText(\"<< First\") self.btnBack = QPushButton() self.btnBack.setText(\"< Back\") self.btnNext = QPushButton() self.btnNext.setText(\"> Next\") self.btnEnd = QPushButton() self.btnEnd.setText(\">> Last\") buttonbar.addWidget(self.btnFirst) buttonbar.addWidget(self.btnBack) buttonbar.addWidget(self.btnNext) buttonbar.addWidget(self.btnEnd) layout = QVBoxLayout() layout.addWidget(self.title) layout.addWidget(self.table) layout.addLayout(buttonbar) self.setLayout(layout) def setTitel(self, titel): self.title.setText(titel) def setData(self, data): nrows = len(data) ncols = len(data[0]) self.setRowCount(nrows) self.setColumnCount(ncols) for rn in range(nrows): for cn in range(ncols): newitem = QTableWidgetItem() val = data[rn][cn] newitem.setText(val if isinstance(val, basestring) else str(val)) self.setItem(rn, cn, newitem) def main(args): app = QApplication(args) table = NavTable() table.setTitel(\"Meine Tabelle\") table.setData(data) table.resize(400, 250) table.show() sys.exit(app.exec_()) if __name__ == '__main__': main(sys.argv)","title":"Beispiel eines Layouts f\u00fcr eine navigierbare Tabelle"},{"location":"ch02/pyqt4.html#signals-and-slots-fur-die-tabellennavigation","text":"Zun\u00e4chst passen wir init an und erstellen diese Eigenschaften: selectedRow: merkt sich die markierte Zeile, default = 0 rowCount: merkt sich Anzahl der Zeilen, wird in setData ermittelt class NavTable(QWidget): def __init__(self): QWidget.__init__(self) self.selectedRow = 0 self.rowCount = 0 und die \u00c4nderung in der Methode setData: def setData(self, data): nrows = len(data) ncols = len(data[0]) # new: self.rowCount = nrows Dann erstellen wir den Signal-Slot-Mechanismus f\u00fcr die Navigation mit den folgenden neuen Methoden: def makeEvents(self): self.btnFirst.clicked.connect(self.goFirst) self.btnBack.clicked.connect(self.goBack) self.btnNext.clicked.connect(self.goNext) self.btnEnd.clicked.connect(self.goLast) def goFirst(self): self.table.selectRow(0) self.selectedRow = 0 def goLast(self): self.table.selectRow(self.rowCount-1) self.selectedRow = self.rowCount-1 def goNext(self): self.selectedRow = self.selectedRow + 1 \\ if self.selectedRow < self.rowCount -1 \\ else self.rowCount -1 self.table.selectRow(self.selectedRow) def goBack(self): self.selectedRow = self.selectedRow - 1 \\ if self.selectedRow > 0 \\ else 0 self.table.selectRow(self.selectedRow) Hinweis: makeEvents sollte eigentlich Bestandteil von init sein, dies w\u00e4re f\u00fcr das Beispiel aber mehr Einf\u00fcge-Arbeit... Aber so sieht dann main() aus: def main(args): app = QApplication(args) table = NavTable() table.setTitel(\"Meine Tabelle\") table.setData(data) table.resize(400, 250) # new table.makeEvents() table.show() sys.exit(app.exec_())","title":"Signals and Slots f\u00fcr die Tabellennavigation"},{"location":"ch02/pyqt4.html#aufgabe-eine-tabelle-fur-pegelonline","text":"Zeigen Sie die Daten von Pegelonline in der Navigations-Tabelle an. Testdaten erhalten wir aus der Spatialite Datenbank: from pyspatialite import dbapi2 as db def readData(): dbname = r\"C:\\temp\\station.sqlite\" conn = db.connect(dbname) cur = conn.cursor() cur.execute(\"SELECT * FROM poStation WHERE water='MOSEL'\") data = cur.fetchall() return data und main \u00e4ndert sich ein weiteres Mal: def main(args): app = QApplication(args) table = NavTable() # new table.setTitel(\"Stationen von Pegelonline\") data = readData() table.setData(data) table.resize(400, 250) table.makeEvents() table.show() sys.exit(app.exec_())","title":"Aufgabe: Eine Tabelle f\u00fcr Pegelonline"},{"location":"ch02/pyqt4.html#dialoge","text":"Wir unterscheiden: Dialogboxen, die bereits als Klassen bestehen: Nachricht mit Ja/Nein, File Save/File Open, Farbwahl, Eingabezeile etc. Dokumentation Eigene Formulare und Dialoge auf Basis von Qdialog sind an ein anderes Widget (z.B. MainWindow) gebunden k\u00f6nnen modal oder unabh\u00e4ngig sein geben einen Wert zur\u00fcck Schema eines modalen Dialogs","title":"Dialoge"},{"location":"ch02/pyqt4.html#bestehende-dialoge","text":"Ein Dialog f\u00fcr eine Eingabe: text, ok = QInputDialog.getText(self, 'Titel', 'Eingabeaufforderung') liefert einen String zur\u00fcck und au\u00dferdem den Wert f\u00fcr OK mit true bzw. false, je nachdem, ob der Benutzer OK geklickt hat, ober nicht. Aufgerufen wird der Dialog von einem anderen Widget via Signal/Slot: # self is a QDialog self.btn = QtGui.QPushButton('Dialog', self) self.btn.clicked.connect(self.showInputDialog) def showInputDialog(self): text, ok = QtGui.QInputDialog.getText(self, 'Input Dialog', 'Enter your name:') if ok: print text Ein funktionierendes Beispiel zum Aufruf eines MessageBox-Dialogs import sys from PyQt4.QtCore import * from PyQt4.QtGui import * app = QApplication(sys.argv) w = QWidget() result = QMessageBox.question(w, 'Message', \"Do you like Python?\", QMessageBox.Yes | QMessageBox.No, QMessageBox.No) if result == QMessageBox.Yes: print \"yes\" else: print \"no\" w.show() app.exec_() Ein Beispiel f\u00fcr den Aufruf verschiedener Dialoge aus dem ZetCode PyQt4 tutorial von Jan Bodnar und pythonspot : (Jan Bodnar importiert das Modul QtGui anstelle von from PyQt4.QtGui import * ) import sys from PyQt4 import QtGui examples = [\"input\", \"color\", \"fileopen\"] class Example(QtGui.QWidget): def __init__(self, example): super(Example, self).__init__() self.initUI(example) def initUI(self, example): self.btn = QtGui.QPushButton('Dialog', self) self.btn.move(20, 20) if example in examples: if example == \"input\": self.btn.clicked.connect(self.showInputDialog) elif example == \"color\": self.btn.clicked.connect(self.showColorDialog) elif example == \"fileopen\": self.btn.clicked.connect(self.showFileOpenDialog) else: self.btn.clicked.connect(self.showMessageDialog) self.le = QtGui.QLineEdit(self) self.le.move(130, 22) self.setGeometry(300, 300, 290, 150) self.setWindowTitle('Input dialog') self.show() def showInputDialog(self): text, ok = QtGui.QInputDialog.getText(self, 'Input Dialog', 'Enter your name:') if ok: self.le.setText(str(text)) def showColorDialog(self): col = QtGui.QColorDialog.getColor() if col.isValid(): self.setStyleSheet(\"QWidget { background-color: %s }\" % col.name()) def showFileOpenDialog(self): fname = QtGui.QFileDialog.getOpenFileName(self, 'Open file', '.') self.le.setText(fname) def showMessageDialog(self): result = QtGui.QMessageBox.question(self, 'Message', \"Do you like Qt?\", QtGui.QMessageBox.Yes | QtGui.QMessageBox.No, QtGui.QMessageBox.No) if result == QtGui.QMessageBox.Yes: self.le.setText(\"Ja\") else: self.le.setText(\"Nein\") def main(): app = QtGui.QApplication(sys.argv) ex = Example(\"\") sys.exit(app.exec_()) if __name__ == '__main__': main() Zum Testen der Dialoge setzen wir f\u00fcr das Argument in Example(\"\") einen Wert aus der Liste ein: examples = [\"input\", \"color\", \"fileopen\"] , ein leerer String \u00f6ffnet einen Ja/Nein-Dialog. Die einzelnen Dialoge sind auch konfigurierbar. Hier die Varianten f\u00fcr den QFileDialog Kann Selektionen von einer oder mehreren Dateien beim Laden, Verzeichniswahl beim Speichern von Dateien etc. vornehmen Standardpfad und Dateifilter k\u00f6nnen u.a. \u00fcbergeben werden Unter der Vielzahl an Methoden des QFileDialog, sind die folgenden fast selbsterkl\u00e4rend: Methoden aus der Qt- C++-Dokumentation","title":"Bestehende Dialoge"},{"location":"ch02/pyqt4.html#eigene-dialoge","text":"Eigene Dialoge sind stets Kinder von QDialog Ein eigener Dialog wird in einer eigenen Klasse definiert, meist in einem eigenen Modul (Wiederverwertbarkeit!) Fast alle Dialoge ben\u00f6tigen Buttons zum Abschluss einer Eingabe Alle anderen erforderlichen Widgets k\u00f6nnen \u00fcber Layouts eingebunden werden der Dialog ist in der Regel von einem anderen Fenster abh\u00e4ngig (parent-Eigenschaft) Buttons eines Dialogs einrichten: die klassische Kombination aus \u201eOK/Cancel\u201c Buttons kann als einzelnes Widget umgesetzt werden Hierdurch bleibt die Reihenfolge der Buttons stets konform mit den Gepflogenheiten der jeweiligen Plattform (GNOME und MacOS X benutzen \u201eCancel/OK\u201c) buttonBox = QDialogButtonBox(QDialogButtonBox.Ok|QDialogButtonBox.Cancel) Die Buttonbox definiert eigene Signals f\u00fcr die Buttons: self.connect(self.buttonBox, SIGNAL(\"accepted()\"), self.accept) self.connect(self.buttonBox, SIGNAL(\"rejected()\"), self.reject) Um den Dialog aufzurufen, wird eine zus\u00e4tzliche Event-Schleife benutzt.","title":"eigene Dialoge"},{"location":"ch02/pyqt4.html#beispiel-fruchtedialog","text":"import sys from PyQt4.QtGui import * from PyQt4.QtCore import * class DialogFruits(QDialog): def __init__(self, parent=None): super(DialogFruits,self).__init__() self.value = \"\" self.setupUI(parent) def setupUI(self, parent=None): dialogLayout = QVBoxLayout() radioLayout = QHBoxLayout() self.b1 = QRadioButton(\"Apple\") self.b1.toggled.connect(lambda:self.btnstate(self.b1)) self.b1.setChecked(True) self.btnstate(self.b1) radioLayout.addWidget(self.b1) self.b2 = QRadioButton(\"Banana\") self.b2.toggled.connect(lambda:self.btnstate(self.b2)) radioLayout.addWidget(self.b2) self.b3 = QRadioButton(\"Orange\") self.b3.toggled.connect(lambda:self.btnstate(self.b3)) radioLayout.addWidget(self.b3) dialogLayout.addLayout(radioLayout) b1 = QPushButton(\"ok\") b1.clicked.connect(lambda:self.close()) dialogLayout.addWidget(b1) self.setLayout(dialogLayout) self.setWindowTitle(\"Fruits\") self.setWindowModality(Qt.ApplicationModal) def btnstate(self,b): self.value = b.text() def getValue(self): return self.value if __name__ == '__main__': app = QApplication(sys.argv) test = DialogFruits() test.show() app.exec_() print test.getValue() Ein Fr\u00fcchtedialog mit Testaufruf. Wir speichern es als eigenes Modul dialogfruits.py In einem Hauptfenster rufen wir den Dialog auf. Hierzu \u00fcbernehmen wir das Hauptfenster aus dem Beispiels der Standarddialoge und passen es etwas an: import sys from PyQt4 import QtGui from dialogfruits import DialogFruits class Example(QtGui.QWidget): def __init__(self, example): super(Example, self).__init__() self.initUI(example) def initUI(self, example): self.btn = QtGui.QPushButton('Fruits', self) self.btn.move(20, 20) self.btn.clicked.connect(self.showFruitsDialog) self.le = QtGui.QLineEdit(self) self.le.move(130, 22) self.setGeometry(300, 300, 290, 150) self.setWindowTitle('Choose a Fruit!') self.show() def showFruitsDialog(self): dlg = DialogFruits(self) dlg.exec_() v = dlg.getValue() self.le.setText(v) Ein Connect richtet das Event ein, in dem der Dialog aufgerufen wird. In showFruitsDialog() sehen wir, dass das Dialogfenster eine eigene Event-Loop bekommt. Eine weitere Erleichterung ergibt sich durch eine eigene Methode um den Event-Loop mit dlg.exec_() zu verbergen. H\u00e4ufig wird hierf\u00fcr der Name run() oder open() gew\u00e4hlt: # in der Dialog-Klasse: def run(self): self.exec_() return self.getValue() und so wird der Dialog dann aufgerufen: def showFruitsDialog(self): dlg = DialogFruits(self) # alt: # dlg.exec_() # v = dlg.getValue() # neu: v = dlg.run() self.le.setText(v)","title":"Beispiel: Fr\u00fcchtedialog"},{"location":"ch02/pyqt4.html#bildanzeige","text":"import urlreader3 import sys from PyQt4.QtGui import * def showimage(imgData, mylabel): pixmap = QPixmap() pixmap.loadFromData(imgData) mylabel.setPixmap(pixmap) mylabel.resize(pixmap.width(), pixmap.height()) app = QApplication(sys.argv) # to show the string Hello World in a window aLabel = QLabel() url = u\"http://pegelonline.wsv.de/webservices/rest-api/v2/stations/BONN/W/measurements.png?start=P15D&width=925&height=220\" imgdata = urlreader3.getDataResponse(url) showimage(imgdata, aLabel) # show window aLabel.show() app.exec_()","title":"Bildanzeige"},{"location":"ch02/pyqt4.html#qtdesigner","text":"Mit dem Qt-Designer k\u00f6nnen GUI's und Widgets interaktiv erstellt werden. Hier gibt eine kurze Einf\u00fchrung . Der QtDesigner ist Teil der PyQt-Installation. :Aufruf des QtDesigners","title":"QtDesigner"},{"location":"ch03/abschlussaufgabe.html","text":"Abschlussaufgabe Abgabe eines QGIS-Plugins zum Zugriff und Darstellung der Daten von Pegelonline. Kritierien zur Beurteilung des Codes Allgemeine Kriterien Bennenung von Klassen, Methoden und Variablen Bedeutung durch Namen erkennbar Syntaktisch eindeutig: Z.B. in Python (Pep8) geregelt, wichtig: konsistente Verwendung und Unterscheidung von Klassen, Methoden etc. Konsistenz in der Namensgebung Aufbau von Funktionen, Methoden Vermeidung von doppelt vorkommendem Code Code von Funktionen erf\u00fcllen eine definierte Aufgabe, sie rufen einander auf, um komplexere Aufgaben zu erf\u00fcller Code-Bl\u00f6cke (Funktionen) sind allgemein nicht l\u00e4nger als 20 Zeilen, in einigen F\u00e4llen unter 50 Zeilen, selten l\u00e4nger als 100 Zeilen Layout von Programmen (Lesbarkeit) -> Pep8! Konsistenter Aufbau eines Modules, einer Klasse durch sinnvolle Gruppierung von Elementen Importe stehen am Beginn, allgemeine Funktionen, Klassen-Definitionen folgen, main steht am Ende Vermeidung zu langer Zeilen, Einr\u00fcckungen bestehen immer aus Gruppen von 4 Leerzeichen Kommantare der Code ist ausreichend kommentiert aber nicht mit Kommentaren \u00fcberladen Funktionen verwenden einen doc string Code-Bl\u00f6cke werden mit einer Kommentarzeile eingeleitet komplexe if-Konstrukte werden erl\u00e4utert wichtige Variablen werden bei der Deklaration erl\u00e4utert TODO-Kommentare oder Auskommentierungen von nicht benutztem Code sollen entfernt werden, Ausnahmen sind denkbar f\u00fcr Dokumentation/Reflektion Fehlerbehandlung externe Module/Funktionen sollten gepr\u00fcft werden, ob und welche Fehler sie abfangen. Diese Fehlerbehadlung sollte \u00fcbernommen werden. IO-Operationen oder der Zugriff auf fremde Daten erfordern Fehlerbehandlungen Reaktionen auf Fehler m\u00fcssen geplant ablaufen, im schlimmsten Fall mit dem Abbruch einer Operation/des Programms (in Plugins kann nat\u00fcrlich nicht das umgebende Programm beendet werden...) Tests wo m\u00f6glich, enth\u00e4lt der Code Testroutinen, bei Modulen z.B. unter __main__ oder in Form von eigenen Testskripten Spezifische Anforderungen Dokumentation umfasst eine kurze Beschreibung des Plugins, inkl. aller aus Nutzersicht relevanter Funktionen (GUI, Anleitung) enth\u00e4lt eine technische Beschreibung zum Aufbau des Codes und der verwendeten Komponenten, kann als Begr\u00fcndung der Implementierung verfasst sein reflektieren sie ihre Arbeit, weisen sie auf Besondernheiten hin (positive wie negative) Lauff\u00e4higkeit als QGIS-Plugin eingebunden, startet und l\u00e4uft der Code fehlerfrei auch ungeplante Bedienung ist m\u00f6glich Vollst\u00e4ndigkeit die in der Veranstaltung besprochenen und in der GUI vorgesehenen Funktionen sind implementiert der abgegebene Code enth\u00e4lt alle notwendigen Komponenten, die nicht durch Python oder QGIS (wie auf dem Stick) gegeben sind Niveau und Kompetenz Aufbau des Plugins ist objektorientiert, eigene Module besitzen eine nachvollziehbare und sinnvolle Klassenstruktur Funktionen f\u00fcr den Internetzugriff, zur Datenbank, f\u00fcr GIS und Kartographie werden souver\u00e4n eingesetzt, korrekt kommentiert und dokumentiert Python-Klassen f\u00fcr Datenstrukturen werden kompetent und nachvollziehbar eingesetzt","title":"Abschlussaufgabe"},{"location":"ch03/abschlussaufgabe.html#abschlussaufgabe","text":"Abgabe eines QGIS-Plugins zum Zugriff und Darstellung der Daten von Pegelonline.","title":"Abschlussaufgabe"},{"location":"ch03/abschlussaufgabe.html#kritierien-zur-beurteilung-des-codes","text":"","title":"Kritierien zur Beurteilung des Codes"},{"location":"ch03/abschlussaufgabe.html#allgemeine-kriterien","text":"Bennenung von Klassen, Methoden und Variablen Bedeutung durch Namen erkennbar Syntaktisch eindeutig: Z.B. in Python (Pep8) geregelt, wichtig: konsistente Verwendung und Unterscheidung von Klassen, Methoden etc. Konsistenz in der Namensgebung Aufbau von Funktionen, Methoden Vermeidung von doppelt vorkommendem Code Code von Funktionen erf\u00fcllen eine definierte Aufgabe, sie rufen einander auf, um komplexere Aufgaben zu erf\u00fcller Code-Bl\u00f6cke (Funktionen) sind allgemein nicht l\u00e4nger als 20 Zeilen, in einigen F\u00e4llen unter 50 Zeilen, selten l\u00e4nger als 100 Zeilen Layout von Programmen (Lesbarkeit) -> Pep8! Konsistenter Aufbau eines Modules, einer Klasse durch sinnvolle Gruppierung von Elementen Importe stehen am Beginn, allgemeine Funktionen, Klassen-Definitionen folgen, main steht am Ende Vermeidung zu langer Zeilen, Einr\u00fcckungen bestehen immer aus Gruppen von 4 Leerzeichen Kommantare der Code ist ausreichend kommentiert aber nicht mit Kommentaren \u00fcberladen Funktionen verwenden einen doc string Code-Bl\u00f6cke werden mit einer Kommentarzeile eingeleitet komplexe if-Konstrukte werden erl\u00e4utert wichtige Variablen werden bei der Deklaration erl\u00e4utert TODO-Kommentare oder Auskommentierungen von nicht benutztem Code sollen entfernt werden, Ausnahmen sind denkbar f\u00fcr Dokumentation/Reflektion Fehlerbehandlung externe Module/Funktionen sollten gepr\u00fcft werden, ob und welche Fehler sie abfangen. Diese Fehlerbehadlung sollte \u00fcbernommen werden. IO-Operationen oder der Zugriff auf fremde Daten erfordern Fehlerbehandlungen Reaktionen auf Fehler m\u00fcssen geplant ablaufen, im schlimmsten Fall mit dem Abbruch einer Operation/des Programms (in Plugins kann nat\u00fcrlich nicht das umgebende Programm beendet werden...) Tests wo m\u00f6glich, enth\u00e4lt der Code Testroutinen, bei Modulen z.B. unter __main__ oder in Form von eigenen Testskripten","title":"Allgemeine Kriterien"},{"location":"ch03/abschlussaufgabe.html#spezifische-anforderungen","text":"Dokumentation umfasst eine kurze Beschreibung des Plugins, inkl. aller aus Nutzersicht relevanter Funktionen (GUI, Anleitung) enth\u00e4lt eine technische Beschreibung zum Aufbau des Codes und der verwendeten Komponenten, kann als Begr\u00fcndung der Implementierung verfasst sein reflektieren sie ihre Arbeit, weisen sie auf Besondernheiten hin (positive wie negative) Lauff\u00e4higkeit als QGIS-Plugin eingebunden, startet und l\u00e4uft der Code fehlerfrei auch ungeplante Bedienung ist m\u00f6glich Vollst\u00e4ndigkeit die in der Veranstaltung besprochenen und in der GUI vorgesehenen Funktionen sind implementiert der abgegebene Code enth\u00e4lt alle notwendigen Komponenten, die nicht durch Python oder QGIS (wie auf dem Stick) gegeben sind Niveau und Kompetenz Aufbau des Plugins ist objektorientiert, eigene Module besitzen eine nachvollziehbare und sinnvolle Klassenstruktur Funktionen f\u00fcr den Internetzugriff, zur Datenbank, f\u00fcr GIS und Kartographie werden souver\u00e4n eingesetzt, korrekt kommentiert und dokumentiert Python-Klassen f\u00fcr Datenstrukturen werden kompetent und nachvollziehbar eingesetzt","title":"Spezifische Anforderungen"},{"location":"ch03/p01_qgisplugin.html","text":"QGIS-Plugins Grundlagen Innerhalb von QGIS k\u00f6nnen Plugins benutzt werden, die erweiterte Funktionen in die Benutzeroberfl\u00e4che integrieren. Diese Plugins werden \u00fcblicherweise von einem Repositorium heruntergeladen und installiert. Zust\u00e4ndig hierf\u00fcr ist der Dialog Erweiterungen ( Plugins in der engl. Version) aus dem Men\u00fc desselben Namens (Men\u00fc->Erweiterungen->Erweiterungen verwalten und installieren). Wird ein Plugin nur f\u00fcr den Eigengebrauchentwickelt, so kann dieses auch als zip-File installiert oder die erforderlichen Ordner und Dateien direkt in das QGIS-Plugin-Verzeichnis kopiert werden. In QGIS k\u00f6nnen Plugins in verschiedener Form auftreten: als Dialogfenster (Formular), das sich \u00fcber der Anwendung \u00f6ffnet als Andockfenster (Panel), das sich in den Bereichen der Benutzeroberf\u00e4che eingf\u00fcgt zur Installation von Processing-Scripten, die in der Processing-Toolbox auftauchen Dialogfenster und Andockfenster werden \u00fcber ein Icon in einer Funktionleiste (Toolbar) aktiviert oder tauchen als Eintrag in einem Men\u00fc auf. Auch Mischformen k\u00f6nnen entwickelt werden oder es wird g\u00e4nzlich auf ein GUI f\u00fcr das Plugin verzichtet. Um ein eigenes Plugin zu schreiben, m\u00fcssen wir die Plugin-Schnittstelle beachten und implementieren den Installationspfad f\u00fcr PlugIns kennen einen Code entwickeln, der in QGIS ausgef\u00fchrt werden kann... Bevor wir soweit sind, installieren wir nutzt einige Helferlein und schauen uns ein Beispiel an, um den Aufbau eines Plugins zu analysieren. Helfer-Plugins Um die Erstellung und Programmierung von Plugins zu erleichtern, installieren wir zwei Helfer-Plugins: Plugin Builder 3 : Erstellt das Grundger\u00fcst eines Plugins, mit allen erforderlichen Dateien Plugin Reloader : Erm\u00f6glicht ein erneutes Einlesen des Plugins, z.B. nach \u00c4nderungen im Code, ohne QGIS jeweils neu starten zu m\u00fcssen Ein weiteres Helfer-Plugin kann bei der Fehlersuche sinnvoll sein: FirstAid f\u00e4ngt Python-Fehler in QGIS ab und bietet teilweise Funktionen eines Debuggers. Beispiel-Plugin Quick WKT Aus dem Repository installieren wir ein einfaches Plugin mit minimalem Code: Quick WKT Das Plugin verf\u00fcgt \u00fcber einen Dialog, um eine Texteingabe im Format WKT (Well-Known-Text) als Layer in QGIS anzuzeigen. Nach der Installation l\u00e4sst sich das Plugin \u00fcber die Werkzeugleiste \"Erweiterungen\" mit dem entsprechendem Icon aufrufen. Wir wollen den Python-Code analysieren, um herauszufinden, wie der Aufruf funktioniert. Alle heruntergeladenen Anwendungen werden in einem Verzeichnis ~/.qgis3/profiles/default/python/plugins bzw. ~/QGIS/QGIS3/profiles/default/python/plugins gespeichert. Hierbei entspricht die Tilde (~) dem Benutzerverzeichnis, auf dem GIS-Stick ist dies der Ordner \"Home\", unter Windows h\u00e4ufig C:\\Users\\benutzername\\AppData\\Roaming unter Linux /home/benutzername In dem Verzeichnis plugins befindet sich dann ein Ordner QuickWKT mit diesen Dateien und Unterordnern: __pycache__ icons __init__.py metadata.txt QuickWKT.py QuickWKTDialog.py Readme.rst resources.qrc Ui_QuickWkt.ui metadata.txt ist eine Pflichtdatei, es enth\u00e4lt eine Beschreibung des Plugins. __init__.py Mit __init__.py wird der Verzeichnisinhalt f\u00fcr den Python-Interpreter zu einem Package. Es kann in Python \u00fcber den Ordnernamen QuickWkt importiert werden. Die init-Datei wird dann als erstes gelesen und ausgef\u00fchrt. Diesen Mechanismus nutzt QGIS zum einbetten des Plugins: Es f\u00fcgt den Plugin-Pfad als Ort mit Python-Modulen dem Python-Interpreter hinzu und importiert automatisch alle Plugin-Packages. Beim Start von QGIS wird also die init-Datei jedes Moduls ausgef\u00fchrt! Zwingende Voraussetzung f\u00fcr ein QGIS-Plugin ist die Funktion 'classFactory()'. Sie bildet die Schnittstelle zum QGIS, das das iface-Objekt als Parameter \u00fcbergibt. def classFactory(iface): from .QuickWKT import QuickWKT return QuickWKT(iface) Die zentrale Klasse des Plugins wird hier importiert und eine Objekt-Instanz erstellt, die an QGIS zur\u00fcckgegeben wird. Diese Klasse enth\u00e4lt dann den Code, um das Plugin die Oberfl\u00e4che von Qgis, als Icon oder Men\u00fceintrag, zu integrieren. QuickWKT.py enth\u00e4lt die gleichnamige Klasse, die von __init__.py importiert und instanziiert wurde. Diese Klasse \u00fcbernimmt das iface-Objekt als Eigenschaft und definiert die Methode initGUI() . Diese wird von QGIS aufgerufen, um so die Verbindung zum Aufruf der GUI des Plugins zu erm\u00f6glichen. es wird ein QAction-Objekt erstellt und mit der run-Methode des Formulars verbunden hierbei wird ein Icon aus dem Unterordner icons eingelesen das QAction-Objekt wird in eine Toolbar und in das Plugin-Men\u00fc eingebaut. Ebenso gibt es eine Funktion zum Abmelden des Plugins aus QGIS: unload() entfernt schlicht die Aufrufm\u00f6glichkeiten f\u00fcr das Plugin, sodass es nicht mehr gestartet werden kann. In dieser Klasse finden wir auch die run-Methode, hier hei\u00dft sie quickwkt() . Die Methode zeigt den Dialog an, wenn der Benutzer das QAction als Klick auf das Icon oder im Men\u00fc ausl\u00f6st. Au\u00dferdem wertet sie aus, welche Eingaben im Dialog gemacht wurden und versucht einen Layer aus dem WKT-Textfeld zu erzeugen. resources.py die \u00dcbersetzung der XML-Datei resource.qrc, in der Icons und andere Medienelemente aufgef\u00fchrt sein k\u00f6nnen. Das Icon f\u00fcr das QAction-Objekt ist hier angegeben, die recource-Datei enth\u00e4lt den Dateinamen und einen relativen Pfad innerhalb QGIS-Plugin-Pfads. Allerdings ist in diesem Fall die resources.qrc nicht \u00fcbersetzt worden und wird wohl innerhalb des Plugins nicht verwendet. Wir w\u00fcrden sonst einen Import von resources in QuickWKT.py finden. Ui_QuickWKT.ui meist mit dem QtDesigner erstellte XML-Datei, welche die Benutzeroberfl\u00e4che beschreibt. Der Name ist frei w\u00e4hlbar, oft finden wir auch pluginname_dialog oder etwas \u00e4hnliches. Das Modul QuickWKTDialog importiert diese ui-Datei. QuickWKTDialog.py Hier wird die Logik des Dialogs festgelegt. Einmal aufgerufen, zeigt er die Widgets an, die in der ui-Datei Ui_QuickWKT.ui aufgef\u00fchrt sind. F\u00fcr diese enth\u00e4lt die Klasse die Signal-Slot-Angaben und Methoden. Der Dialog enth\u00e4lt z.B. eine ComboBox, die mit Werten gef\u00fcllt und mit der Methode on_exampleComboBox_currentIndexChanged verbunden wird. Die vorhandene Button-Leiste hat bereits vordefinierte Signal-Slots f\u00fcr Clear,OK und Cancel, die in der ui-Datei enthalten sind. Textfeld und CheckBox haben keinen verbundenen Signal-Slot. Lebenszyklus des Plugins untersuchen Mit ein paar wenigen print-Anweisungen wollen wir sehen, welche Methoden aus welchem Modul, wann aufgerufen werden. Wir beginnen mit __init__.py und dem Aufruf von classFactory, nehmen uns dann nacheinander alle Intialisierungsmethoden vor sowie die Stellen im Code, wo \"etwas passiert\" , z.B. in den Signal-Slot-Methoden. Wir \u00f6ffnen die QGIS-Python-Console, um die Ausgaben sehen zu k\u00f6nnen und benutzen den Plugin-Reloader, um das Plugin erneut einzulesen. Ein eigenes Plugin erstellen Um zu sehen, wie wir ein eigenes Plugin entwickeln k\u00f6nnen, wollen wir einen Dialog erstellen, der die Datenquellen (Pfade) aller geladenen Layer anzeigt. Unser Plugin soll daher ListLayers hei\u00dfen. Vorgehensweise: Um die n\u00f6tigen Dateien zu erhalten, nutzen wir den Plugin-Builder In die vom Plugin-Builder erstellte ui-Datei bearbeiten wir mit dem QtDesigner Wir \"installieren\" das Plugin im Plugin-Ordner und starten QGIS (neu) Der QGIS-Plugin Builder Das Modul integriert sich in die QGIS-Oberfl\u00e4che als Icon (Hammer) bzw. unter dem Men\u00fc Erweiterungen->Plugin Builder. Beim Start des Plugin \u00f6ffnet sich ein Dialog mit Formular. Wir folgen den Anweisungen und w\u00e4hlen als Template \"Tool button with dialog\". Fenster des PluginBuilder mit Pflichtfeldern Wir f\u00fcllen aus: ClassName: wird in den Code \u00fcbernommen und wird zu: class ListLayers(): Plugin-Name: Kann frei gew\u00e4hlt werden, z.B. List Layers Modulname: sollte dem Klassennamen entsprechen, wird zu listlayers.py Versionsangaben belassen wir ... Author/Company und Email address kann ihre Angaben beinhalten Weiter gehts: About: Kurzbeschreibung des Plugins N\u00e4chster Schritt: Template: Wir w\u00e4hlen Tool button mit Dialog Mit Menu kann festgelegt werden, in welchem Men\u00fc das Plugin in QGIS aufgerufen werden kann. Weiter: Angaben zu erweiterten Dateien und Tools zur Pluginentwicklung: diesmal abw\u00e4hlen Noch ein Schritt: Angaben zu bug tracker und code repository f\u00fcllen wir mit Platzhaltern letzter Schritt Wir w\u00e4hlen den Ausgabeordner und best\u00e4tigen mit \"Generate\" vom Plugin Builder erzeugte Dateien Wie wir sehen, legt der Plugin-Builder mehr Dateien an, als wir es von unserem ersten Beispiel kennen. Alle Angaben zu der Ausgabe des Plugin-Builder finden wir in der Dokumentation . Die dort erw\u00e4hnten Programme make und pb_tool verwenden wir zun\u00e4chst nicht! Anpassungen im QtDesigner Der Plugin-Builder erstellt eine ui-Datei mit einem leeren Dialog, den wir mit dem QtDesigner bearbeiten wollen (listlayers_dialog_base.ui). Unser Plugin soll alle geladen Layer mit ihrer Datenquelle anzeigen und in einer Datei speichern. Dazu ben\u00f6tigen wir geeignete Widgets im Formular: Dialog mit Labeln, ListWidget und LineEdit Au\u00dferdem existiert die Datei resources.qrc, die zun\u00e4chst \u00fcbersetzt werden muss, um sp\u00e4ter das Icon anzeigen zu k\u00f6nnen... In der OSGeo4W-Shell f\u00fchren wir hierzu folgende Befehle aus: <Laufwerksbuchstabe:> cd zu_pluin_ordner py3_env qt5_env pyrcc5 -o resources.py resources.qrc Logik des Plugin-Dialogs Im Beispiel-Plugin haben wir gesehen, dass innerhalb der run-Methode der Code zu finden ist, der ausgef\u00fchrt wird, wenn der Benutzer den Dialog mit OK beendet. In der vom Plugin-Builder erzeugten Datei listlayers.py sieht das so aus: def run(self): \"\"\"Run method that performs all the real work\"\"\" # Create the dialog with elements (after translation) and keep reference # Only create GUI ONCE in callback, so that it will only load when the plugin is started if self.first_start == True: self.first_start = False self.dlg = ListLayersDialog() # show the dialog self.dlg.show() # Run the dialog event loop result = self.dlg.exec_() # See if OK was pressed if result: # Do something useful here - delete the line containing pass and # substitute with your code. pass In unserem Fall bieten sich hier zwei Eingriffspunkte an: In der if-Abfrage if result: ersetzen wir pass durch den Code, der ausgef\u00fchrt wird, wenn der Benutzer den Dialog mit OK bereits wieder geschlossen hat Vor der Anzeige des Dialogs sollten wir aber die Widgets f\u00fcllen , vor allem das ListWidget. Zu Beginn der run-Methode wird \u00fcberpr\u00fcft, ob der Dialog zum ersten Mal ge\u00f6ffnet werden soll und er wird in diesem Fall an dieser Stelle \u00fcberhaupt erst erzeugt. Innerhalb des if-Blocks unter if self.first_start == True: bietet sich die M\u00f6glichkeit, den Dialog zu f\u00fcllen. Aber die run-Methode wird jedesmal ausgef\u00fchrt, wenn der Benutzer auf das Icon oder den Men\u00fceintrag klickt - Was ist, wenn zwischenzeitlich Layer hinzugef\u00fcgt oder entfernt wurden? Daher liegt die geeignete Stelle f\u00fcr unseren Code hinter der if-Anweisung und vor der Anzeige des Dialogs! def run(self): \"\"\"Run method that performs all the real work\"\"\" # Create the dialog with elements (after translation) and keep reference # Only create GUI ONCE in callback, so that it will only load when the plugin is started if self.first_start == True: self.first_start = False self.dlg = ListLayersDialog() # prepare dialogs content # show the dialog self.dlg.show() # Run the dialog event loop result = self.dlg.exec_() # See if OK was pressed if result: # Do something useful here - delete the line containing pass # get dialogs content and process pass Als erstes k\u00fcmmern wir uns um den Teil unter # prepare dialogs content Um das ListWidget f\u00fcllen, verwenden wir dessen Methode addItem() und \u00fcbertragen so die Datenquellen aller Layer: # prepare dialogs content print(\"run - prepare\") self.dlg.listWidget.clear() for lyr in self.iface.mapCanvas().layers(): print(lyr.dataProvider().dataSourceUri()) self.dlg.listWidget.addItem(lyr.dataProvider().dataSourceUri()) Hier iterieren wir \u00fcber alle Layer aus self.iface.mapCanvas().layers() . Um deren Datenquelle zu bestimmen ben\u00f6tigen wir den Provider und dessen Methode dataSourceUri: lyr.dataProvider().dataSourceUri() Schliesslich benutzen wir den Inhalt des ListWidgets und des LineEdits, um die Angaben in eine Datei zu schreiben, bzw. wie hier, um sie zun\u00e4chst mit print() auszugeben: if result: # Do something useful here - delete the line containing pass # get dialogs content and process filename = self.dlg.lineEdit.text() if filename: print(filename) for i in range(self.dlg.listWidget.count()): print(self.dlg.listWidget.item(i).text()) Auch hier durchlaufen wir eine for-Schleife, diesmal mit einer Index-Variablen i aus range und der Anzahl der Listenelemente: for i in range(self.dlg.listWidget.count()): . Die Variable i ben\u00f6tigen wir, um nacheinander die Eintr\u00e4ge der Liste zu erhalten, und zwar als Strings: self.dlg.listWidget.item(i).text() Aufgabe: Pegelonline-Layer als Plugin Eine Aufgabe zur Verbindung von Plugin und Pegelonline-Package pomodules. Wir erstellen ein simples Plugin mit Dialog, \u00fcber den die Stationen von PegelOnline als Layer in QGIS geladen werden. Grundlage ist das Script, \u00fcber das dieser Import \u00fcber die Python-Konsole m\u00f6glich ist. Der Code benutzt pomodules und soll nun in ein Plugin integriert werden. Hier ist eine m\u00f6gliche Umsetzung des urspr\u00fcnglichen Scripts: import sys sys.path.append(r\"mein_script_verzeichnis\") # ersetzen from pomodules.poqgsstations import PoQgsStations po = PoQgsStations() features = po.getFeatures() fields = po.fields crs = po.crs # QgsVectorLayer benutzt eine URI layer_uri = \"Point?crs=%s\"%crs.authid() # layer erzeugen: im Arbeitsspeicher, tempor\u00e4r vl = QgsVectorLayer(layer_uri, \"Stations\", \"memory\") # Provider = Dateiebene pr = vl.dataProvider() pr.addAttributes(fields) vl.updateFields() pr.addFeatures(features) vl.updateExtents() print(\"fields:\", len(pr.fields())) print(\"features:\", pr.featureCount()) e = vl.extent() print(\"extent:\", e.xMinimum(), e.yMinimum(), e.xMaximum(), e.yMaximum()) QgsProject.instance().addMapLayer(vl) Vorgehensweise In einem neuen Plugin poStationLoader muss nur der richtige Ort f\u00fcr den Code gefunden werden, und einige Anpassungen vorgenommen werden, damit der Code im Plugin l\u00e4uft: wir kopieren unser aktuelles pomodules in den Plugin-Ordner wir importieren die Klasse PoQgsStations im Kopfteil des Moduls postationloader.py, auf die Erweiterung des sys.path k\u00f6nnen wir verzichten. Allerdings ist pomodules jetzt Teil des Plugins (als Subpackage) und wird relativ importiert. wir importieren auch die verwendeten Klassen aus dem qgis.core-Modul: from qgis.core import (QgsVectorLayer, QgsProject) wir f\u00fcgen den restlichen Code z.B. als neue Methode 'loadStations()' ein und rufen diese in run() auf. \u00c4nderungen im Modul pomodules: stations from .urlreader import Urlreader from . import poBaseURL poqgsstations from .currentw import CurrentW postaionsloader.py from .pomodules.poqgsstations import PoQgsStations Erg\u00e4nzungen Beim Entwurf des pomodules-Package hatten wir geplant, auch die Wasserst\u00e4nde als QGIS-Layer laden zu k\u00f6nnen. Jetzt ist der richtige Zeitpunkt gekommen, dies auszuprobieren! F\u00fcgen Sie in das Dialogfenster eine Option ein, um entweder alle Stationen, oder die Stationen mit aktuellen Pegelst\u00e4nden zu laden. Wir erweitern hierzu das Package pomodules um die zwei Dateien pocurrentw.py und poqgscurrentw.py. Analog zum Laden der Stationen sollen in pocurrentw die json-Daten aufbereitet werden und in poqgscurrentw die aufbereiteten Daten als QgsFields und QgsFeatures bereitgestellt werden. Die Abfrage erfolgt mit der URL: stations.json?timeseries=W&includeTimeseries=true&includeCurrentMeasurement=true Attribute der Pegelonline-Wasserst\u00e4nde sind: 'geometry': ( d['longitude'], d['latitude']), 'attributes': ( d['uuid'], d['shortname'], d['timeseries'][0]['currentMeasurement']['timestamp'], d['timeseries'][0]['currentMeasurement']['value'], d['timeseries'][0]['currentMeasurement']['trend'], d['timeseries'][0]['currentMeasurement']['stateMnwMhw'], d['timeseries'][0]['currentMeasurement']['stateNswHsw']) Vergleiche auch hier im Kapitel zu QGIS mit Pegelonline-Daten","title":"Aufbau von QGIS-Plugins"},{"location":"ch03/p01_qgisplugin.html#qgis-plugins","text":"","title":"QGIS-Plugins"},{"location":"ch03/p01_qgisplugin.html#grundlagen","text":"Innerhalb von QGIS k\u00f6nnen Plugins benutzt werden, die erweiterte Funktionen in die Benutzeroberfl\u00e4che integrieren. Diese Plugins werden \u00fcblicherweise von einem Repositorium heruntergeladen und installiert. Zust\u00e4ndig hierf\u00fcr ist der Dialog Erweiterungen ( Plugins in der engl. Version) aus dem Men\u00fc desselben Namens (Men\u00fc->Erweiterungen->Erweiterungen verwalten und installieren). Wird ein Plugin nur f\u00fcr den Eigengebrauchentwickelt, so kann dieses auch als zip-File installiert oder die erforderlichen Ordner und Dateien direkt in das QGIS-Plugin-Verzeichnis kopiert werden. In QGIS k\u00f6nnen Plugins in verschiedener Form auftreten: als Dialogfenster (Formular), das sich \u00fcber der Anwendung \u00f6ffnet als Andockfenster (Panel), das sich in den Bereichen der Benutzeroberf\u00e4che eingf\u00fcgt zur Installation von Processing-Scripten, die in der Processing-Toolbox auftauchen Dialogfenster und Andockfenster werden \u00fcber ein Icon in einer Funktionleiste (Toolbar) aktiviert oder tauchen als Eintrag in einem Men\u00fc auf. Auch Mischformen k\u00f6nnen entwickelt werden oder es wird g\u00e4nzlich auf ein GUI f\u00fcr das Plugin verzichtet. Um ein eigenes Plugin zu schreiben, m\u00fcssen wir die Plugin-Schnittstelle beachten und implementieren den Installationspfad f\u00fcr PlugIns kennen einen Code entwickeln, der in QGIS ausgef\u00fchrt werden kann... Bevor wir soweit sind, installieren wir nutzt einige Helferlein und schauen uns ein Beispiel an, um den Aufbau eines Plugins zu analysieren.","title":"Grundlagen"},{"location":"ch03/p01_qgisplugin.html#helfer-plugins","text":"Um die Erstellung und Programmierung von Plugins zu erleichtern, installieren wir zwei Helfer-Plugins: Plugin Builder 3 : Erstellt das Grundger\u00fcst eines Plugins, mit allen erforderlichen Dateien Plugin Reloader : Erm\u00f6glicht ein erneutes Einlesen des Plugins, z.B. nach \u00c4nderungen im Code, ohne QGIS jeweils neu starten zu m\u00fcssen Ein weiteres Helfer-Plugin kann bei der Fehlersuche sinnvoll sein: FirstAid f\u00e4ngt Python-Fehler in QGIS ab und bietet teilweise Funktionen eines Debuggers.","title":"Helfer-Plugins"},{"location":"ch03/p01_qgisplugin.html#beispiel-plugin-quick-wkt","text":"Aus dem Repository installieren wir ein einfaches Plugin mit minimalem Code: Quick WKT Das Plugin verf\u00fcgt \u00fcber einen Dialog, um eine Texteingabe im Format WKT (Well-Known-Text) als Layer in QGIS anzuzeigen. Nach der Installation l\u00e4sst sich das Plugin \u00fcber die Werkzeugleiste \"Erweiterungen\" mit dem entsprechendem Icon aufrufen. Wir wollen den Python-Code analysieren, um herauszufinden, wie der Aufruf funktioniert. Alle heruntergeladenen Anwendungen werden in einem Verzeichnis ~/.qgis3/profiles/default/python/plugins bzw. ~/QGIS/QGIS3/profiles/default/python/plugins gespeichert. Hierbei entspricht die Tilde (~) dem Benutzerverzeichnis, auf dem GIS-Stick ist dies der Ordner \"Home\", unter Windows h\u00e4ufig C:\\Users\\benutzername\\AppData\\Roaming unter Linux /home/benutzername In dem Verzeichnis plugins befindet sich dann ein Ordner QuickWKT mit diesen Dateien und Unterordnern: __pycache__ icons __init__.py metadata.txt QuickWKT.py QuickWKTDialog.py Readme.rst resources.qrc Ui_QuickWkt.ui metadata.txt ist eine Pflichtdatei, es enth\u00e4lt eine Beschreibung des Plugins. __init__.py Mit __init__.py wird der Verzeichnisinhalt f\u00fcr den Python-Interpreter zu einem Package. Es kann in Python \u00fcber den Ordnernamen QuickWkt importiert werden. Die init-Datei wird dann als erstes gelesen und ausgef\u00fchrt. Diesen Mechanismus nutzt QGIS zum einbetten des Plugins: Es f\u00fcgt den Plugin-Pfad als Ort mit Python-Modulen dem Python-Interpreter hinzu und importiert automatisch alle Plugin-Packages. Beim Start von QGIS wird also die init-Datei jedes Moduls ausgef\u00fchrt! Zwingende Voraussetzung f\u00fcr ein QGIS-Plugin ist die Funktion 'classFactory()'. Sie bildet die Schnittstelle zum QGIS, das das iface-Objekt als Parameter \u00fcbergibt. def classFactory(iface): from .QuickWKT import QuickWKT return QuickWKT(iface) Die zentrale Klasse des Plugins wird hier importiert und eine Objekt-Instanz erstellt, die an QGIS zur\u00fcckgegeben wird. Diese Klasse enth\u00e4lt dann den Code, um das Plugin die Oberfl\u00e4che von Qgis, als Icon oder Men\u00fceintrag, zu integrieren. QuickWKT.py enth\u00e4lt die gleichnamige Klasse, die von __init__.py importiert und instanziiert wurde. Diese Klasse \u00fcbernimmt das iface-Objekt als Eigenschaft und definiert die Methode initGUI() . Diese wird von QGIS aufgerufen, um so die Verbindung zum Aufruf der GUI des Plugins zu erm\u00f6glichen. es wird ein QAction-Objekt erstellt und mit der run-Methode des Formulars verbunden hierbei wird ein Icon aus dem Unterordner icons eingelesen das QAction-Objekt wird in eine Toolbar und in das Plugin-Men\u00fc eingebaut. Ebenso gibt es eine Funktion zum Abmelden des Plugins aus QGIS: unload() entfernt schlicht die Aufrufm\u00f6glichkeiten f\u00fcr das Plugin, sodass es nicht mehr gestartet werden kann. In dieser Klasse finden wir auch die run-Methode, hier hei\u00dft sie quickwkt() . Die Methode zeigt den Dialog an, wenn der Benutzer das QAction als Klick auf das Icon oder im Men\u00fc ausl\u00f6st. Au\u00dferdem wertet sie aus, welche Eingaben im Dialog gemacht wurden und versucht einen Layer aus dem WKT-Textfeld zu erzeugen. resources.py die \u00dcbersetzung der XML-Datei resource.qrc, in der Icons und andere Medienelemente aufgef\u00fchrt sein k\u00f6nnen. Das Icon f\u00fcr das QAction-Objekt ist hier angegeben, die recource-Datei enth\u00e4lt den Dateinamen und einen relativen Pfad innerhalb QGIS-Plugin-Pfads. Allerdings ist in diesem Fall die resources.qrc nicht \u00fcbersetzt worden und wird wohl innerhalb des Plugins nicht verwendet. Wir w\u00fcrden sonst einen Import von resources in QuickWKT.py finden. Ui_QuickWKT.ui meist mit dem QtDesigner erstellte XML-Datei, welche die Benutzeroberfl\u00e4che beschreibt. Der Name ist frei w\u00e4hlbar, oft finden wir auch pluginname_dialog oder etwas \u00e4hnliches. Das Modul QuickWKTDialog importiert diese ui-Datei. QuickWKTDialog.py Hier wird die Logik des Dialogs festgelegt. Einmal aufgerufen, zeigt er die Widgets an, die in der ui-Datei Ui_QuickWKT.ui aufgef\u00fchrt sind. F\u00fcr diese enth\u00e4lt die Klasse die Signal-Slot-Angaben und Methoden. Der Dialog enth\u00e4lt z.B. eine ComboBox, die mit Werten gef\u00fcllt und mit der Methode on_exampleComboBox_currentIndexChanged verbunden wird. Die vorhandene Button-Leiste hat bereits vordefinierte Signal-Slots f\u00fcr Clear,OK und Cancel, die in der ui-Datei enthalten sind. Textfeld und CheckBox haben keinen verbundenen Signal-Slot.","title":"Beispiel-Plugin Quick WKT"},{"location":"ch03/p01_qgisplugin.html#lebenszyklus-des-plugins-untersuchen","text":"Mit ein paar wenigen print-Anweisungen wollen wir sehen, welche Methoden aus welchem Modul, wann aufgerufen werden. Wir beginnen mit __init__.py und dem Aufruf von classFactory, nehmen uns dann nacheinander alle Intialisierungsmethoden vor sowie die Stellen im Code, wo \"etwas passiert\" , z.B. in den Signal-Slot-Methoden. Wir \u00f6ffnen die QGIS-Python-Console, um die Ausgaben sehen zu k\u00f6nnen und benutzen den Plugin-Reloader, um das Plugin erneut einzulesen.","title":"Lebenszyklus des Plugins untersuchen"},{"location":"ch03/p01_qgisplugin.html#ein-eigenes-plugin-erstellen","text":"Um zu sehen, wie wir ein eigenes Plugin entwickeln k\u00f6nnen, wollen wir einen Dialog erstellen, der die Datenquellen (Pfade) aller geladenen Layer anzeigt. Unser Plugin soll daher ListLayers hei\u00dfen. Vorgehensweise: Um die n\u00f6tigen Dateien zu erhalten, nutzen wir den Plugin-Builder In die vom Plugin-Builder erstellte ui-Datei bearbeiten wir mit dem QtDesigner Wir \"installieren\" das Plugin im Plugin-Ordner und starten QGIS (neu)","title":"Ein eigenes Plugin erstellen"},{"location":"ch03/p01_qgisplugin.html#der-qgis-plugin-builder","text":"Das Modul integriert sich in die QGIS-Oberfl\u00e4che als Icon (Hammer) bzw. unter dem Men\u00fc Erweiterungen->Plugin Builder. Beim Start des Plugin \u00f6ffnet sich ein Dialog mit Formular. Wir folgen den Anweisungen und w\u00e4hlen als Template \"Tool button with dialog\". Fenster des PluginBuilder mit Pflichtfeldern Wir f\u00fcllen aus: ClassName: wird in den Code \u00fcbernommen und wird zu: class ListLayers(): Plugin-Name: Kann frei gew\u00e4hlt werden, z.B. List Layers Modulname: sollte dem Klassennamen entsprechen, wird zu listlayers.py Versionsangaben belassen wir ... Author/Company und Email address kann ihre Angaben beinhalten Weiter gehts: About: Kurzbeschreibung des Plugins N\u00e4chster Schritt: Template: Wir w\u00e4hlen Tool button mit Dialog Mit Menu kann festgelegt werden, in welchem Men\u00fc das Plugin in QGIS aufgerufen werden kann. Weiter: Angaben zu erweiterten Dateien und Tools zur Pluginentwicklung: diesmal abw\u00e4hlen Noch ein Schritt: Angaben zu bug tracker und code repository f\u00fcllen wir mit Platzhaltern letzter Schritt Wir w\u00e4hlen den Ausgabeordner und best\u00e4tigen mit \"Generate\" vom Plugin Builder erzeugte Dateien Wie wir sehen, legt der Plugin-Builder mehr Dateien an, als wir es von unserem ersten Beispiel kennen. Alle Angaben zu der Ausgabe des Plugin-Builder finden wir in der Dokumentation . Die dort erw\u00e4hnten Programme make und pb_tool verwenden wir zun\u00e4chst nicht!","title":"Der QGIS-Plugin Builder"},{"location":"ch03/p01_qgisplugin.html#anpassungen-im-qtdesigner","text":"Der Plugin-Builder erstellt eine ui-Datei mit einem leeren Dialog, den wir mit dem QtDesigner bearbeiten wollen (listlayers_dialog_base.ui). Unser Plugin soll alle geladen Layer mit ihrer Datenquelle anzeigen und in einer Datei speichern. Dazu ben\u00f6tigen wir geeignete Widgets im Formular: Dialog mit Labeln, ListWidget und LineEdit Au\u00dferdem existiert die Datei resources.qrc, die zun\u00e4chst \u00fcbersetzt werden muss, um sp\u00e4ter das Icon anzeigen zu k\u00f6nnen... In der OSGeo4W-Shell f\u00fchren wir hierzu folgende Befehle aus: <Laufwerksbuchstabe:> cd zu_pluin_ordner py3_env qt5_env pyrcc5 -o resources.py resources.qrc","title":"Anpassungen im QtDesigner"},{"location":"ch03/p01_qgisplugin.html#logik-des-plugin-dialogs","text":"Im Beispiel-Plugin haben wir gesehen, dass innerhalb der run-Methode der Code zu finden ist, der ausgef\u00fchrt wird, wenn der Benutzer den Dialog mit OK beendet. In der vom Plugin-Builder erzeugten Datei listlayers.py sieht das so aus: def run(self): \"\"\"Run method that performs all the real work\"\"\" # Create the dialog with elements (after translation) and keep reference # Only create GUI ONCE in callback, so that it will only load when the plugin is started if self.first_start == True: self.first_start = False self.dlg = ListLayersDialog() # show the dialog self.dlg.show() # Run the dialog event loop result = self.dlg.exec_() # See if OK was pressed if result: # Do something useful here - delete the line containing pass and # substitute with your code. pass In unserem Fall bieten sich hier zwei Eingriffspunkte an: In der if-Abfrage if result: ersetzen wir pass durch den Code, der ausgef\u00fchrt wird, wenn der Benutzer den Dialog mit OK bereits wieder geschlossen hat Vor der Anzeige des Dialogs sollten wir aber die Widgets f\u00fcllen , vor allem das ListWidget. Zu Beginn der run-Methode wird \u00fcberpr\u00fcft, ob der Dialog zum ersten Mal ge\u00f6ffnet werden soll und er wird in diesem Fall an dieser Stelle \u00fcberhaupt erst erzeugt. Innerhalb des if-Blocks unter if self.first_start == True: bietet sich die M\u00f6glichkeit, den Dialog zu f\u00fcllen. Aber die run-Methode wird jedesmal ausgef\u00fchrt, wenn der Benutzer auf das Icon oder den Men\u00fceintrag klickt - Was ist, wenn zwischenzeitlich Layer hinzugef\u00fcgt oder entfernt wurden? Daher liegt die geeignete Stelle f\u00fcr unseren Code hinter der if-Anweisung und vor der Anzeige des Dialogs! def run(self): \"\"\"Run method that performs all the real work\"\"\" # Create the dialog with elements (after translation) and keep reference # Only create GUI ONCE in callback, so that it will only load when the plugin is started if self.first_start == True: self.first_start = False self.dlg = ListLayersDialog() # prepare dialogs content # show the dialog self.dlg.show() # Run the dialog event loop result = self.dlg.exec_() # See if OK was pressed if result: # Do something useful here - delete the line containing pass # get dialogs content and process pass Als erstes k\u00fcmmern wir uns um den Teil unter # prepare dialogs content Um das ListWidget f\u00fcllen, verwenden wir dessen Methode addItem() und \u00fcbertragen so die Datenquellen aller Layer: # prepare dialogs content print(\"run - prepare\") self.dlg.listWidget.clear() for lyr in self.iface.mapCanvas().layers(): print(lyr.dataProvider().dataSourceUri()) self.dlg.listWidget.addItem(lyr.dataProvider().dataSourceUri()) Hier iterieren wir \u00fcber alle Layer aus self.iface.mapCanvas().layers() . Um deren Datenquelle zu bestimmen ben\u00f6tigen wir den Provider und dessen Methode dataSourceUri: lyr.dataProvider().dataSourceUri() Schliesslich benutzen wir den Inhalt des ListWidgets und des LineEdits, um die Angaben in eine Datei zu schreiben, bzw. wie hier, um sie zun\u00e4chst mit print() auszugeben: if result: # Do something useful here - delete the line containing pass # get dialogs content and process filename = self.dlg.lineEdit.text() if filename: print(filename) for i in range(self.dlg.listWidget.count()): print(self.dlg.listWidget.item(i).text()) Auch hier durchlaufen wir eine for-Schleife, diesmal mit einer Index-Variablen i aus range und der Anzahl der Listenelemente: for i in range(self.dlg.listWidget.count()): . Die Variable i ben\u00f6tigen wir, um nacheinander die Eintr\u00e4ge der Liste zu erhalten, und zwar als Strings: self.dlg.listWidget.item(i).text()","title":"Logik des Plugin-Dialogs"},{"location":"ch03/p01_qgisplugin.html#aufgabe-pegelonline-layer-als-plugin","text":"Eine Aufgabe zur Verbindung von Plugin und Pegelonline-Package pomodules. Wir erstellen ein simples Plugin mit Dialog, \u00fcber den die Stationen von PegelOnline als Layer in QGIS geladen werden. Grundlage ist das Script, \u00fcber das dieser Import \u00fcber die Python-Konsole m\u00f6glich ist. Der Code benutzt pomodules und soll nun in ein Plugin integriert werden. Hier ist eine m\u00f6gliche Umsetzung des urspr\u00fcnglichen Scripts: import sys sys.path.append(r\"mein_script_verzeichnis\") # ersetzen from pomodules.poqgsstations import PoQgsStations po = PoQgsStations() features = po.getFeatures() fields = po.fields crs = po.crs # QgsVectorLayer benutzt eine URI layer_uri = \"Point?crs=%s\"%crs.authid() # layer erzeugen: im Arbeitsspeicher, tempor\u00e4r vl = QgsVectorLayer(layer_uri, \"Stations\", \"memory\") # Provider = Dateiebene pr = vl.dataProvider() pr.addAttributes(fields) vl.updateFields() pr.addFeatures(features) vl.updateExtents() print(\"fields:\", len(pr.fields())) print(\"features:\", pr.featureCount()) e = vl.extent() print(\"extent:\", e.xMinimum(), e.yMinimum(), e.xMaximum(), e.yMaximum()) QgsProject.instance().addMapLayer(vl)","title":"Aufgabe: Pegelonline-Layer als Plugin"},{"location":"ch03/p01_qgisplugin.html#vorgehensweise","text":"In einem neuen Plugin poStationLoader muss nur der richtige Ort f\u00fcr den Code gefunden werden, und einige Anpassungen vorgenommen werden, damit der Code im Plugin l\u00e4uft: wir kopieren unser aktuelles pomodules in den Plugin-Ordner wir importieren die Klasse PoQgsStations im Kopfteil des Moduls postationloader.py, auf die Erweiterung des sys.path k\u00f6nnen wir verzichten. Allerdings ist pomodules jetzt Teil des Plugins (als Subpackage) und wird relativ importiert. wir importieren auch die verwendeten Klassen aus dem qgis.core-Modul: from qgis.core import (QgsVectorLayer, QgsProject) wir f\u00fcgen den restlichen Code z.B. als neue Methode 'loadStations()' ein und rufen diese in run() auf. \u00c4nderungen im Modul pomodules: stations from .urlreader import Urlreader from . import poBaseURL poqgsstations from .currentw import CurrentW postaionsloader.py from .pomodules.poqgsstations import PoQgsStations","title":"Vorgehensweise"},{"location":"ch03/p01_qgisplugin.html#erganzungen","text":"Beim Entwurf des pomodules-Package hatten wir geplant, auch die Wasserst\u00e4nde als QGIS-Layer laden zu k\u00f6nnen. Jetzt ist der richtige Zeitpunkt gekommen, dies auszuprobieren! F\u00fcgen Sie in das Dialogfenster eine Option ein, um entweder alle Stationen, oder die Stationen mit aktuellen Pegelst\u00e4nden zu laden. Wir erweitern hierzu das Package pomodules um die zwei Dateien pocurrentw.py und poqgscurrentw.py. Analog zum Laden der Stationen sollen in pocurrentw die json-Daten aufbereitet werden und in poqgscurrentw die aufbereiteten Daten als QgsFields und QgsFeatures bereitgestellt werden. Die Abfrage erfolgt mit der URL: stations.json?timeseries=W&includeTimeseries=true&includeCurrentMeasurement=true Attribute der Pegelonline-Wasserst\u00e4nde sind: 'geometry': ( d['longitude'], d['latitude']), 'attributes': ( d['uuid'], d['shortname'], d['timeseries'][0]['currentMeasurement']['timestamp'], d['timeseries'][0]['currentMeasurement']['value'], d['timeseries'][0]['currentMeasurement']['trend'], d['timeseries'][0]['currentMeasurement']['stateMnwMhw'], d['timeseries'][0]['currentMeasurement']['stateNswHsw']) Vergleiche auch hier im Kapitel zu QGIS mit Pegelonline-Daten","title":"Erg\u00e4nzungen"},{"location":"ch03/p02_pluginentwurf.html","text":"Voraussetzungen Die Basis f\u00fcr QGIS-Plugin bilden die Abfragen auf den Pegelonline-Datenbestand: Stationen Wasserst\u00e4nde Stationsbezogene Pegelverl\u00e4ufe als Diagramm Es sollen folgende Funktionen im Plugin realisiert werden: Laden und Anzeigen des Datenbestands -> Aus den json-Daten von Pegelonline werden QGIS-Layer erzeugt und visualisiert Erg\u00e4nzungen: \"Basiskarte\", Darstellung unterschiedlicher Attribute -> \u00c4nderung der Darstellung f\u00fcr z.B. Wasserst\u00e4nde ... Plugin-GUI: Das GUI wird als Dockwidget realisiert und erlaubt die Steuerung aller Funktionen und Interaktionen Layer: Selektionen von Stationen Integration des \"Custom\"-Widgets Pegelverlauf-Graph m\u00f6gliches GUI des Plugin Mit dem Plugin-Builder wird ein Dockwidget samt Logik erzeugt. Dies stellt eine Variante zum Dialog dar, und ist geeignet, mehrere interaktive Funktionen zu steuern, da ein Dockwidget dauerhaft angezeigt bleibt. Module einrichten Vorgehensweise: mit dem Plugin-Builder erstellen wir ein neues Plugin \"pegelonline\". in der OSGeo4W-Shell \u00fcbersetzen wir die Datei resources.qrc mit dem Programm pyrcc5 wir f\u00fcgen dem Plugin ein Modul hinzu, um alle unsere Funktionen zu integrieren: po_runner.py mit einer Klasse: class PoRunner PoRunner wird die zentrale Stelle, in der wir unsere Funktionen f\u00fcr das Plugin schreiben. Damit erhalten wir eine besserer \u00dcbersicht \u00fcber unseren eigenen Code und ver\u00e4ndern die vom Plugin-Builder erzeugten Modul nur minimal. Hierzu importieren wir in pegelonline.py : # Our runner-class from .po_runner import PoRunner und erstellen dort innerhalb der run-Methode ein Objekt z.B. als self.runner def run(self): \"\"\"Run method that loads and starts the plugin\"\"\" if not self.pluginIsActive: self.pluginIsActive = True if self.dockwidget == None: # Create the dockwidget self.dockwidget = PegelOnlineDockWidget() # setup runner class self.runner = PoRunner(self.dockwidget, self.iface) PoRunner Mit PoRunner lagern wir alle Funktionen in einem eigenen Modul und in einer Klasse aus. Die Schnittstelle zum Plugin erhalten \u00fcber zwei Objekte: iface und ui (das Dockwidget und seine Widgets): class PoRunner(object): def __init__(self, ui, iface): self.ui = ui self.iface = iface PoRunner wird s\u00e4mtliche Funktionen enthalten, die zum Betrieb des Plugins geschrieben werden m\u00fcssen: Methoden f\u00fcr Signal-Slots Methoden zur Zusammenarbeit mit pomodules from .pomodules.poqgsstations import PoQgsStations from .pomodules.poqgscurrentw import PoQgsCurrentW Falls poqgscurrentw noch nicht existiert, kommentieren wir es zun\u00e4chst aus. Jetzt k\u00f6nnen wir das Plugin testen. Dazu kopieren wir den Ordner in das QGIS-Plugin-Verzeichnis und starten QGIS. Eventuell muss das neue Plugin noch unter dem Men\u00fc Erweiterungen aktiviert werden! Eine erste Version des GUI Einbinden einer Basiskarte \u00dcber eine Basiskarte soll eine minimale Orientierungshilfe gegeben werden. Sie wird die Fl\u00fcsse/Gew\u00e4sser enthalten, an denen Stationen liegen. Hierzu erstellen wir in unserem Plugin-Ordner eine Unterodner basemap und speichern dort die Daten zur Basiskarte. In diesem Fall ist es ein GeoPackage 'waters.gpkg' mit zwei Layern (waters_l und waters_f). Au\u00dferdem enth\u00e4lt das GeoPackage zwei Styles (water_f_style, water_l_style), die mit beiden Layer verkn\u00fcpft sind und deren Darstellung festlegen. Die Basiskarte des Plugins Die Basiskarte muss optimalerweise beim Laden in QGIS als letztes (oder ganz unten) in der Legende eingef\u00fcgt werden, damit andere Informatione dar\u00fcber gezeichnet werden k\u00f6nnen. Hierzu gibt es ein kleines Rezept aus dem PyQGIS-Cookbook: #... layer wurde erstellt, dann: layerTree = iface.layerTreeCanvasBridge().rootGroup() layerTree.insertChildNode(-1, QgsLayerTreeLayer(vlayer)) Das folgende Beispiel basemap.py zeigt eine lauff\u00e4higen Code f\u00fcr die QGIS-Python-Konsole: import os def show_basemap(): local_dir = r\"c:\\Mein_Plugin_Ordner\\basemap\" water_lines = os.path.join(local_dir, \"waters.gpkg|layername=water_l\") water_areas = os.path.join(local_dir, \"waters.gpkg|layername=water_f\") vlayer = QgsVectorLayer(water_lines, \"Fl\u00fcsse\", \"ogr\") if not vlayer.isValid(): print(\"Layer '%s' not valid\"%water_lines) return QgsProject.instance().addMapLayer(vlayer, False) layerTree = iface.layerTreeCanvasBridge().rootGroup() layerTree.insertChildNode(-1, QgsLayerTreeLayer(vlayer)) vlayer = QgsVectorLayer(water_areas, \"Gew\u00e4sser\", \"ogr\") if not vlayer.isValid(): print(\"Layer '%s' not valid\"%water_areas) return QgsProject.instance().addMapLayer(vlayer, False) layerTree = iface.layerTreeCanvasBridge().rootGroup() layerTree.insertChildNode(-1, QgsLayerTreeLayer(vlayer)) show_basemap() Wir k\u00f6nnen die Grafikvorgaben eines Styles auch \u00e4ndern und im GeoPackage aktualisieren. Style-Eigenschaften mit QGIS speichern wir \u00e4ndern die Grafik des Layers in QGIS dann w\u00e4hlen wir in der QGIS-Legende den Layer aus und rufen das Eigenschaften-Fenster auf (Properties) unter Stil (Style) k\u00f6nnen wir die aktuellen Grafikeinstellungen speichern um den vorhandenen Stil zu aktualisieren, benutzen wir denselben Stilnamen Angabe der Optionen beim Speichern Layermanagement Im Plugin wird auf Layer zugegriffen Pegelonlinedaten werden geladen und ein Layer erzeugt Es werden Funktionen auf den Layer angewendet Layer k\u00f6nnen im Plugin referenziert werden, \u00fcber den Namen \u00fcber eine ID (Name+Zufallsstring) \u00fcber ein Layer-Objekt (QgsVectorLayer) Was passiert wenn der Nutzer die abgerufenen Informationen aktualisiert und neue Layer erzeugt? den Layer in QGIS l\u00f6scht? in einem Layer Daten selektiert? Laden Ladevorgang (wie im Script basemap.py ) wir merken uns alle Layer im Plugin als Layer-Objekt (self.stationen = vlayer) Aktualisieren werden die Daten neu geladen, so erstellen wir einen neuen Layer wir verfahren wie beim Laden L\u00f6schen Der Benutzer kann einen Layer l\u00f6schen, dies muss unser Plugin registrieren Die Variable und Referenz zum Layer wird zur\u00fcckgesetzt (self.stationen = None) Beispiel \"Basemap\" Im Plugin als Option (QCheckBox) Option steht auf aus : Kein Layer geladen Benutzer schaltet Option ein: Layer wird geladen Layer wird angezeigt Benutzer schaltet Option wieder aus Layer wird nicht gel\u00f6scht, sondern nur ausgeblendet Alternativ: Layer l\u00f6schen und neu laden ... CheckBox zur Anzeige der Basiskarte Wir richten mit QtDesinger eine CheckBox ein, Name chBshowBasemap eine Methode in PoRunner \u00fcbernimmt die Signal-Slot-Definitionen: init_connects() Wir schreiben einen Slot(Methode) als doBasemapOptionChanged Umsetzung in po_runner: # ver\u00e4nderte init-Methode def __init__(self, ui, iface): self.ui = ui self.iface = iface self.init_connects() self.local_dir = os.path.dirname(os.path.realpath(__file__)) # neue Methode init_connects def init_connects(self): self.ui.chBshowBasemap.toggled.connect(self.doBasemapOptionChanged) # Slot-Methode doBasemapOptionChanged def doBasemapOptionChanged(self): pass Ein Layer kann \u00fcber Python ein- und ausgeschaltet werden, indem auf das Legendenobjekt LayerTreeRoot zugriffen wird. Die enth\u00e4lt Eintr\u00e4ge (items), die mit setItemVisibilityChecked() auf True bzw False gesetzt werden. Ein Beispiel f\u00fcr die QGIS-Python-Konsole: lyr = iface.activeLayer() lt = QgsProject.instance().layerTreeRoot().findLayer(lyr.id()) lt.setItemVisibilityChecked(False) Innerhalb des Plugins pr\u00fcfen wir innerhlb des Slots f\u00fcr die CheckBox, ob ein- oder ausgeschaltet wurde: def doBasemapOptionChanged(self): if self.ui.chBshowBasemap.isChecked() == True: # Layer anzeigen else: # Layer ausblenden Basemap-Layer verwalten Zur Verwaltung des Layers geh\u00f6rt die Referenz auf das Objekt und das Verhalten des Plugins bei Ver\u00e4nderungen an diesem Layer. Zun\u00e4chst, pr\u00fcfen wir, ob der Layer bereits geladen wurde, andernfall wird der Layer geladen. Das Laden erfolgt wie in basemap.py getestet. Zus\u00e4tzlich merken wir uns das erstellte VectorLayer-Objekt blenden wir nur ein, wenn der Nutzer die Aktion nochmals ausl\u00f6st wurde und der Layer schon erzeugt wurde water_lines = os.path.join(self.local_dir, \"basemap\", \"waters.gpkg|layername=water_l\") # Layer bereits erstellt? if self.base_l is None: vl = QgsVectorLayer(water_lines, \"Fl\u00fcsse\", \"ogr\") if not vl.isValid(): print(\"Layer '%s' not valid\"%water_lines) return QgsProject.instance().addMapLayer(vl, False) layerTree = self.iface.layerTreeCanvasBridge().rootGroup() layerTree.insertChildNode(-1, QgsLayerTreeLayer(vl)) self.base_l = vl # nur einblenden else: lyrtree = QgsProject.instance().layerTreeRoot().findLayer(self.base_l.id()) lyrtree.setItemVisibilityChecked(True) HINWEISE: In po_runner m\u00fcssen die ben\u00f6tigten PyQGI-Klassen aus qgis.core importiert werden dasselbe Vorgehen wie oben w\u00e4hlen wir f\u00fcr den zweiten Layer water_f . Eine weitere Anforderung unseres Plugins betrifft den Vorgang, wenn ein Nutzer einen oder beide Layer in der QGIS-Legende l\u00f6scht. In diesem Fall zeigen die Variablen der QgsVektorLayer auf einen Layer, der nicht mehr existiert und es kann zu Fehlern in unserem Code kommen. Es existiert ein Signal (Event), das ausgel\u00f6st wird, wenn der Layer gel\u00f6scht werden soll: willBeDeleted eine entsprechende Anweisung wird in doBasemapOptionChanged eingef\u00fcgt, dort wo der Layer erstellt wird self.base_l.willBeDeleted.connect(self.doDisconnectBaseL) mit dem zugeh\u00f6rige Slot sollte auch gepr\u00fcft werden, ob andere Objekte von der Aktion betroffen sind, z.B. der CheckBox-Schalter. Minimal sollten wir auf jeden Fall die Layer-Variable zur\u00fccksetzen: def doDisconnectBaseL(self): self.base_l = None","title":"Entwurf des PegelOnline-Plugin"},{"location":"ch03/p02_pluginentwurf.html#voraussetzungen","text":"Die Basis f\u00fcr QGIS-Plugin bilden die Abfragen auf den Pegelonline-Datenbestand: Stationen Wasserst\u00e4nde Stationsbezogene Pegelverl\u00e4ufe als Diagramm Es sollen folgende Funktionen im Plugin realisiert werden: Laden und Anzeigen des Datenbestands -> Aus den json-Daten von Pegelonline werden QGIS-Layer erzeugt und visualisiert Erg\u00e4nzungen: \"Basiskarte\", Darstellung unterschiedlicher Attribute -> \u00c4nderung der Darstellung f\u00fcr z.B. Wasserst\u00e4nde ... Plugin-GUI: Das GUI wird als Dockwidget realisiert und erlaubt die Steuerung aller Funktionen und Interaktionen Layer: Selektionen von Stationen Integration des \"Custom\"-Widgets Pegelverlauf-Graph m\u00f6gliches GUI des Plugin Mit dem Plugin-Builder wird ein Dockwidget samt Logik erzeugt. Dies stellt eine Variante zum Dialog dar, und ist geeignet, mehrere interaktive Funktionen zu steuern, da ein Dockwidget dauerhaft angezeigt bleibt.","title":"Voraussetzungen"},{"location":"ch03/p02_pluginentwurf.html#module-einrichten","text":"Vorgehensweise: mit dem Plugin-Builder erstellen wir ein neues Plugin \"pegelonline\". in der OSGeo4W-Shell \u00fcbersetzen wir die Datei resources.qrc mit dem Programm pyrcc5 wir f\u00fcgen dem Plugin ein Modul hinzu, um alle unsere Funktionen zu integrieren: po_runner.py mit einer Klasse: class PoRunner PoRunner wird die zentrale Stelle, in der wir unsere Funktionen f\u00fcr das Plugin schreiben. Damit erhalten wir eine besserer \u00dcbersicht \u00fcber unseren eigenen Code und ver\u00e4ndern die vom Plugin-Builder erzeugten Modul nur minimal. Hierzu importieren wir in pegelonline.py : # Our runner-class from .po_runner import PoRunner und erstellen dort innerhalb der run-Methode ein Objekt z.B. als self.runner def run(self): \"\"\"Run method that loads and starts the plugin\"\"\" if not self.pluginIsActive: self.pluginIsActive = True if self.dockwidget == None: # Create the dockwidget self.dockwidget = PegelOnlineDockWidget() # setup runner class self.runner = PoRunner(self.dockwidget, self.iface)","title":"Module einrichten"},{"location":"ch03/p02_pluginentwurf.html#porunner","text":"Mit PoRunner lagern wir alle Funktionen in einem eigenen Modul und in einer Klasse aus. Die Schnittstelle zum Plugin erhalten \u00fcber zwei Objekte: iface und ui (das Dockwidget und seine Widgets): class PoRunner(object): def __init__(self, ui, iface): self.ui = ui self.iface = iface PoRunner wird s\u00e4mtliche Funktionen enthalten, die zum Betrieb des Plugins geschrieben werden m\u00fcssen: Methoden f\u00fcr Signal-Slots Methoden zur Zusammenarbeit mit pomodules from .pomodules.poqgsstations import PoQgsStations from .pomodules.poqgscurrentw import PoQgsCurrentW Falls poqgscurrentw noch nicht existiert, kommentieren wir es zun\u00e4chst aus. Jetzt k\u00f6nnen wir das Plugin testen. Dazu kopieren wir den Ordner in das QGIS-Plugin-Verzeichnis und starten QGIS. Eventuell muss das neue Plugin noch unter dem Men\u00fc Erweiterungen aktiviert werden! Eine erste Version des GUI","title":"PoRunner"},{"location":"ch03/p02_pluginentwurf.html#einbinden-einer-basiskarte","text":"\u00dcber eine Basiskarte soll eine minimale Orientierungshilfe gegeben werden. Sie wird die Fl\u00fcsse/Gew\u00e4sser enthalten, an denen Stationen liegen. Hierzu erstellen wir in unserem Plugin-Ordner eine Unterodner basemap und speichern dort die Daten zur Basiskarte. In diesem Fall ist es ein GeoPackage 'waters.gpkg' mit zwei Layern (waters_l und waters_f). Au\u00dferdem enth\u00e4lt das GeoPackage zwei Styles (water_f_style, water_l_style), die mit beiden Layer verkn\u00fcpft sind und deren Darstellung festlegen. Die Basiskarte des Plugins Die Basiskarte muss optimalerweise beim Laden in QGIS als letztes (oder ganz unten) in der Legende eingef\u00fcgt werden, damit andere Informatione dar\u00fcber gezeichnet werden k\u00f6nnen. Hierzu gibt es ein kleines Rezept aus dem PyQGIS-Cookbook: #... layer wurde erstellt, dann: layerTree = iface.layerTreeCanvasBridge().rootGroup() layerTree.insertChildNode(-1, QgsLayerTreeLayer(vlayer)) Das folgende Beispiel basemap.py zeigt eine lauff\u00e4higen Code f\u00fcr die QGIS-Python-Konsole: import os def show_basemap(): local_dir = r\"c:\\Mein_Plugin_Ordner\\basemap\" water_lines = os.path.join(local_dir, \"waters.gpkg|layername=water_l\") water_areas = os.path.join(local_dir, \"waters.gpkg|layername=water_f\") vlayer = QgsVectorLayer(water_lines, \"Fl\u00fcsse\", \"ogr\") if not vlayer.isValid(): print(\"Layer '%s' not valid\"%water_lines) return QgsProject.instance().addMapLayer(vlayer, False) layerTree = iface.layerTreeCanvasBridge().rootGroup() layerTree.insertChildNode(-1, QgsLayerTreeLayer(vlayer)) vlayer = QgsVectorLayer(water_areas, \"Gew\u00e4sser\", \"ogr\") if not vlayer.isValid(): print(\"Layer '%s' not valid\"%water_areas) return QgsProject.instance().addMapLayer(vlayer, False) layerTree = iface.layerTreeCanvasBridge().rootGroup() layerTree.insertChildNode(-1, QgsLayerTreeLayer(vlayer)) show_basemap() Wir k\u00f6nnen die Grafikvorgaben eines Styles auch \u00e4ndern und im GeoPackage aktualisieren. Style-Eigenschaften mit QGIS speichern wir \u00e4ndern die Grafik des Layers in QGIS dann w\u00e4hlen wir in der QGIS-Legende den Layer aus und rufen das Eigenschaften-Fenster auf (Properties) unter Stil (Style) k\u00f6nnen wir die aktuellen Grafikeinstellungen speichern um den vorhandenen Stil zu aktualisieren, benutzen wir denselben Stilnamen Angabe der Optionen beim Speichern","title":"Einbinden einer Basiskarte"},{"location":"ch03/p02_pluginentwurf.html#layermanagement","text":"Im Plugin wird auf Layer zugegriffen Pegelonlinedaten werden geladen und ein Layer erzeugt Es werden Funktionen auf den Layer angewendet Layer k\u00f6nnen im Plugin referenziert werden, \u00fcber den Namen \u00fcber eine ID (Name+Zufallsstring) \u00fcber ein Layer-Objekt (QgsVectorLayer) Was passiert wenn der Nutzer die abgerufenen Informationen aktualisiert und neue Layer erzeugt? den Layer in QGIS l\u00f6scht? in einem Layer Daten selektiert? Laden Ladevorgang (wie im Script basemap.py ) wir merken uns alle Layer im Plugin als Layer-Objekt (self.stationen = vlayer) Aktualisieren werden die Daten neu geladen, so erstellen wir einen neuen Layer wir verfahren wie beim Laden L\u00f6schen Der Benutzer kann einen Layer l\u00f6schen, dies muss unser Plugin registrieren Die Variable und Referenz zum Layer wird zur\u00fcckgesetzt (self.stationen = None)","title":"Layermanagement"},{"location":"ch03/p02_pluginentwurf.html#beispiel-basemap","text":"Im Plugin als Option (QCheckBox) Option steht auf aus : Kein Layer geladen Benutzer schaltet Option ein: Layer wird geladen Layer wird angezeigt Benutzer schaltet Option wieder aus Layer wird nicht gel\u00f6scht, sondern nur ausgeblendet Alternativ: Layer l\u00f6schen und neu laden ... CheckBox zur Anzeige der Basiskarte Wir richten mit QtDesinger eine CheckBox ein, Name chBshowBasemap eine Methode in PoRunner \u00fcbernimmt die Signal-Slot-Definitionen: init_connects() Wir schreiben einen Slot(Methode) als doBasemapOptionChanged Umsetzung in po_runner: # ver\u00e4nderte init-Methode def __init__(self, ui, iface): self.ui = ui self.iface = iface self.init_connects() self.local_dir = os.path.dirname(os.path.realpath(__file__)) # neue Methode init_connects def init_connects(self): self.ui.chBshowBasemap.toggled.connect(self.doBasemapOptionChanged) # Slot-Methode doBasemapOptionChanged def doBasemapOptionChanged(self): pass Ein Layer kann \u00fcber Python ein- und ausgeschaltet werden, indem auf das Legendenobjekt LayerTreeRoot zugriffen wird. Die enth\u00e4lt Eintr\u00e4ge (items), die mit setItemVisibilityChecked() auf True bzw False gesetzt werden. Ein Beispiel f\u00fcr die QGIS-Python-Konsole: lyr = iface.activeLayer() lt = QgsProject.instance().layerTreeRoot().findLayer(lyr.id()) lt.setItemVisibilityChecked(False) Innerhalb des Plugins pr\u00fcfen wir innerhlb des Slots f\u00fcr die CheckBox, ob ein- oder ausgeschaltet wurde: def doBasemapOptionChanged(self): if self.ui.chBshowBasemap.isChecked() == True: # Layer anzeigen else: # Layer ausblenden","title":"Beispiel \"Basemap\""},{"location":"ch03/p02_pluginentwurf.html#basemap-layer-verwalten","text":"Zur Verwaltung des Layers geh\u00f6rt die Referenz auf das Objekt und das Verhalten des Plugins bei Ver\u00e4nderungen an diesem Layer. Zun\u00e4chst, pr\u00fcfen wir, ob der Layer bereits geladen wurde, andernfall wird der Layer geladen. Das Laden erfolgt wie in basemap.py getestet. Zus\u00e4tzlich merken wir uns das erstellte VectorLayer-Objekt blenden wir nur ein, wenn der Nutzer die Aktion nochmals ausl\u00f6st wurde und der Layer schon erzeugt wurde water_lines = os.path.join(self.local_dir, \"basemap\", \"waters.gpkg|layername=water_l\") # Layer bereits erstellt? if self.base_l is None: vl = QgsVectorLayer(water_lines, \"Fl\u00fcsse\", \"ogr\") if not vl.isValid(): print(\"Layer '%s' not valid\"%water_lines) return QgsProject.instance().addMapLayer(vl, False) layerTree = self.iface.layerTreeCanvasBridge().rootGroup() layerTree.insertChildNode(-1, QgsLayerTreeLayer(vl)) self.base_l = vl # nur einblenden else: lyrtree = QgsProject.instance().layerTreeRoot().findLayer(self.base_l.id()) lyrtree.setItemVisibilityChecked(True) HINWEISE: In po_runner m\u00fcssen die ben\u00f6tigten PyQGI-Klassen aus qgis.core importiert werden dasselbe Vorgehen wie oben w\u00e4hlen wir f\u00fcr den zweiten Layer water_f . Eine weitere Anforderung unseres Plugins betrifft den Vorgang, wenn ein Nutzer einen oder beide Layer in der QGIS-Legende l\u00f6scht. In diesem Fall zeigen die Variablen der QgsVektorLayer auf einen Layer, der nicht mehr existiert und es kann zu Fehlern in unserem Code kommen. Es existiert ein Signal (Event), das ausgel\u00f6st wird, wenn der Layer gel\u00f6scht werden soll: willBeDeleted eine entsprechende Anweisung wird in doBasemapOptionChanged eingef\u00fcgt, dort wo der Layer erstellt wird self.base_l.willBeDeleted.connect(self.doDisconnectBaseL) mit dem zugeh\u00f6rige Slot sollte auch gepr\u00fcft werden, ob andere Objekte von der Aktion betroffen sind, z.B. der CheckBox-Schalter. Minimal sollten wir auf jeden Fall die Layer-Variable zur\u00fccksetzen: def doDisconnectBaseL(self): self.base_l = None","title":"Basemap-Layer verwalten"},{"location":"ch03/p03_pluginrezepte.html","text":"\u00dcbersicht An dieser Stelle sollen verschiedene L\u00f6sungsm\u00f6glichkeiten aufgezeigt werden, die bei der Umsetzung des Plugins pegelonline helfen. Styles f\u00fcr Wasserst\u00e4nde Nach den Attributen der Wasserst\u00e4nde (Beispieldaten: polevel_26_06.gpkg): value trend stateMnwMhw stateNswHsw kann die Darstellung der Stationen variiert werden. Hierbei haben die Attribute folgende Werte Value: Die absoluten Werte der Pegel. Leider sind diese nicht untereinander vergleichbar, sodass wir diese zun\u00e4chst nicht ber\u00fccksichtigen wollen Trend: Werte = (-1, 0, 1, -999), Bedeutung: fallend, konstant, steigend und unbekannt stateMnwMhw: Werte: (low, normal, high, commented, out-dated, unknown), als Abweichung von langfristigen Mittelwerten stateNswHsw: Werte wie stateMnwMhw, hier als Abweichung von absoluten Extremwerten Im Plugin k\u00f6nnen die unterschiedlichen Attribute z.B. \u00fcber RadioButtons realisiert werden: RadioButtons zur Attributauswahl Zur Umsetzung legen wir vorgefertigte Styles an, die wir als qml-Dateien im Plugin-Ordner unter styles speichern. Die Gestaltung erfolgt in QGIS und die Styles k\u00f6nnen, \u00e4hnlich wie es f\u00fcr die Basiskarte gemacht wurde, gespeichert werden. Vorgehensweise Pegelst\u00e4nde laden Layer->Layergestaltung wir w\u00e4hlen Kategorisiert als Darstellungsart Spalte: Trend Klassifizieren: alle Werte weden angezeigt Grafik anpassen unter Layer->Exportieren oder Layer-Eigenschaften-Stil: Als QGIS-Layerstildatei speichern Beispiel der Layergestaltung f\u00fcr das Attribut Trend Test: Layergestaltung zur\u00fccksetzen auf Einzelsymbol Layer->Eigenschaften->Stil->Lade Stil->aus Datei Zur Anzeige des Layers mit Python f\u00fcr das entsprechende Attribut laden wir eine Style-Datei mit der Methode loadNamedStyle . Wir testen dies zun\u00e4chst mit den Beispieldaten in der QGIS-Python-Konsole: import os local_dir = r\"Mein_Plugin_Pfad\\pegelonline\" lyr = iface.activeLayer() lyr.loadNamedStyle(os.path.join(local_dir, \"styles/stateM.qml\")) # im plugin als refreshLayer() vorhanden if iface.mapCanvas().isCachingEnabled(): lyr.triggerRepaint() else: iface.mapCanvas().refresh() Layermanagement f\u00fcr die Wasserst\u00e4nde Ein Verfahren f\u00fcr das Layermanagement haben anhand der Funktionen f\u00fcr die Basiskarte bereits kennengelernt. Die wollen wir nun auf die Behandlung der Stationen mit Wasserstandsdaten anwenden. dies setzt voraus, dass die Pegel geladen werden k\u00f6nnen, testweise hier mit dem Geopackage polevel_25_06.gpkg doLoadCurrentW() als Slot f\u00fcr den PushButton pBloadCurrentW Im QtDesigner erweitern wir das GUI des Plugins, um die folgenden Elemente: PushButton zum Laden aus Geopackage pBloadCurrentW Eine GroupBox mit drei Radio-Buttons f\u00fcr rBstyleTrend f\u00fcr das Attribut trend rBstyleMid f\u00fcr das Attribut stateMnwMhw rBstyleAbs f\u00fcr das Attribut stateNswHsw Funktionsweise der Radio-Buttons RadioButton funktionieren zusammen als Gruppe Ein Klick auf einen RadioButton schaltet den zuletzt aktiven aus Mehrere RadioButtons lassen sich gruppieren Mehrere Gruppierungen erm\u00f6glichen unterschiedliche Funktionen f\u00fcr die jeweiligen RadioButtons In der Objektanzeige des QtDesigners lassen sich mehrere RadioButtons ausw\u00e4hlen Mit der rechten Maustaste w\u00e4hlen wir den Befehl Gruppierung -> neue Gruppierung Wir erhalten ein neues QButtonGroup-Widget, nennen wir es bGStyleCurrentW Auf dieser Basis k\u00f6nnen wir die Events der gruppierten RadioButtons auswerten: Verbinden: bGStyleCurrentW.buttonClicked.connect(self.doCurrentWChangeStyle) Slot: def doCurrentWChangeStyle(self, button): pass Dem Slot wird automatisch der aktive RadioButton \u00fcbergeben, so dass wir die Wahl des Styles aus dem Namen des Button bestimmen k\u00f6nnen: button.objectName() # -> rBstyleTrend,rBstyleAbs,rBstyleMid Integration in po_runner Daten \u00fcber das Plugin laden Zun\u00e4chst laden wir die Daten und erg\u00e4nzen: In __init__() : self.currentw = None In init_connects () : self.ui.pBloadCurrentW.clicked.connect(self.doLoadCurrentW) In doLoadCurrentW() :(zusammen mit allen anderen Anweisungen) currentw = QgsVectorLayer(currentw_path, \"Wasserst\u00e4nde\", \"ogr\") if not currentw.isValid: print(\"Could not load layer %s\"%currentw_path) return self.currentw = currentw QgsProject.instance().addMapLayer(self.currentw) self.layerRefresh(self.currentw) currentw_path ist der Pfad zur Testdatei polevel_25_06.gpkg willBeDeleted nicht vergessen! Sie k\u00f6nnen auch, wenn bereits geschrieben, den Layer \u00fcber pomodules laden und aktuelle Daten verwenden Einen LayerRefresh brauchen wir h\u00e4ufiger, daher als eigene Methode: def layerRefresh(self, lyr): if self.iface.mapCanvas().isCachingEnabled(): lyr.triggerRepaint() else: self.iface.mapCanvas().refresh() Styles umschalten def doCurrentWChangeStyle(self, button): if self.currentw is None: return if button.objectName() == \"rBstyleTrend\": self.currentw.loadNamedStyle(os.path.join(self.local_dir, \"styles/trend.qml\")) elif button.objectName() == \"rBstyleAbs\": pass # und so weiter self.layerRefresh(self.currentw) dies ist bisher nur ein minimaler Code, der noch auf verschiedene Aspekte hin erweitert werden kann: Soll der Layer einen Default-Style bekommen? Kann dies \u00fcber die GroupBox erfolgen (z.B: ersten Button aktivieren) Was passiert beim L\u00f6schen, was soll passieren? Selektionen In QGIS kann ein Benutzer die Features eines VectorLayers selektieren. Sie werden dann in Tabelle und Karte markiert. Dies geschieht entweder interaktiv, mit der Maus, oder durch eine Art SQL-Abfrage. Diese Form der Selektion wollen wir nutzen, um f\u00fcr das Plugin Stationen auszuw\u00e4hlen, die dann weiterverarbeitet werden, zum Beispiel zur Abfrage des Pegelverlaufs als Diagramm. Selektion auf Wassenst\u00e4nde Auf den Layer der Wasserst\u00e4nde sollen Selektionen m\u00f6glich sein. Damit ein Plugin mitbekommt, dass eine Selektion ausgef\u00fchrt wurde, muss der passende Signal/Slot implementiert werden. Signals und Slots f\u00fcr Layer-Objekte finden wir in der QGIS-API-Dokumentation: Signal-Slot f\u00fcr QGIS-Layer Den Signal-Slot f\u00fcr willBeDeleted haben wir bereits kennengelernt, er ist allen QgsMapLayern nutzbar (also z.B. auch f\u00fcr Raster-Layer), w\u00e4hrend selectionChanged nur f\u00fcr QgsVectorLayer existiert. In der QGIS-Python-Konsole k\u00f6nnen wir testhalber einen Signal-Slot einrichten: lyr = iface.activeLayer() lyr.selectionChanged.connect(doSelectionChanged) Dieser ben\u00f6tigt dann die Methode doSelectionChanged() und nach den Tests sollten wir den verbundenen Slot wieder freigeben: Komplettes Script: def doSelectionChanged(selection): print(selection) def layerDisconnectDoSelCh(): lyr.selectionChanged.disconnect(doSelectionChanged) lyr = iface.activeLayer() lyr.selectionChanged.connect(doSelectionChanged) Wir testen mit diesem Script, was dem Slot doSelectionChanged \u00fcbergeben wird. In der QGIS-Python-Konsole sind das die folgenden Schritte: Script erstellen ausf\u00fchren im Layer selektieren -> print(selection) wird ausgef\u00fchrt danach layerDisconnectDoSelCh(lyr) ausf\u00fchren -> Slot wird ausgeschaltet nochmals im Layer Selektion \u00e4ndern -> Slot wird nicht mehr ausgef\u00fchrt Nun wenden wir uns etwas genauer der Frage zu, was der Parameter selection enth\u00e4lt. Die ausgegeben Zahlen deuten darauf hin, dass es sich dabei um id's handelt, die Angaben sind identisch mit den fid's in der Tabelle. Mit einer for-Schleife im Slot doSelectionChanged wollen wir Zugriff auf die entsprechenden Qgis-Features erhalten: def doSelectionChanged(selection): print(selection) for id in selection: feat = lyr.getFeature(id) print(feat['shortname']) for feature in lyr.selectedFeatures(): print(feature.id()) W\u00e4hrend die erste for-Schleife die Elemente in selection durchl\u00e4uft, um die Features abzurufen, nutzt die zweite for-Schleife alternativ die Methode selectedFeatures() eines VectorLayer-Objekts. Somit ist es egal, welche der beiden Varianten wir verwenden. Aufgabe: Integration in po_runner Dieses Konstrukt kann nun in po_runner umgesetzt werden, hierdurch \u00e4ndern sich die Funktionen, da sie als Methode zus\u00e4tzlich die Objektvariable self als Parameter bekommen. Au\u00dfer nutzen wir nicht eine globale Variable, wie lyr oben im Beispiel, sondern self.currentw als Referenz auf den Layer der Pegelst\u00e4nde. Selektionen auf Layer Wasserst\u00e4nde: Einrichten, wenn Layer geladen wird Pr\u00fcfen, ob bereits ein Layer verbunden ist def doLoadCurrentW(self): if self.currentw: pass # disconnect signals/slots currentw = QgsVectorLayer(...) # ... self.currentw = currentw # connect signals/slots # ... Einbetten eines Custom-Wigets in QtDesiger Im Kapitel zu PyQt5 haben wir ein Widget programmiert, dass die Pegelverl\u00e4ufe zu einer Station anzeigt. In dem Modul poGraph steht daf\u00fcr das Widget als Klasse poGraphDisplay zur Verf\u00fcgung. Dieses Widget soll nun in das GUI des Plugin integriert werden. Dazu haben wir zwei M\u00f6glichkeiten: In QtDesigner bauen wir das Widget nachmals nach und \u00fcbernehmen den Code in das po_runner-Modul Im QtDesigner nutzen wir eine Funktion, um ein unbekanntes Widget \u00fcber einen Platzhalter zu integrieren. Letztere M\u00f6glichkeit bietet mehr Flexibilit\u00e4t, da sie auf Modularit\u00e4t setzt und doppelten Aufwand vermeidet. Als Platzhalter setzen wir ein QWidget in das Dockwidget ein: Platzhalter in QtDesigner konfigurieren Zum Aufrufen des Fensters makieren wir das QWidget und w\u00e4hlen \u00fcber das Kontextmen\u00fc (rechte Maustaste) Als Platzhalter f\u00fcr benutzerdefinierte Klasse festlegen . der Platzhalter erh\u00e4lt die Angabe einer include-Datei in unserem Fall das Modul poGraph wir kopieren die Moduldatei poGraph.py in den Plugin-Ordner pegelonline In QtDesigner legen wir fest: Klassenname: PoGraphDisplay include-Datei: pegelonline.poGraph (dies wird eine import-Anweisung) einen eindeutigen Namen f\u00fcr das Platzhalter-Widget: poGraphDisplay Weiter brauchen wir uns um nichts zu k\u00fcmmern. Die gespeicherte ui-Datei enth\u00e4lt alle ben\u00f6tigten Angaben, um das Widget zu aktivieren. Es wird nun in QGIS angezeigt. Integration in po_runner Ziel: Ausgew\u00e4hlte Stationen werden im PoGraph-Widget angezeigt Voraussetzung ist eine Selektion auf den Layer Wasserst\u00e4nde , deren Einrichtung oben beschrieben wurde. Nun wollen wir die Selektionen auswerten: die Namen der Stationen werden ins poGraphDisplay-Widget eingetragen poGraphDisplay hat die Methode setStations() und erwartet eine Liste mit Namen Der Slot: def doCurrentWSelection(self, selection): # for Schleife erzeugt Namensliste stations stations = [] # ins poGraphDisplay-Widget eintragen self.ui.poGraphDisplay.setStations(stations) Bei einem Disconnect oder beim L\u00f6schen des Layers sollte Liste geleert werden: self.ui.poGraphDisplay.setStations([])","title":"Rezepte f\u00fcr Layer und Interaktionen"},{"location":"ch03/p03_pluginrezepte.html#ubersicht","text":"An dieser Stelle sollen verschiedene L\u00f6sungsm\u00f6glichkeiten aufgezeigt werden, die bei der Umsetzung des Plugins pegelonline helfen.","title":"\u00dcbersicht"},{"location":"ch03/p03_pluginrezepte.html#styles-fur-wasserstande","text":"Nach den Attributen der Wasserst\u00e4nde (Beispieldaten: polevel_26_06.gpkg): value trend stateMnwMhw stateNswHsw kann die Darstellung der Stationen variiert werden. Hierbei haben die Attribute folgende Werte Value: Die absoluten Werte der Pegel. Leider sind diese nicht untereinander vergleichbar, sodass wir diese zun\u00e4chst nicht ber\u00fccksichtigen wollen Trend: Werte = (-1, 0, 1, -999), Bedeutung: fallend, konstant, steigend und unbekannt stateMnwMhw: Werte: (low, normal, high, commented, out-dated, unknown), als Abweichung von langfristigen Mittelwerten stateNswHsw: Werte wie stateMnwMhw, hier als Abweichung von absoluten Extremwerten Im Plugin k\u00f6nnen die unterschiedlichen Attribute z.B. \u00fcber RadioButtons realisiert werden: RadioButtons zur Attributauswahl Zur Umsetzung legen wir vorgefertigte Styles an, die wir als qml-Dateien im Plugin-Ordner unter styles speichern. Die Gestaltung erfolgt in QGIS und die Styles k\u00f6nnen, \u00e4hnlich wie es f\u00fcr die Basiskarte gemacht wurde, gespeichert werden.","title":"Styles f\u00fcr Wasserst\u00e4nde"},{"location":"ch03/p03_pluginrezepte.html#vorgehensweise","text":"Pegelst\u00e4nde laden Layer->Layergestaltung wir w\u00e4hlen Kategorisiert als Darstellungsart Spalte: Trend Klassifizieren: alle Werte weden angezeigt Grafik anpassen unter Layer->Exportieren oder Layer-Eigenschaften-Stil: Als QGIS-Layerstildatei speichern Beispiel der Layergestaltung f\u00fcr das Attribut Trend Test: Layergestaltung zur\u00fccksetzen auf Einzelsymbol Layer->Eigenschaften->Stil->Lade Stil->aus Datei Zur Anzeige des Layers mit Python f\u00fcr das entsprechende Attribut laden wir eine Style-Datei mit der Methode loadNamedStyle . Wir testen dies zun\u00e4chst mit den Beispieldaten in der QGIS-Python-Konsole: import os local_dir = r\"Mein_Plugin_Pfad\\pegelonline\" lyr = iface.activeLayer() lyr.loadNamedStyle(os.path.join(local_dir, \"styles/stateM.qml\")) # im plugin als refreshLayer() vorhanden if iface.mapCanvas().isCachingEnabled(): lyr.triggerRepaint() else: iface.mapCanvas().refresh()","title":"Vorgehensweise"},{"location":"ch03/p03_pluginrezepte.html#layermanagement-fur-die-wasserstande","text":"Ein Verfahren f\u00fcr das Layermanagement haben anhand der Funktionen f\u00fcr die Basiskarte bereits kennengelernt. Die wollen wir nun auf die Behandlung der Stationen mit Wasserstandsdaten anwenden. dies setzt voraus, dass die Pegel geladen werden k\u00f6nnen, testweise hier mit dem Geopackage polevel_25_06.gpkg doLoadCurrentW() als Slot f\u00fcr den PushButton pBloadCurrentW Im QtDesigner erweitern wir das GUI des Plugins, um die folgenden Elemente: PushButton zum Laden aus Geopackage pBloadCurrentW Eine GroupBox mit drei Radio-Buttons f\u00fcr rBstyleTrend f\u00fcr das Attribut trend rBstyleMid f\u00fcr das Attribut stateMnwMhw rBstyleAbs f\u00fcr das Attribut stateNswHsw","title":"Layermanagement f\u00fcr die Wasserst\u00e4nde"},{"location":"ch03/p03_pluginrezepte.html#funktionsweise-der-radio-buttons","text":"RadioButton funktionieren zusammen als Gruppe Ein Klick auf einen RadioButton schaltet den zuletzt aktiven aus Mehrere RadioButtons lassen sich gruppieren Mehrere Gruppierungen erm\u00f6glichen unterschiedliche Funktionen f\u00fcr die jeweiligen RadioButtons In der Objektanzeige des QtDesigners lassen sich mehrere RadioButtons ausw\u00e4hlen Mit der rechten Maustaste w\u00e4hlen wir den Befehl Gruppierung -> neue Gruppierung Wir erhalten ein neues QButtonGroup-Widget, nennen wir es bGStyleCurrentW Auf dieser Basis k\u00f6nnen wir die Events der gruppierten RadioButtons auswerten: Verbinden: bGStyleCurrentW.buttonClicked.connect(self.doCurrentWChangeStyle) Slot: def doCurrentWChangeStyle(self, button): pass Dem Slot wird automatisch der aktive RadioButton \u00fcbergeben, so dass wir die Wahl des Styles aus dem Namen des Button bestimmen k\u00f6nnen: button.objectName() # -> rBstyleTrend,rBstyleAbs,rBstyleMid","title":"Funktionsweise der Radio-Buttons"},{"location":"ch03/p03_pluginrezepte.html#integration-in-po_runner","text":"","title":"Integration in po_runner"},{"location":"ch03/p03_pluginrezepte.html#daten-uber-das-plugin-laden","text":"Zun\u00e4chst laden wir die Daten und erg\u00e4nzen: In __init__() : self.currentw = None In init_connects () : self.ui.pBloadCurrentW.clicked.connect(self.doLoadCurrentW) In doLoadCurrentW() :(zusammen mit allen anderen Anweisungen) currentw = QgsVectorLayer(currentw_path, \"Wasserst\u00e4nde\", \"ogr\") if not currentw.isValid: print(\"Could not load layer %s\"%currentw_path) return self.currentw = currentw QgsProject.instance().addMapLayer(self.currentw) self.layerRefresh(self.currentw) currentw_path ist der Pfad zur Testdatei polevel_25_06.gpkg willBeDeleted nicht vergessen! Sie k\u00f6nnen auch, wenn bereits geschrieben, den Layer \u00fcber pomodules laden und aktuelle Daten verwenden Einen LayerRefresh brauchen wir h\u00e4ufiger, daher als eigene Methode: def layerRefresh(self, lyr): if self.iface.mapCanvas().isCachingEnabled(): lyr.triggerRepaint() else: self.iface.mapCanvas().refresh()","title":"Daten \u00fcber das Plugin laden"},{"location":"ch03/p03_pluginrezepte.html#styles-umschalten","text":"def doCurrentWChangeStyle(self, button): if self.currentw is None: return if button.objectName() == \"rBstyleTrend\": self.currentw.loadNamedStyle(os.path.join(self.local_dir, \"styles/trend.qml\")) elif button.objectName() == \"rBstyleAbs\": pass # und so weiter self.layerRefresh(self.currentw) dies ist bisher nur ein minimaler Code, der noch auf verschiedene Aspekte hin erweitert werden kann: Soll der Layer einen Default-Style bekommen? Kann dies \u00fcber die GroupBox erfolgen (z.B: ersten Button aktivieren) Was passiert beim L\u00f6schen, was soll passieren?","title":"Styles umschalten"},{"location":"ch03/p03_pluginrezepte.html#selektionen","text":"In QGIS kann ein Benutzer die Features eines VectorLayers selektieren. Sie werden dann in Tabelle und Karte markiert. Dies geschieht entweder interaktiv, mit der Maus, oder durch eine Art SQL-Abfrage. Diese Form der Selektion wollen wir nutzen, um f\u00fcr das Plugin Stationen auszuw\u00e4hlen, die dann weiterverarbeitet werden, zum Beispiel zur Abfrage des Pegelverlaufs als Diagramm.","title":"Selektionen"},{"location":"ch03/p03_pluginrezepte.html#selektion-auf-wassenstande","text":"Auf den Layer der Wasserst\u00e4nde sollen Selektionen m\u00f6glich sein. Damit ein Plugin mitbekommt, dass eine Selektion ausgef\u00fchrt wurde, muss der passende Signal/Slot implementiert werden. Signals und Slots f\u00fcr Layer-Objekte finden wir in der QGIS-API-Dokumentation: Signal-Slot f\u00fcr QGIS-Layer Den Signal-Slot f\u00fcr willBeDeleted haben wir bereits kennengelernt, er ist allen QgsMapLayern nutzbar (also z.B. auch f\u00fcr Raster-Layer), w\u00e4hrend selectionChanged nur f\u00fcr QgsVectorLayer existiert. In der QGIS-Python-Konsole k\u00f6nnen wir testhalber einen Signal-Slot einrichten: lyr = iface.activeLayer() lyr.selectionChanged.connect(doSelectionChanged) Dieser ben\u00f6tigt dann die Methode doSelectionChanged() und nach den Tests sollten wir den verbundenen Slot wieder freigeben: Komplettes Script: def doSelectionChanged(selection): print(selection) def layerDisconnectDoSelCh(): lyr.selectionChanged.disconnect(doSelectionChanged) lyr = iface.activeLayer() lyr.selectionChanged.connect(doSelectionChanged) Wir testen mit diesem Script, was dem Slot doSelectionChanged \u00fcbergeben wird. In der QGIS-Python-Konsole sind das die folgenden Schritte: Script erstellen ausf\u00fchren im Layer selektieren -> print(selection) wird ausgef\u00fchrt danach layerDisconnectDoSelCh(lyr) ausf\u00fchren -> Slot wird ausgeschaltet nochmals im Layer Selektion \u00e4ndern -> Slot wird nicht mehr ausgef\u00fchrt Nun wenden wir uns etwas genauer der Frage zu, was der Parameter selection enth\u00e4lt. Die ausgegeben Zahlen deuten darauf hin, dass es sich dabei um id's handelt, die Angaben sind identisch mit den fid's in der Tabelle. Mit einer for-Schleife im Slot doSelectionChanged wollen wir Zugriff auf die entsprechenden Qgis-Features erhalten: def doSelectionChanged(selection): print(selection) for id in selection: feat = lyr.getFeature(id) print(feat['shortname']) for feature in lyr.selectedFeatures(): print(feature.id()) W\u00e4hrend die erste for-Schleife die Elemente in selection durchl\u00e4uft, um die Features abzurufen, nutzt die zweite for-Schleife alternativ die Methode selectedFeatures() eines VectorLayer-Objekts. Somit ist es egal, welche der beiden Varianten wir verwenden.","title":"Selektion auf Wassenst\u00e4nde"},{"location":"ch03/p03_pluginrezepte.html#aufgabe-integration-in-po_runner","text":"Dieses Konstrukt kann nun in po_runner umgesetzt werden, hierdurch \u00e4ndern sich die Funktionen, da sie als Methode zus\u00e4tzlich die Objektvariable self als Parameter bekommen. Au\u00dfer nutzen wir nicht eine globale Variable, wie lyr oben im Beispiel, sondern self.currentw als Referenz auf den Layer der Pegelst\u00e4nde. Selektionen auf Layer Wasserst\u00e4nde: Einrichten, wenn Layer geladen wird Pr\u00fcfen, ob bereits ein Layer verbunden ist def doLoadCurrentW(self): if self.currentw: pass # disconnect signals/slots currentw = QgsVectorLayer(...) # ... self.currentw = currentw # connect signals/slots # ...","title":"Aufgabe: Integration in po_runner"},{"location":"ch03/p03_pluginrezepte.html#einbetten-eines-custom-wigets-in-qtdesiger","text":"Im Kapitel zu PyQt5 haben wir ein Widget programmiert, dass die Pegelverl\u00e4ufe zu einer Station anzeigt. In dem Modul poGraph steht daf\u00fcr das Widget als Klasse poGraphDisplay zur Verf\u00fcgung. Dieses Widget soll nun in das GUI des Plugin integriert werden. Dazu haben wir zwei M\u00f6glichkeiten: In QtDesigner bauen wir das Widget nachmals nach und \u00fcbernehmen den Code in das po_runner-Modul Im QtDesigner nutzen wir eine Funktion, um ein unbekanntes Widget \u00fcber einen Platzhalter zu integrieren. Letztere M\u00f6glichkeit bietet mehr Flexibilit\u00e4t, da sie auf Modularit\u00e4t setzt und doppelten Aufwand vermeidet. Als Platzhalter setzen wir ein QWidget in das Dockwidget ein: Platzhalter in QtDesigner konfigurieren Zum Aufrufen des Fensters makieren wir das QWidget und w\u00e4hlen \u00fcber das Kontextmen\u00fc (rechte Maustaste) Als Platzhalter f\u00fcr benutzerdefinierte Klasse festlegen . der Platzhalter erh\u00e4lt die Angabe einer include-Datei in unserem Fall das Modul poGraph wir kopieren die Moduldatei poGraph.py in den Plugin-Ordner pegelonline In QtDesigner legen wir fest: Klassenname: PoGraphDisplay include-Datei: pegelonline.poGraph (dies wird eine import-Anweisung) einen eindeutigen Namen f\u00fcr das Platzhalter-Widget: poGraphDisplay Weiter brauchen wir uns um nichts zu k\u00fcmmern. Die gespeicherte ui-Datei enth\u00e4lt alle ben\u00f6tigten Angaben, um das Widget zu aktivieren. Es wird nun in QGIS angezeigt.","title":"Einbetten eines Custom-Wigets in QtDesiger"},{"location":"ch03/p03_pluginrezepte.html#integration-in-po_runner_1","text":"Ziel: Ausgew\u00e4hlte Stationen werden im PoGraph-Widget angezeigt Voraussetzung ist eine Selektion auf den Layer Wasserst\u00e4nde , deren Einrichtung oben beschrieben wurde. Nun wollen wir die Selektionen auswerten: die Namen der Stationen werden ins poGraphDisplay-Widget eingetragen poGraphDisplay hat die Methode setStations() und erwartet eine Liste mit Namen Der Slot: def doCurrentWSelection(self, selection): # for Schleife erzeugt Namensliste stations stations = [] # ins poGraphDisplay-Widget eintragen self.ui.poGraphDisplay.setStations(stations) Bei einem Disconnect oder beim L\u00f6schen des Layers sollte Liste geleert werden: self.ui.poGraphDisplay.setStations([])","title":"Integration in po_runner"},{"location":"ch03/p04_abschluss.html","text":"Abschlussaufgabe Abgabe eines QGIS-Plugins zum Zugriff und Darstellung der Daten von Pegelonline. Ansicht des Plugins Pegelonline Kritierien zur Beurteilung des Codes Allgemeine Kriterien Bennenung von Klassen, Methoden und Variablen Bedeutung durch Namen erkennbar Syntaktisch eindeutig: Z.B. in Python (Pep8) geregelt, wichtig: konsistente Verwendung und Unterscheidung von Klassen, Methoden etc. Konsistenz in der Namensgebung Aufbau von Funktionen, Methoden Vermeidung von doppelt vorkommendem Code Code von Funktionen erf\u00fcllen eine definierte Aufgabe, sie rufen einander auf, um komplexere Aufgaben zu erf\u00fcllen Code-Bl\u00f6cke (Funktionen) sind allgemein nicht l\u00e4nger als 20 Zeilen, in einigen F\u00e4llen unter 50 Zeilen, selten l\u00e4nger als 100 Zeilen Layout von Programmen (Lesbarkeit) -> Pep8! Konsistenter Aufbau eines Modules, einer Klasse durch sinnvolle Gruppierung von Elementen Importe stehen am Beginn, allgemeine Funktionen, Klassen-Definitionen folgen Vermeidung von langen Zeilen, Einr\u00fcckungen bestehen immer aus Gruppen von 4 Leerzeichen Kommantare der Code ist ausreichend kommentiert aber nicht mit Kommentaren \u00fcberladen Funktionen verwenden einen doc string Code-Bl\u00f6cke werden mit einer Kommentarzeile eingeleitet komplexe if-Konstrukte werden erl\u00e4utert wichtige Variablen werden bei der Deklaration erl\u00e4utert TODO-Kommentare oder Auskommentierungen von nicht benutztem Code sollen entfernt werden, Ausnahmen sind denkbar f\u00fcr Dokumentation/Reflektion Fehlerbehandlung externe Module/Funktionen sollten gepr\u00fcft werden, ob und welche Fehler sie abfangen. Diese Fehlerbehadlung sollte \u00fcbernommen werden. IO-Operationen oder der Zugriff auf fremde Daten erfordern grunds\u00e4tzlich Fehlerbehandlungen Reaktionen auf Fehler m\u00fcssen geplant ablaufen, im schlimmsten Fall mit dem Abbruch einer Operation/des Programms (in Plugins kann nat\u00fcrlich nicht das umgebende Programm beendet werden...) Tests Das Plugin soll auf denkbare Fehler hin getestet werden Insbesondere die Logik der Benutzeroberfl\u00e4che ist anspruchsvoll und bietet h\u00e4ufig unvorhergesehene Bedienschritte, die zu Inkonsistenzen f\u00fchren k\u00f6nnen Wir verzichten auf explizite Test-Routinen, etwa dem Unit-Testing, diese w\u00e4ren aber sinnvoll. Bei der Erstellung eines Plugins mit dem Plugin-Builder existiert eine Option zur Einrichtung solcher Tests. Spezifische Anforderungen Dokumentation umfasst eine kurze Beschreibung des Plugins, inkl. aller aus Nutzersicht relevanter Funktionen (GUI, Anleitung) enth\u00e4lt eine technische Beschreibung zum Aufbau des Codes und der verwendeten Komponenten, kann als Begr\u00fcndung der Implementierung verfasst sein reflektieren sie ihre Arbeit, weisen sie auf Besondernheiten hin (positive wie negative) Lauff\u00e4higkeit als QGIS-Plugin eingebunden, startet und l\u00e4uft der Code fehlerfrei auch ungeplante Bedienung ist m\u00f6glich Vollst\u00e4ndigkeit die in der Veranstaltung besprochenen und in der GUI vorgesehenen Funktionen sind implementiert Zugriff auf Pegelonline und Datenaufbereitung f\u00fcr QGIS Darstellung der Daten durch unterschiedliche Attribute Umsetzung interaktiver Funktionen in der GUI der abgegebene Code enth\u00e4lt alle notwendigen Komponenten, die nicht durch Python oder QGIS (wie auf dem Stick) gegeben sind Niveau und Kompetenz Aufbau des Plugins ist objektorientiert, eigene Module besitzen eine nachvollziehbare und sinnvolle Klassenstruktur Funktionen f\u00fcr den Internetzugriff, f\u00fcr GIS und Kartographie werden souver\u00e4n eingesetzt, kommentiert und dokumentiert Es ist gew\u00fcnscht (Bonus), dass die Entwicklung des Plugins zumindest in einzelnen Bereichen \u00fcber die in der Lehrveranstaltung gezeigten Grundlagen hinausgeht. Verbesserte objektorientierte Struktur \u00c4nderungen im Zugriff auf Pegelonline (z.B. weitere Attribute) Erweiterung der einstellbaren Darstellungen Neue interaktive Funktionen in der GUI Abschlie\u00dfende Rezepte Einsatz von interaktiven QGIS-Funktionen Viele interaktive Funktionen sind in QGIS als Qt-Actions implementiert. Dazu geh\u00f6ren s\u00e4mliche Funktionen aus Men\u00fcs und den Funktionsleisten (Werkzeugk\u00e4sten). QAction hei\u00dft die \u00fcbergeordnete Klasse dieser Elemente, sie \u00fcber Python erstellt (siehe Plugin) und aufgerufen werden. Einige dieser Funktionen wurden dem iface-Objekt direkt mitgegeben, andere sind, ebenfalls \u00fcber iface, in den zugeordneten Werkzeugk\u00e4sten zu finden: # iface direkt zugeordnet self.iface.actionZoomFullExtent() self.iface.actionZoomToSelected() self.iface.actionSelectRectangle() # iface \u00fcber Werkzeugkasten, hier \"Attributwerkzeugleiste\" # self.iface.attributesToolBar().actions() for a in self.iface.attributesToolBar().actions(): if a.objectName() == 'mActionDeselectAll': break Zum Einbau in das Plugin bietet es sich an, diese Funktionen in einem Fensterbereich des Dockwidgets zu platzieren. Im QtDesigner legen wir diesen Bereich an und f\u00fcllen ihn im Plugin mit den entsprechenden QActions. Aufbau in Qt-Designer und Darstellung in QGIS Hier wurde im Dockwidget ein horizontales Layout mit einem Spacer erstellt, der daf\u00fcr sorgen soll, dass die Icons linksb\u00fcndig eingesetzt werden. In QGIS wurden die Werkzuge actionSelectRectangle, mActionDeselectAll, actionZoomToSelected, actionZoomFullExtent eingebaut: self.tBzoomAll = QToolButton() self.tBzoomAll.setDefaultAction(self.iface.actionZoomFullExtent()) self.ui.hlTools.insertWidget(0, self.tBzoomAll) Actions sind selber keine Widgets, sondern sie finden ihren Platz in Men\u00fc oder Buttons. Daher wurde hier zun\u00e4chst ein QToolButton erstellt und diesem die Action zugewiesen. Anschlie\u00dfend wurde der Button in das hlTools-Layout eingesetzt. Eine Linie zur optischen Trenung von Funktionen l\u00e4sst sich auch einsetzen: self.vLine = QFrame() self.vLine.setFrameShape(QFrame.VLine) self.vLine.setFrameShadow(QFrame.Sunken) self.ui.hlTools.insertWidget(0, self.vLine) Kartenschrift (Labeling) ein- und ausschalten F\u00fcr die Darstellung der Wasserst\u00e4nde kann z.B. zus\u00e4tzlich eine Beschriftung \u00fcber das Attribut value erfolgen, die sich \u00fcber das Plugin ein- und ausschalten l\u00e4sst. Zun\u00e4chst wurden in den QGIS-Layerstildateien zu den Attributen (qml-Dateien) jeweils eine einheitliche Beschriftung hinzugef\u00fcgt. Die Einstellungen finden wir in dem Layergestaltungsfenster unter \"Beschriftungen\": Attribut: value Text: Wahl einer gut lesbaren Schriftart, hier Calibri Light in Blau Puffer: eingeschaltet, 1mm in Wei\u00df Platzierung: Abstand vom Punkt, im Qudrant Mitte-Oben, mit einem Versatz in Y-Richtung von 1mm Parameter f\u00fcr die Beschriftung Zur Umschaltung wurde in Qt-Designer eine QCheckBox eingef\u00fcgt (chBshowLabels) und im Code mit der Methode des Layers self.currentw.setLabelsEnabled() if self.ui.chBshowLabels.isChecked(): self.currentw.setLabelsEnabled(True) else: self.currentw.setLabelsEnabled(False) \u00dcber das if-Statement wird in der Methode doCurrentWChangeStyle gepr\u00fcft, ob die Labels angezeigt werden sollen. Allerdings soll die Checkbox nicht nur beim Wechsel des Attributs ber\u00fccksichtigung find, sondern auch f\u00fcr einen bereits angezeiten Stil ein- und ausschaltbar sein. Das ist fast schon ein eigenes Rezept: F\u00fcr diese Funktionalit\u00e4t bietet es sich an, die Methode doCurrentWChangeStyle auch auszuf\u00fchren, wenn der Benutzer die Schrift ein- oder ausschaltet. Dazu ist ein kleiner Trick notwendig, denn diese Funktion bekommt ja den eingeschalteten Button aus der ButtonGroup bGStyleCurrentW \u00fcbergeben: # connect f\u00fcr chBshowLabels self.ui.chBshowLabels.toggled.connect(self.doShowLabels) def doShowLabels(self): self.ui.bGStyleCurrentW.buttonClicked.emit( self.ui.bGStyleCurrentW.checkedButton() ) Mit emit() wird der Slot buttonClicked der ButtonGroup ausgef\u00fchrt, dabei wird genauso verfahren, als h\u00e4tte der Benutzer das Siganl mit einem Klick ausgel\u00f6st. Mit checkedButton() k\u00f6nnen wir zus\u00e4tzlich den f\u00fcr den Slot ben\u00f6tigten Button \u00fcbergeben. GUI-Elemente aktivieren und deaktivieren In manchen Situationen ist es erforderlich, einzelne Funktionen im GUI abzuschalten, weil sie nur in einem bestimmten Kontext benutzt werden sollen. So ist es z.B. nicht vorgesehen, den Stil f\u00fcr die Wasserst\u00e4nde zu w\u00e4hlen, wenn diese noch nicht geladen sind. Alle Widgets in Qt besitzen daher die Eigenschaft enabled , die auf True oder False gesetzt werden kann. Ist enabled == False , kann das Element vom Benutzer nicht verwendet werden. Hier ein Beispiel f\u00fcr die Buttons zur Stil-Auswahl: # in init_connects for b in self.ui.bGStyleCurrentW.buttons(): b.setEnabled(False) # f\u00fcr Labelling: self.ui.chBshowLabels.setEnabled(False) Wird der Layer geladen, schalten wir diese wieder frei: setEnabled(True) HTML-Kartenhinweise Wird der Mauszeiger im Kartenfenster \u00fcber Objekte bewegt, so kann QGIS in einem Fenster Objektinformationen \u00fcber HTML einblenden. Unter den Layereigenschaften finden wir den Punkt Anzeigen . So l\u00e4sst sich bspw. f\u00fcr die Stationen folgende Information zusammenstellen: <p>[% \"shortname\" %]</p> <ul> <li>Beh\u00f6rde: [% \"agency\" %]</li> <li>Gew\u00e4sser: [% \"water\" %]</li> </ul> Mit dem Tool \"Kartenhinweise anzeigen\" l\u00e4sst sich die Funktion ein- und ausschalten. Um dies im Plugin zu nutzen, k\u00f6nnen wir f\u00fcr die Anzeige der Stationen eine Layerstildatei verwenden, bei der in den QGIS-Layereinstellunen unter Anzeigen der HTML-Kartenhinweis eingetragen ist. Wird der Layer geladen, weisen wir die qml-Datei zu und aktivieren die QGIS-Action iface.actionMapTips(). Speichern sollten wir die Layerdatei im im Unterverzeichnis des Plugins styles z.B. als stations.qml . # we have a style self.stations.loadNamedStyle(os.path.join(self.local_dir, \"styles/stations.qml\")) self.layerRefresh(self.stations) # turn map tips on self.iface.actionMapTips().setChecked(True)","title":"Abschluss"},{"location":"ch03/p04_abschluss.html#abschlussaufgabe","text":"Abgabe eines QGIS-Plugins zum Zugriff und Darstellung der Daten von Pegelonline. Ansicht des Plugins Pegelonline","title":"Abschlussaufgabe"},{"location":"ch03/p04_abschluss.html#kritierien-zur-beurteilung-des-codes","text":"","title":"Kritierien zur Beurteilung des Codes"},{"location":"ch03/p04_abschluss.html#allgemeine-kriterien","text":"Bennenung von Klassen, Methoden und Variablen Bedeutung durch Namen erkennbar Syntaktisch eindeutig: Z.B. in Python (Pep8) geregelt, wichtig: konsistente Verwendung und Unterscheidung von Klassen, Methoden etc. Konsistenz in der Namensgebung Aufbau von Funktionen, Methoden Vermeidung von doppelt vorkommendem Code Code von Funktionen erf\u00fcllen eine definierte Aufgabe, sie rufen einander auf, um komplexere Aufgaben zu erf\u00fcllen Code-Bl\u00f6cke (Funktionen) sind allgemein nicht l\u00e4nger als 20 Zeilen, in einigen F\u00e4llen unter 50 Zeilen, selten l\u00e4nger als 100 Zeilen Layout von Programmen (Lesbarkeit) -> Pep8! Konsistenter Aufbau eines Modules, einer Klasse durch sinnvolle Gruppierung von Elementen Importe stehen am Beginn, allgemeine Funktionen, Klassen-Definitionen folgen Vermeidung von langen Zeilen, Einr\u00fcckungen bestehen immer aus Gruppen von 4 Leerzeichen Kommantare der Code ist ausreichend kommentiert aber nicht mit Kommentaren \u00fcberladen Funktionen verwenden einen doc string Code-Bl\u00f6cke werden mit einer Kommentarzeile eingeleitet komplexe if-Konstrukte werden erl\u00e4utert wichtige Variablen werden bei der Deklaration erl\u00e4utert TODO-Kommentare oder Auskommentierungen von nicht benutztem Code sollen entfernt werden, Ausnahmen sind denkbar f\u00fcr Dokumentation/Reflektion Fehlerbehandlung externe Module/Funktionen sollten gepr\u00fcft werden, ob und welche Fehler sie abfangen. Diese Fehlerbehadlung sollte \u00fcbernommen werden. IO-Operationen oder der Zugriff auf fremde Daten erfordern grunds\u00e4tzlich Fehlerbehandlungen Reaktionen auf Fehler m\u00fcssen geplant ablaufen, im schlimmsten Fall mit dem Abbruch einer Operation/des Programms (in Plugins kann nat\u00fcrlich nicht das umgebende Programm beendet werden...) Tests Das Plugin soll auf denkbare Fehler hin getestet werden Insbesondere die Logik der Benutzeroberfl\u00e4che ist anspruchsvoll und bietet h\u00e4ufig unvorhergesehene Bedienschritte, die zu Inkonsistenzen f\u00fchren k\u00f6nnen Wir verzichten auf explizite Test-Routinen, etwa dem Unit-Testing, diese w\u00e4ren aber sinnvoll. Bei der Erstellung eines Plugins mit dem Plugin-Builder existiert eine Option zur Einrichtung solcher Tests.","title":"Allgemeine Kriterien"},{"location":"ch03/p04_abschluss.html#spezifische-anforderungen","text":"Dokumentation umfasst eine kurze Beschreibung des Plugins, inkl. aller aus Nutzersicht relevanter Funktionen (GUI, Anleitung) enth\u00e4lt eine technische Beschreibung zum Aufbau des Codes und der verwendeten Komponenten, kann als Begr\u00fcndung der Implementierung verfasst sein reflektieren sie ihre Arbeit, weisen sie auf Besondernheiten hin (positive wie negative) Lauff\u00e4higkeit als QGIS-Plugin eingebunden, startet und l\u00e4uft der Code fehlerfrei auch ungeplante Bedienung ist m\u00f6glich Vollst\u00e4ndigkeit die in der Veranstaltung besprochenen und in der GUI vorgesehenen Funktionen sind implementiert Zugriff auf Pegelonline und Datenaufbereitung f\u00fcr QGIS Darstellung der Daten durch unterschiedliche Attribute Umsetzung interaktiver Funktionen in der GUI der abgegebene Code enth\u00e4lt alle notwendigen Komponenten, die nicht durch Python oder QGIS (wie auf dem Stick) gegeben sind Niveau und Kompetenz Aufbau des Plugins ist objektorientiert, eigene Module besitzen eine nachvollziehbare und sinnvolle Klassenstruktur Funktionen f\u00fcr den Internetzugriff, f\u00fcr GIS und Kartographie werden souver\u00e4n eingesetzt, kommentiert und dokumentiert Es ist gew\u00fcnscht (Bonus), dass die Entwicklung des Plugins zumindest in einzelnen Bereichen \u00fcber die in der Lehrveranstaltung gezeigten Grundlagen hinausgeht. Verbesserte objektorientierte Struktur \u00c4nderungen im Zugriff auf Pegelonline (z.B. weitere Attribute) Erweiterung der einstellbaren Darstellungen Neue interaktive Funktionen in der GUI","title":"Spezifische Anforderungen"},{"location":"ch03/p04_abschluss.html#abschlieende-rezepte","text":"","title":"Abschlie\u00dfende Rezepte"},{"location":"ch03/p04_abschluss.html#einsatz-von-interaktiven-qgis-funktionen","text":"Viele interaktive Funktionen sind in QGIS als Qt-Actions implementiert. Dazu geh\u00f6ren s\u00e4mliche Funktionen aus Men\u00fcs und den Funktionsleisten (Werkzeugk\u00e4sten). QAction hei\u00dft die \u00fcbergeordnete Klasse dieser Elemente, sie \u00fcber Python erstellt (siehe Plugin) und aufgerufen werden. Einige dieser Funktionen wurden dem iface-Objekt direkt mitgegeben, andere sind, ebenfalls \u00fcber iface, in den zugeordneten Werkzeugk\u00e4sten zu finden: # iface direkt zugeordnet self.iface.actionZoomFullExtent() self.iface.actionZoomToSelected() self.iface.actionSelectRectangle() # iface \u00fcber Werkzeugkasten, hier \"Attributwerkzeugleiste\" # self.iface.attributesToolBar().actions() for a in self.iface.attributesToolBar().actions(): if a.objectName() == 'mActionDeselectAll': break Zum Einbau in das Plugin bietet es sich an, diese Funktionen in einem Fensterbereich des Dockwidgets zu platzieren. Im QtDesigner legen wir diesen Bereich an und f\u00fcllen ihn im Plugin mit den entsprechenden QActions. Aufbau in Qt-Designer und Darstellung in QGIS Hier wurde im Dockwidget ein horizontales Layout mit einem Spacer erstellt, der daf\u00fcr sorgen soll, dass die Icons linksb\u00fcndig eingesetzt werden. In QGIS wurden die Werkzuge actionSelectRectangle, mActionDeselectAll, actionZoomToSelected, actionZoomFullExtent eingebaut: self.tBzoomAll = QToolButton() self.tBzoomAll.setDefaultAction(self.iface.actionZoomFullExtent()) self.ui.hlTools.insertWidget(0, self.tBzoomAll) Actions sind selber keine Widgets, sondern sie finden ihren Platz in Men\u00fc oder Buttons. Daher wurde hier zun\u00e4chst ein QToolButton erstellt und diesem die Action zugewiesen. Anschlie\u00dfend wurde der Button in das hlTools-Layout eingesetzt. Eine Linie zur optischen Trenung von Funktionen l\u00e4sst sich auch einsetzen: self.vLine = QFrame() self.vLine.setFrameShape(QFrame.VLine) self.vLine.setFrameShadow(QFrame.Sunken) self.ui.hlTools.insertWidget(0, self.vLine)","title":"Einsatz von interaktiven QGIS-Funktionen"},{"location":"ch03/p04_abschluss.html#kartenschrift-labeling-ein-und-ausschalten","text":"F\u00fcr die Darstellung der Wasserst\u00e4nde kann z.B. zus\u00e4tzlich eine Beschriftung \u00fcber das Attribut value erfolgen, die sich \u00fcber das Plugin ein- und ausschalten l\u00e4sst. Zun\u00e4chst wurden in den QGIS-Layerstildateien zu den Attributen (qml-Dateien) jeweils eine einheitliche Beschriftung hinzugef\u00fcgt. Die Einstellungen finden wir in dem Layergestaltungsfenster unter \"Beschriftungen\": Attribut: value Text: Wahl einer gut lesbaren Schriftart, hier Calibri Light in Blau Puffer: eingeschaltet, 1mm in Wei\u00df Platzierung: Abstand vom Punkt, im Qudrant Mitte-Oben, mit einem Versatz in Y-Richtung von 1mm Parameter f\u00fcr die Beschriftung Zur Umschaltung wurde in Qt-Designer eine QCheckBox eingef\u00fcgt (chBshowLabels) und im Code mit der Methode des Layers self.currentw.setLabelsEnabled() if self.ui.chBshowLabels.isChecked(): self.currentw.setLabelsEnabled(True) else: self.currentw.setLabelsEnabled(False) \u00dcber das if-Statement wird in der Methode doCurrentWChangeStyle gepr\u00fcft, ob die Labels angezeigt werden sollen. Allerdings soll die Checkbox nicht nur beim Wechsel des Attributs ber\u00fccksichtigung find, sondern auch f\u00fcr einen bereits angezeiten Stil ein- und ausschaltbar sein. Das ist fast schon ein eigenes Rezept: F\u00fcr diese Funktionalit\u00e4t bietet es sich an, die Methode doCurrentWChangeStyle auch auszuf\u00fchren, wenn der Benutzer die Schrift ein- oder ausschaltet. Dazu ist ein kleiner Trick notwendig, denn diese Funktion bekommt ja den eingeschalteten Button aus der ButtonGroup bGStyleCurrentW \u00fcbergeben: # connect f\u00fcr chBshowLabels self.ui.chBshowLabels.toggled.connect(self.doShowLabels) def doShowLabels(self): self.ui.bGStyleCurrentW.buttonClicked.emit( self.ui.bGStyleCurrentW.checkedButton() ) Mit emit() wird der Slot buttonClicked der ButtonGroup ausgef\u00fchrt, dabei wird genauso verfahren, als h\u00e4tte der Benutzer das Siganl mit einem Klick ausgel\u00f6st. Mit checkedButton() k\u00f6nnen wir zus\u00e4tzlich den f\u00fcr den Slot ben\u00f6tigten Button \u00fcbergeben.","title":"Kartenschrift (Labeling) ein- und ausschalten"},{"location":"ch03/p04_abschluss.html#gui-elemente-aktivieren-und-deaktivieren","text":"In manchen Situationen ist es erforderlich, einzelne Funktionen im GUI abzuschalten, weil sie nur in einem bestimmten Kontext benutzt werden sollen. So ist es z.B. nicht vorgesehen, den Stil f\u00fcr die Wasserst\u00e4nde zu w\u00e4hlen, wenn diese noch nicht geladen sind. Alle Widgets in Qt besitzen daher die Eigenschaft enabled , die auf True oder False gesetzt werden kann. Ist enabled == False , kann das Element vom Benutzer nicht verwendet werden. Hier ein Beispiel f\u00fcr die Buttons zur Stil-Auswahl: # in init_connects for b in self.ui.bGStyleCurrentW.buttons(): b.setEnabled(False) # f\u00fcr Labelling: self.ui.chBshowLabels.setEnabled(False) Wird der Layer geladen, schalten wir diese wieder frei: setEnabled(True)","title":"GUI-Elemente aktivieren und deaktivieren"},{"location":"ch03/p04_abschluss.html#html-kartenhinweise","text":"Wird der Mauszeiger im Kartenfenster \u00fcber Objekte bewegt, so kann QGIS in einem Fenster Objektinformationen \u00fcber HTML einblenden. Unter den Layereigenschaften finden wir den Punkt Anzeigen . So l\u00e4sst sich bspw. f\u00fcr die Stationen folgende Information zusammenstellen: <p>[% \"shortname\" %]</p> <ul> <li>Beh\u00f6rde: [% \"agency\" %]</li> <li>Gew\u00e4sser: [% \"water\" %]</li> </ul> Mit dem Tool \"Kartenhinweise anzeigen\" l\u00e4sst sich die Funktion ein- und ausschalten. Um dies im Plugin zu nutzen, k\u00f6nnen wir f\u00fcr die Anzeige der Stationen eine Layerstildatei verwenden, bei der in den QGIS-Layereinstellunen unter Anzeigen der HTML-Kartenhinweis eingetragen ist. Wird der Layer geladen, weisen wir die qml-Datei zu und aktivieren die QGIS-Action iface.actionMapTips(). Speichern sollten wir die Layerdatei im im Unterverzeichnis des Plugins styles z.B. als stations.qml . # we have a style self.stations.loadNamedStyle(os.path.join(self.local_dir, \"styles/stations.qml\")) self.layerRefresh(self.stations) # turn map tips on self.iface.actionMapTips().setChecked(True)","title":"HTML-Kartenhinweise"},{"location":"ch03/pgol_entwurf.html","text":"Entwurf der Pegel-Online Schnittstelle Anforderungen In einem QGIS-Plugin soll der Zugriff auf die Daten von Pegel-Online erm\u00f6glicht werden. Hierbei sollen die Liste der Stationen abgerufen und als Layer in QGIS dargestellt werden. die aktuellen Wasserst\u00e4nde f\u00fcr alle Stationen abgerufen werden, der Trend (Angabe zum Pegelstand auf Pegel-Online) soll dabei in der Karte dargestellt werden. F\u00fcr jeweils eine Station soll der Pegelverlauf abgerufen werden, Pegel-Online stellt daf\u00fcr die Datenwerte sowie ein PNG-Bild zur Verf\u00fcgung. Beide M\u00f6glichkeiten sollen realisiert werden. Um die Daten von Pegel-Online verwalten zu k\u00f6nnen, sollen die Liste der Stationen und die aktuellen Wasserst\u00e4nde aller Stationen in einer SQLite-Datenbank gespeichert werden (zwei Tabellen). Die PNG-Grafiken des Pegelverlaufs werden sp\u00e4ter in die Oberfl\u00e4che eingef\u00fcgt, die Daten werden nicht dauerhaft gespeichert, sondern nur als Datenstruktur in einer Variablen (oder Eigenschaft) zur Verf\u00fcgung gestellt. Die Daten zum Pegelverlauf sollen als CSV-Tabelle gespeichert werden k\u00f6nnen. Abfragen an Pegel-Online So sehen die unterschiedlichen Abfragen und zugeh\u00f6rigen Attribute der einzelnen Abfragen aus: Basis-URL: http://www.pegelonline.wsv.de/webservices/rest-api/v2 Stationen mit includeTimeseries und den zur\u00fcckgegebene dictionaries: includeTimeseries listet alle Zeitreihen auf, die an der Station erhoben werden \"/stations.json?includeTimeseries=true\" \"uuid\", \"number\", \"shortname\", \"longname\", \"km\", \"agency\", \"longitude\", \"latitude\", \"water\", \"timeseries\" mit water: \"shortname\", \"longname\" mit timeseries: \"shortname\", \"longname\", \"unit\", \"equidistance\", \"gaugeZero\" mit gaugeZero: \"unit\", \"value\", \"validFrom\" Abruf Stationen mit Current Measurements CurrentMeasurements sind hier auf die Pegelst\u00e4nde beschr\u00e4nkt: timeseries=W dies erfordert au\u00dferdem den Parameter includeTimeseries=True \"/stations.json?timeseries=W&includeTimeseries=true&includeCurrentMeasurement=true\" \"timestamp\", \"value\", \"trend\", \"stateMnwMhw\", \"stateNswHsw\" Abruf (Diese Abfrage liefert ein recht komplexes Ergebnis: wir ben\u00f6tigen lediglich die uuid zur Identifikation der Station und die Angaben zu currentMeasurements) Einzelne Station mit einer gemessenen Zeitreihe der Pegelst\u00e4nde: shortname ist der Name der Station W bezeichnet die Zeitreihe \"Wasserstand\" measurements.json: gibt die Daten mit Zeitpunkt und Wert zur\u00fcck \"/stations/\" + shortname + \"/W/measurements.json\" \"timestamp\", \"value\" Abruf f\u00fcr Bonn Alle Attribute, die Pegelonline benutzt werden auf deren Webseite erl\u00e4utert! Dokumentation Hinweise f\u00fcr das QGIS-Plugin PegelOnline Datenbank \u00f6ffnen Die Datenbank kann bereits beim Aufruf des Plugins in run() ge\u00f6ffnet und ein connection-Objekt erstellt werden. Da wir dort das Datenbank-Objekt instanzieren, ist deren __init__() eine geeignete Stelle. Beim \u00d6ffnen der Datenbank sollten wir testen, ob diese existiert, bzw. die n\u00f6tigen Tabellen enth\u00e4lt. # datenbank.py from pyspatialite import dbapi2 as db class PoDB(object): def __init__(self, dbname, iface): self.dbname = dbname self.iface = iface self.connection = db.connect(self.dbname) # query table names sql = \"\"\"SELECT name FROM sqlite_master WHERE type='table';\"\"\" result = self.connection.execute(sql) tables = [row[0] for row in result.fetchall()] # ... Hier sehen wir, wie eine Abfrage auf eine interne Tabelle der Datenbank erfolgt. Diese gibt die Namen aller vorhandenen Tabellen zur\u00fcck. Fehlt uns eine Tabelle, m\u00fcssen wir sie zuerst erstellen! Diese Tabellen m\u00fcssen in der Liste enthalten sein (Namen sind Vorschl\u00e4ge): \"poStations\" mit den Stationsnamen und der Punktgeometrie. \"poCurrentW\" mit den Wasserst\u00e4nden der Stationen Ist eine von diese beiden nicht vorhanden, legen wir sie mit dem SQL-Befehl \"create table\" an. \"geometry_columns\": interne Tabelle, anhand der wir erkennen, ob die Datenk eine g\u00fcltige Geodatenbank ist. fehlt diese Tabelle, f\u00fchren wir 'SELECT InitSpatialMetadata(1)' aus. Download und Daten speichern Der Download kann am besten in dem jeweiligen Modul erfolgen und auf die Funktionen aus urlreader.py zur\u00fcckgreifen. Allerdings haben die Daten so ihre Eigenarten, die eine 1:1-\u00dcbertragung in eine Tabellenform unm\u00f6glich machen. F\u00fcr den Download der Stationen hatten die bereits festgehalten, wie hier beschrieben. Eine Umwandlung f\u00fcr die Daten der Pegelst\u00e4nde erfolgt dann \u00e4hnlich, dort haben wir eine verschachtelte json-Struktur aus dem Dictionary \"timeseries\", Listen und dem dict \"currentMeasurement\" - siehe dazu die Abfragen von Pegelonline [ { \"uuid\": \"47174d8f-1b8e-4599-8a59-b580dd55bc87\", \"number\": \"48900237\", \"shortname\": \"EITZE\", \"longname\": \"EITZE\", \"km\": 9.56, \"agency\": \"WSA VERDEN\", \"longitude\": 9.27676943537587, \"latitude\": 52.90406541008721, \"water\": { \"shortname\": \"ALLER\", \"longname\": \"ALLER\" }, \"timeseries\": [ { \"shortname\": \"W\", \"longname\": \"WASSERSTAND ROHDATEN\", \"unit\": \"cm\", \"equidistance\": 15, \"currentMeasurement\": { \"timestamp\": \"2018-07-02T20:15:00+02:00\", \"value\": 234.0, \"trend\": 1, \"stateMnwMhw\": \"low\", \"stateNswHsw\": \"unknown\" }, \"gaugeZero\": { \"unit\": \"m. \u00fc. NN\", \"value\": 8.0, \"validFrom\": \"1985-03-13\" } } ] },... ] Allerdings ben\u00f6tigen wir nur diese Angaben in der Datenbank: uuid: ID zur Zuordnung eine Station value: wie in currentMeasurement angegeben trend: Prognose zum zeitlichen Verlauf stateMnwMhw: Status zum Vergleich mit Mittelwert, stateNswHsw: Status zum Vergleich mit H\u00f6chstwert (genaue Definitionen sind auf Pegelonline beschrieben!) Wir k\u00f6nnen dennoch die Funktion getDataTable() aus urlreader benutzen, m\u00fcssen die Daten aber \"nacharbeiten\". Im Endeffekt m\u00fcssen die Daten in der Datenbank-Tabelle oder wie beim Pegelverlauf, als csv-Datei gespeichert werden. F\u00fcr die Datenbanktabellen verwenden wir das sql-Kommando INSERT INTO in der Form sql = \"INSERT INTO %s (%s) VALUES (%s)\"%(table, str_fields, str_fgz) Die Angabe von Fragezeichen in der Values-Liste hilft, die Datentypen automatisch erkennen zu lassen! Vor der Ausf\u00fchrung sollten die vorhandenen Daten gel\u00f6scht werden (DELETE FROM) Wir sollten eine Liste der Tabellenspalten in einem der Module abrufen k\u00f6nnen! Solche umfangreichen Operationen schlie\u00dfen stets mit der Methode commit() des Connection-Objekts ab. Rezepte Die folgenden Rezepte sind fast alle so verfasst, dass sie auch ohne Plugin ausprobiert werden k\u00f6nnen, indem wir die angegebenen Code-Beispiele in den QGIS-Python-Editor kopieren. Anzeige eines Layers Die Anzeige eines Layers haben wir schon durchgespielt, hier haben wir es mit einer spatialite-Datenquelle (Provider) zu tun. Vergleiche 'Spatialite Layer' in: QGIS und Python. uri festlegen, mit table und geom_column layer erzeugen als QgsVectorLayer() hinzuf\u00fcgen zur Karte mit QgsMapLayerRegistry.instance().addMapLayer() F\u00fcr die Anzeige der Pegelst\u00e4nde k\u00f6nnen wir zwei Varianten einf\u00fchren: - Zugriff auf die Datenbank \u00fcber eine SQL-Abfrage mit einem Join der Tabellen poStations und poCurrentW. - Einsatz eines QGIS-Renderers zur Darstellung der Werte der Spalte \"trend\" aus der SQL-Abfrage Ebenfalls unter 'Spatialite Layer' beschrieben! Tabelle anzeigen Die QGIS-Funktion zur Tabellenanzeige lautet showAttributeTable(), Parameter ist ein Layer-Object: iface.showAttributeTable(qgsLayer) Selektionen Ein Plugin kann \u00fcber Signal-Slot-Definitionen benachrichtigt werden, wenn der Benutzer eine Auswahl an Objekten in einem Layer getroffen hat. def doLayerSelectionChanged(selected): print selected lay = iface.activeLayer() feats = lay.selectedFeatures() for f in feats: print f.attributes() lay = iface.activeLayer() lay.selectionChanged.connect(doLayerSelectionChanged) Mit dem iface-Objekt kann dann auch ein \"ZoomToSelected\" ausgef\u00fchrt werden: iface.mapCanvas().panToSelected() iface.mapCanvas().zoomIn() Die Zoom-Funktion kann auch mit diesen Methodes des mapCanvas ausgef\u00fchrt werden: zoomScale(fScale) , hier ist es m\u00f6glich einen Ma\u00dfstab anzugeben zoomToFeatureExtent(aQgsRectangle) , das Rechteck sollte dann das Ausma\u00df der selektierten Objekte haben: box = layer.boundingBoxOfSelected() zoomToFeatureIds(aQgsVectorLayer, aFeatureIdList) : sollte das gleiche bewirken, z.B.: mit selected aus der Funktion doLayerSelectionChanged() def doLayerSelectionChanged(selected): # ... iface.mapCanvas().zoomToFeatureIds(lay, selected) In unserem Plugin k\u00f6nnen wir f\u00fcr den Layer der Pegelst\u00e4nde (CurrentW) eine Selektion einrichten und die Egebnisse in der ComboBox anzeigen. from PyQt4.QtGui import QComboBox comboBox = QComboBox(iface.mainWindow()) comboBox.show() def doLayerSelectionChanged(selected): # ... comboBox.clear() if len(selected) > 0: for feat in lay.selectedFeatures(): # shortname ist eine Attributspalte des Layers print feat['shortname'] comboBox.addItem(feat['shortname']) csv-Datei speichern Als csv werden die Pegelverl\u00e4ufe (timeline) einer ausgew\u00e4hlten Station gespeichert. Hierzu entnehmen wir den aktuell angezeigten Namen aus der ComboBox: import urlreader2 as urlreader name = unicode(comboBox.currentText()) # File-Dialog: Nutzer gibt Speicherot an fileName = QFileDialog.getSaveFileName(None, 'CSV Datei speichern', name + \".csv\", '*.csv') # Download von Pegel-Online json_data = urlreader.getJsonResponse(urlreader.maskURLString(self.urljson%name)) table = urlreader.getDataTable(json_data) if fileName: f = open(fileName, 'w+') fields = [\"timestamp\", \"value\"] csvHeader = \";\".join(fields) f.write(csvHeader + '\\n') for row in table: csvRow = \";\".join(str(e) for e in row) f.write(csvRow + '\\n') f.close() Eine vollst\u00e4ndige L\u00f6sung zur Speicherung mit open() und write(), alternativ kann auch das Python-Standard-Modul csv benutzt werden. Nachrichten an den Nutzer Bei vermeintlich l\u00e4nger laufenden Operationen, auftretenden Fehlern etc. sollte der Nutzer informiert werden. Wir halten uns dabei an die QGIS-\u00fcblichen M\u00f6glichkeiten: StatusBar: Anzeige am unteren Bildschirm-Rand MessageBar: Zeitlich gesteuerte Einblendung oben im Kartenfenster Statusbar: self.iface.mainWindow().statusBar().showMessage(\"Download ...\") self.iface.mainWindow().statusBar().clearMessage() MessageBar: iface.messageBar().pushMessage(levelText, messageText, level=numLevel, duration=seconds) MessageBar in \"QGIS-Plugin\" oder in der QGIS-Dokumentation . Weiterhin besteht die M\u00f6glichkeit, eine QProgressBar anzuzeigen, bzw. die in QGIS vorhandene Fortschrittsleiste zu verwenden. Ebenfalls auf der Seite der QGIS-Dokumentation . Debuging und Tests F\u00fcr das Testen des Plugins stehen verschiedene Ans\u00e4tze zur Verf\u00fcgung, hilfreich ist der bereits besprochene Plugin-Reloader. Bevor das Plugin in QGIS geladen wird, testen wir es in der IDE (PyScripter). Hier k\u00f6nnen wir schon viele Fehler erkennen. Jedes Modul kann in einem Codeblock unter if __name__ == '__main__': Funktionen testen. Wir laden das Plugin in QGIS und versuchen, im Falle von Fehlern, diese mit print-Anweisungen einzugrenzen. Sehr anspruchsvoll ist es, mit Python eine Standalone QGIS-Umgebung zu erstellen, die komplett in der IDE l\u00e4uft, um dort das Plugin zu laden und es mit Debugger-Funktionen untersuchen zu k\u00f6nnen. Plugin-Tester","title":"Entwurf der Pegel-Online Schnittstelle"},{"location":"ch03/pgol_entwurf.html#entwurf-der-pegel-online-schnittstelle","text":"","title":"Entwurf der Pegel-Online Schnittstelle"},{"location":"ch03/pgol_entwurf.html#anforderungen","text":"In einem QGIS-Plugin soll der Zugriff auf die Daten von Pegel-Online erm\u00f6glicht werden. Hierbei sollen die Liste der Stationen abgerufen und als Layer in QGIS dargestellt werden. die aktuellen Wasserst\u00e4nde f\u00fcr alle Stationen abgerufen werden, der Trend (Angabe zum Pegelstand auf Pegel-Online) soll dabei in der Karte dargestellt werden. F\u00fcr jeweils eine Station soll der Pegelverlauf abgerufen werden, Pegel-Online stellt daf\u00fcr die Datenwerte sowie ein PNG-Bild zur Verf\u00fcgung. Beide M\u00f6glichkeiten sollen realisiert werden. Um die Daten von Pegel-Online verwalten zu k\u00f6nnen, sollen die Liste der Stationen und die aktuellen Wasserst\u00e4nde aller Stationen in einer SQLite-Datenbank gespeichert werden (zwei Tabellen). Die PNG-Grafiken des Pegelverlaufs werden sp\u00e4ter in die Oberfl\u00e4che eingef\u00fcgt, die Daten werden nicht dauerhaft gespeichert, sondern nur als Datenstruktur in einer Variablen (oder Eigenschaft) zur Verf\u00fcgung gestellt. Die Daten zum Pegelverlauf sollen als CSV-Tabelle gespeichert werden k\u00f6nnen.","title":"Anforderungen"},{"location":"ch03/pgol_entwurf.html#abfragen-an-pegel-online","text":"So sehen die unterschiedlichen Abfragen und zugeh\u00f6rigen Attribute der einzelnen Abfragen aus: Basis-URL: http://www.pegelonline.wsv.de/webservices/rest-api/v2","title":"Abfragen an Pegel-Online"},{"location":"ch03/pgol_entwurf.html#stationen","text":"mit includeTimeseries und den zur\u00fcckgegebene dictionaries: includeTimeseries listet alle Zeitreihen auf, die an der Station erhoben werden \"/stations.json?includeTimeseries=true\" \"uuid\", \"number\", \"shortname\", \"longname\", \"km\", \"agency\", \"longitude\", \"latitude\", \"water\", \"timeseries\" mit water: \"shortname\", \"longname\" mit timeseries: \"shortname\", \"longname\", \"unit\", \"equidistance\", \"gaugeZero\" mit gaugeZero: \"unit\", \"value\", \"validFrom\" Abruf","title":"Stationen"},{"location":"ch03/pgol_entwurf.html#stationen-mit-current-measurements","text":"CurrentMeasurements sind hier auf die Pegelst\u00e4nde beschr\u00e4nkt: timeseries=W dies erfordert au\u00dferdem den Parameter includeTimeseries=True \"/stations.json?timeseries=W&includeTimeseries=true&includeCurrentMeasurement=true\" \"timestamp\", \"value\", \"trend\", \"stateMnwMhw\", \"stateNswHsw\" Abruf (Diese Abfrage liefert ein recht komplexes Ergebnis: wir ben\u00f6tigen lediglich die uuid zur Identifikation der Station und die Angaben zu currentMeasurements)","title":"Stationen mit Current Measurements"},{"location":"ch03/pgol_entwurf.html#einzelne-station","text":"mit einer gemessenen Zeitreihe der Pegelst\u00e4nde: shortname ist der Name der Station W bezeichnet die Zeitreihe \"Wasserstand\" measurements.json: gibt die Daten mit Zeitpunkt und Wert zur\u00fcck \"/stations/\" + shortname + \"/W/measurements.json\" \"timestamp\", \"value\" Abruf f\u00fcr Bonn Alle Attribute, die Pegelonline benutzt werden auf deren Webseite erl\u00e4utert! Dokumentation","title":"Einzelne Station"},{"location":"ch03/pgol_entwurf.html#hinweise-fur-das-qgis-plugin-pegelonline","text":"","title":"Hinweise f\u00fcr das QGIS-Plugin PegelOnline"},{"location":"ch03/pgol_entwurf.html#datenbank-offnen","text":"Die Datenbank kann bereits beim Aufruf des Plugins in run() ge\u00f6ffnet und ein connection-Objekt erstellt werden. Da wir dort das Datenbank-Objekt instanzieren, ist deren __init__() eine geeignete Stelle. Beim \u00d6ffnen der Datenbank sollten wir testen, ob diese existiert, bzw. die n\u00f6tigen Tabellen enth\u00e4lt. # datenbank.py from pyspatialite import dbapi2 as db class PoDB(object): def __init__(self, dbname, iface): self.dbname = dbname self.iface = iface self.connection = db.connect(self.dbname) # query table names sql = \"\"\"SELECT name FROM sqlite_master WHERE type='table';\"\"\" result = self.connection.execute(sql) tables = [row[0] for row in result.fetchall()] # ... Hier sehen wir, wie eine Abfrage auf eine interne Tabelle der Datenbank erfolgt. Diese gibt die Namen aller vorhandenen Tabellen zur\u00fcck. Fehlt uns eine Tabelle, m\u00fcssen wir sie zuerst erstellen! Diese Tabellen m\u00fcssen in der Liste enthalten sein (Namen sind Vorschl\u00e4ge): \"poStations\" mit den Stationsnamen und der Punktgeometrie. \"poCurrentW\" mit den Wasserst\u00e4nden der Stationen Ist eine von diese beiden nicht vorhanden, legen wir sie mit dem SQL-Befehl \"create table\" an. \"geometry_columns\": interne Tabelle, anhand der wir erkennen, ob die Datenk eine g\u00fcltige Geodatenbank ist. fehlt diese Tabelle, f\u00fchren wir 'SELECT InitSpatialMetadata(1)' aus.","title":"Datenbank \u00f6ffnen"},{"location":"ch03/pgol_entwurf.html#download-und-daten-speichern","text":"Der Download kann am besten in dem jeweiligen Modul erfolgen und auf die Funktionen aus urlreader.py zur\u00fcckgreifen. Allerdings haben die Daten so ihre Eigenarten, die eine 1:1-\u00dcbertragung in eine Tabellenform unm\u00f6glich machen. F\u00fcr den Download der Stationen hatten die bereits festgehalten, wie hier beschrieben. Eine Umwandlung f\u00fcr die Daten der Pegelst\u00e4nde erfolgt dann \u00e4hnlich, dort haben wir eine verschachtelte json-Struktur aus dem Dictionary \"timeseries\", Listen und dem dict \"currentMeasurement\" - siehe dazu die Abfragen von Pegelonline [ { \"uuid\": \"47174d8f-1b8e-4599-8a59-b580dd55bc87\", \"number\": \"48900237\", \"shortname\": \"EITZE\", \"longname\": \"EITZE\", \"km\": 9.56, \"agency\": \"WSA VERDEN\", \"longitude\": 9.27676943537587, \"latitude\": 52.90406541008721, \"water\": { \"shortname\": \"ALLER\", \"longname\": \"ALLER\" }, \"timeseries\": [ { \"shortname\": \"W\", \"longname\": \"WASSERSTAND ROHDATEN\", \"unit\": \"cm\", \"equidistance\": 15, \"currentMeasurement\": { \"timestamp\": \"2018-07-02T20:15:00+02:00\", \"value\": 234.0, \"trend\": 1, \"stateMnwMhw\": \"low\", \"stateNswHsw\": \"unknown\" }, \"gaugeZero\": { \"unit\": \"m. \u00fc. NN\", \"value\": 8.0, \"validFrom\": \"1985-03-13\" } } ] },... ] Allerdings ben\u00f6tigen wir nur diese Angaben in der Datenbank: uuid: ID zur Zuordnung eine Station value: wie in currentMeasurement angegeben trend: Prognose zum zeitlichen Verlauf stateMnwMhw: Status zum Vergleich mit Mittelwert, stateNswHsw: Status zum Vergleich mit H\u00f6chstwert (genaue Definitionen sind auf Pegelonline beschrieben!) Wir k\u00f6nnen dennoch die Funktion getDataTable() aus urlreader benutzen, m\u00fcssen die Daten aber \"nacharbeiten\". Im Endeffekt m\u00fcssen die Daten in der Datenbank-Tabelle oder wie beim Pegelverlauf, als csv-Datei gespeichert werden. F\u00fcr die Datenbanktabellen verwenden wir das sql-Kommando INSERT INTO in der Form sql = \"INSERT INTO %s (%s) VALUES (%s)\"%(table, str_fields, str_fgz) Die Angabe von Fragezeichen in der Values-Liste hilft, die Datentypen automatisch erkennen zu lassen! Vor der Ausf\u00fchrung sollten die vorhandenen Daten gel\u00f6scht werden (DELETE FROM) Wir sollten eine Liste der Tabellenspalten in einem der Module abrufen k\u00f6nnen! Solche umfangreichen Operationen schlie\u00dfen stets mit der Methode commit() des Connection-Objekts ab.","title":"Download und Daten speichern"},{"location":"ch03/pgol_entwurf.html#rezepte","text":"Die folgenden Rezepte sind fast alle so verfasst, dass sie auch ohne Plugin ausprobiert werden k\u00f6nnen, indem wir die angegebenen Code-Beispiele in den QGIS-Python-Editor kopieren.","title":"Rezepte"},{"location":"ch03/pgol_entwurf.html#anzeige-eines-layers","text":"Die Anzeige eines Layers haben wir schon durchgespielt, hier haben wir es mit einer spatialite-Datenquelle (Provider) zu tun. Vergleiche 'Spatialite Layer' in: QGIS und Python. uri festlegen, mit table und geom_column layer erzeugen als QgsVectorLayer() hinzuf\u00fcgen zur Karte mit QgsMapLayerRegistry.instance().addMapLayer() F\u00fcr die Anzeige der Pegelst\u00e4nde k\u00f6nnen wir zwei Varianten einf\u00fchren: - Zugriff auf die Datenbank \u00fcber eine SQL-Abfrage mit einem Join der Tabellen poStations und poCurrentW. - Einsatz eines QGIS-Renderers zur Darstellung der Werte der Spalte \"trend\" aus der SQL-Abfrage Ebenfalls unter 'Spatialite Layer' beschrieben!","title":"Anzeige eines Layers"},{"location":"ch03/pgol_entwurf.html#tabelle-anzeigen","text":"Die QGIS-Funktion zur Tabellenanzeige lautet showAttributeTable(), Parameter ist ein Layer-Object: iface.showAttributeTable(qgsLayer)","title":"Tabelle anzeigen"},{"location":"ch03/pgol_entwurf.html#selektionen","text":"Ein Plugin kann \u00fcber Signal-Slot-Definitionen benachrichtigt werden, wenn der Benutzer eine Auswahl an Objekten in einem Layer getroffen hat. def doLayerSelectionChanged(selected): print selected lay = iface.activeLayer() feats = lay.selectedFeatures() for f in feats: print f.attributes() lay = iface.activeLayer() lay.selectionChanged.connect(doLayerSelectionChanged) Mit dem iface-Objekt kann dann auch ein \"ZoomToSelected\" ausgef\u00fchrt werden: iface.mapCanvas().panToSelected() iface.mapCanvas().zoomIn() Die Zoom-Funktion kann auch mit diesen Methodes des mapCanvas ausgef\u00fchrt werden: zoomScale(fScale) , hier ist es m\u00f6glich einen Ma\u00dfstab anzugeben zoomToFeatureExtent(aQgsRectangle) , das Rechteck sollte dann das Ausma\u00df der selektierten Objekte haben: box = layer.boundingBoxOfSelected() zoomToFeatureIds(aQgsVectorLayer, aFeatureIdList) : sollte das gleiche bewirken, z.B.: mit selected aus der Funktion doLayerSelectionChanged() def doLayerSelectionChanged(selected): # ... iface.mapCanvas().zoomToFeatureIds(lay, selected) In unserem Plugin k\u00f6nnen wir f\u00fcr den Layer der Pegelst\u00e4nde (CurrentW) eine Selektion einrichten und die Egebnisse in der ComboBox anzeigen. from PyQt4.QtGui import QComboBox comboBox = QComboBox(iface.mainWindow()) comboBox.show() def doLayerSelectionChanged(selected): # ... comboBox.clear() if len(selected) > 0: for feat in lay.selectedFeatures(): # shortname ist eine Attributspalte des Layers print feat['shortname'] comboBox.addItem(feat['shortname'])","title":"Selektionen"},{"location":"ch03/pgol_entwurf.html#csv-datei-speichern","text":"Als csv werden die Pegelverl\u00e4ufe (timeline) einer ausgew\u00e4hlten Station gespeichert. Hierzu entnehmen wir den aktuell angezeigten Namen aus der ComboBox: import urlreader2 as urlreader name = unicode(comboBox.currentText()) # File-Dialog: Nutzer gibt Speicherot an fileName = QFileDialog.getSaveFileName(None, 'CSV Datei speichern', name + \".csv\", '*.csv') # Download von Pegel-Online json_data = urlreader.getJsonResponse(urlreader.maskURLString(self.urljson%name)) table = urlreader.getDataTable(json_data) if fileName: f = open(fileName, 'w+') fields = [\"timestamp\", \"value\"] csvHeader = \";\".join(fields) f.write(csvHeader + '\\n') for row in table: csvRow = \";\".join(str(e) for e in row) f.write(csvRow + '\\n') f.close() Eine vollst\u00e4ndige L\u00f6sung zur Speicherung mit open() und write(), alternativ kann auch das Python-Standard-Modul csv benutzt werden.","title":"csv-Datei speichern"},{"location":"ch03/pgol_entwurf.html#nachrichten-an-den-nutzer","text":"Bei vermeintlich l\u00e4nger laufenden Operationen, auftretenden Fehlern etc. sollte der Nutzer informiert werden. Wir halten uns dabei an die QGIS-\u00fcblichen M\u00f6glichkeiten: StatusBar: Anzeige am unteren Bildschirm-Rand MessageBar: Zeitlich gesteuerte Einblendung oben im Kartenfenster Statusbar: self.iface.mainWindow().statusBar().showMessage(\"Download ...\") self.iface.mainWindow().statusBar().clearMessage() MessageBar: iface.messageBar().pushMessage(levelText, messageText, level=numLevel, duration=seconds) MessageBar in \"QGIS-Plugin\" oder in der QGIS-Dokumentation . Weiterhin besteht die M\u00f6glichkeit, eine QProgressBar anzuzeigen, bzw. die in QGIS vorhandene Fortschrittsleiste zu verwenden. Ebenfalls auf der Seite der QGIS-Dokumentation .","title":"Nachrichten an den Nutzer"},{"location":"ch03/pgol_entwurf.html#debuging-und-tests","text":"F\u00fcr das Testen des Plugins stehen verschiedene Ans\u00e4tze zur Verf\u00fcgung, hilfreich ist der bereits besprochene Plugin-Reloader. Bevor das Plugin in QGIS geladen wird, testen wir es in der IDE (PyScripter). Hier k\u00f6nnen wir schon viele Fehler erkennen. Jedes Modul kann in einem Codeblock unter if __name__ == '__main__': Funktionen testen. Wir laden das Plugin in QGIS und versuchen, im Falle von Fehlern, diese mit print-Anweisungen einzugrenzen. Sehr anspruchsvoll ist es, mit Python eine Standalone QGIS-Umgebung zu erstellen, die komplett in der IDE l\u00e4uft, um dort das Plugin zu laden und es mit Debugger-Funktionen untersuchen zu k\u00f6nnen. Plugin-Tester","title":"Debuging und Tests"},{"location":"ch03/pluginentwurf.html","text":"Entwurf des Plugins Pegel Online Reader Dialog zum Pegel Online Reader Mit dem Plugin-Builder erstellen wir ein Plugin als Dockwidget Dockwidgets werden an den Rand eines MainWindow angedockt (z.B. als \"Seitenleiste\") in QGIS als \"Bedienfeld\" Mit dem QtDesigner entwerfen wir den Inhalt des Widgets innerhalb eines Dockwidgets werden andere Elemente angelegt Dockwidget zum Pegel Online Reader Diese Funktionalit\u00e4t soll abgebildet werden: Stationen Download Liste der Stationen von Pegelonline lesen Daten in DB speichern Benutzer informieren Kartenanzeige Tabelle der DB als Vektorlayer \u00f6ffnen Layer merken Tabellenanzeige pr\u00fcfen, ob Layer geladen ist QGIS-Tabellenfenster f\u00fcr Layer \u00f6ffnen aktuelle Pegelst\u00e4nde Download aktuelle Messwerte aller Stationen von Pegelonline lesen Daten in DB speichern Benutzer informieren Kartenanzeige Abfrage auf DB (Join Stationen, Messwerte) als Vektorlayer \u00f6ffnen Layer merken und Renderer/Symbology einsetzen Signal/Slot f\u00fcr den Layer einrichten, selektierte Objekte merken Tabellenanzeige pr\u00fcfen, ob Layer geladen ist QGIS-Tabellenfenster f\u00fcr Layer \u00f6ffnen Pegelverlauf ComboBox enth\u00e4lt die Namen der selektierten Stationen aus dem Pegellayer Nutzer w\u00e4hlt hier genau eine Station aus Diagrammanzeige Ausgew\u00e4hlte Station ermitteln Daten (png) von Pegelonline herunterladen Diagramm im Plugin anzeigen Daten des Verlaufs speichern Ausgew\u00e4hlte Station ermitteln json-Daten von Pegelonline lesen heruntergeladene Daten als Datei (csv) speichern Denkbare Zusatzfunktionen Zoom auf eine Auswahl Auswahl-Button im Dockwidget Anzeige einer Basiskarte (Fluss-SHP, OSM-WMS-Anzeige) Elemente des GUI und Namen festlegen PushButton Beschriftung Name der Funktion f\u00fcr Signal/Slot pbStationsLoad Load Stations doStationsLoad pbStationsMap Show Map doStationsMap pbStationsTable Show Table doStationsTable pbCurrentLoad Load Levels doCurrentLoad pbCurrentMap Show Map doCurrentMap pbCurrentTable Show Table doCurrentTable cboxTimelineSelect ohne Beschriftung ohne Funktion pbTimelinePNG Show Timeline doTimelinePNG pbTimelineExport Export Values doTimelineExport Dateien des Plugin-Builders Zentral f\u00fcr die Entwicklung des Plugin ist das Modul, dessen Namen wir im Pluginbuilder angegeben haben: z.B. pegel_online.py. Innerhalb dieses Modules wird unser Plugin in QGIS registriert, au\u00dferdem stellt es die Methode run() zur Verf\u00fcgung, mit der unser Dockwidget in QGIS angezeigt wird. Innerhalb dieser Methode binden wir unsere Signal/Slot-Funktionen ein: def run(self): \"\"\"Run method that loads and starts the plugin\"\"\" if not self.pluginIsActive: self.pluginIsActive = True #print \"** STARTING PegelOnline\" # dockwidget may not exist if: # first run of plugin # removed on close (see self.onClosePlugin method) if self.dockwidget == None: # Create the dockwidget (after translation) and keep reference self.dockwidget = PegelOnlineDockWidget() # connect to provide cleanup on closing of dockwidget self.dockwidget.closingPlugin.connect(self.onClosePlugin) # show the dockwidget # TODO: fix to allow choice of dock location self.iface.addDockWidget(Qt.RightDockWidgetArea, self.dockwidget) self.dockwidget.show() und unsere Funktionen k\u00f6nnen auf diese Weise eingebunden werden: # connect to provide cleanup on closing of dockwidget self.dockwidget.closingPlugin.connect(self.onClosePlugin) # ## here we go self.makeEvents() # show the dockwidget #... def makeEvents(self): self.dockwidget.myButton.clicked.connect(self.doSomething) # ... def doSomething(self): pass def doSomethingElse(self): pass Klassen/Objektorientierter Entwurf Der grunds\u00e4tzliche Umgang mit den Daten von Pegel-Online liegt ja bereits vor. Die Daten werden heruntergeladen, bis auf die Grafiken als json-Strukturen, wir \u00fcberf\u00fchren die Daten in eine Python Datenstruktur und geben sie in Form einer Tabelle ( List of Tuples ) aus. Diese Daten k\u00f6nnen dann in einer Datenbank, auch mit GIS-tauglichen r\u00e4umlichen Objekten, abgelegt und auch wieder gelesen werden (letzteres werden wir allerdings QGIS \u00fcberlassen). Wir sollten nun f\u00fcr die einzelnen Operationen Begriffe finden, die sie treffend beschreiben und voneinander abgrenzen. Eine Datenbank muss mit der Anwendung verbunden (open-DB) und wieder geschlossen werden (close-DB). Dabei sollte \u00fcberpr\u00fcft werden, ob diese Datenbank existiert oder eine neue angelegt werden soll! Eine DB-Tabelle muss mit ihren Spalten und Datentypen zu den abgefragten Daten passen, eine Attributliste ist hier n\u00f6tig! Darauf basierend werden Tabellen erstellt und Daten strukturiert! Eine Tabelle mit Geomtrie-Attribut erfordert eine andere Herangehensweise, als eine \"normale\" Tabelle Klassen anlegen Vier Klassen (als Vorschlag): Modul database mit class PoDB -> Zugriff auf SQLite-Datenbank Modul stations mit class PoStations -> Lesen/Anzeigen der Stationen Modul currentw mit class PoCurrentW -> Lesen/Anzeigen der aktuellen Wasserst\u00e4nde Modul timeline mit class PoTimeline -> Lesen der Wasserst\u00e4nde der letzten x Tage Wir ordnen grob Eigenschaften und Methoden zu, danach entscheiden wir, welche Spezialisierungen brauchen wir -> abzuleitende Klassen welche Verallgemeinerungen erkennen wir -> (abstrakte) Klassen Bei den Methoden versuchen wir, bereits vorhandene Funktionen zu verwenden und testen vorgesehene Methoden aus. Entwickeln Sie ihre eigenen Module f\u00fcr die Klassen, welche die Funktionalit\u00e4t bestm\u00f6glich abbilden. Diskutieren Sie untereinander m\u00f6gliche L\u00f6sungen! Auch Schemazeichnungen k\u00f6nnen helfen! Schreiben Sie den Code zun\u00e4chst mit Platzhaltern und \u00fcberlegen Sie, welche Eigenschaften und Methoden in welcher Klasse am besten untergebracht werden k\u00f6nnen! Module importieren und Objekte erzeugen Wir importieren unsere Klassen aus den vier Modulen am Anfang von pegel_online.py. In __init__ legen wir vier Variablen als Eigenschaften an, In run(), unterhalb des Aufrufs instanzieren wir die entsprechenden Objekte in init(): # initialize plugin directory self.plugin_dir = os.path.dirname(__file__) ### HERE WE GO self.dbname = os.path.join(self.plugin_dir, \"stations.sqlite\") self.db = None self.stations = None self.currentw = None self.timeline = None Wir legen den Namen der Datenbank und des Speicherortes fest, dieser sollte im Plugin-Verzeichnis liegen. in run() # connect Signals and Slots: self.makeEvents() # initialize PoObjects: self.db = PoDB(self.dbname, self.iface) self.stations = PoStations(self.db, self.iface) self.currentw = PoCurrentW(self.db, self.iface, self.dockwidget) self.timeline = PoTimeline(self.iface, self.dockwidget) wir \u00fcbergeben bei der Objekterzeugung self.db, zum Zugriff auf die Datenbank self.iface, um Zugriff auf QGIS zu haben self.dockwidget, um Zugriff auf das gui des Plugins zu haben Eine gute Idee ist es, das Modul pegel_online.py nicht zu umfangreich werden zu lassen, da es sonst zu \u00fcn\u00fcbersichtlich wird. Alle do-Funktionen sollen daher die Verarbeitung den spezialisierten Klassen(Objekten \u00fcberlassen). Beispiel: doStationsLoad() ruft eine Methode download() des Objekts self.stations auf. innerhalb der Methode laden wir die json-Daten herunter und speichern diese als Taellendaten in der Datenbank wie die Aufgaben zwischen dem Datenbank-Modul und dem Stationen-Modul verteilt werden, sollte gut \u00fcberlegt werden. Eine sehr \u00e4hnliche Funktionsweise trifft ja auch auf die Pegelst\u00e4nde zu!","title":"Entwurf des Plugins Pegel Online Reader"},{"location":"ch03/pluginentwurf.html#entwurf-des-plugins-pegel-online-reader","text":"","title":"Entwurf des Plugins Pegel Online Reader"},{"location":"ch03/pluginentwurf.html#dialog-zum-pegel-online-reader","text":"Mit dem Plugin-Builder erstellen wir ein Plugin als Dockwidget Dockwidgets werden an den Rand eines MainWindow angedockt (z.B. als \"Seitenleiste\") in QGIS als \"Bedienfeld\" Mit dem QtDesigner entwerfen wir den Inhalt des Widgets innerhalb eines Dockwidgets werden andere Elemente angelegt Dockwidget zum Pegel Online Reader Diese Funktionalit\u00e4t soll abgebildet werden:","title":"Dialog zum Pegel Online Reader"},{"location":"ch03/pluginentwurf.html#stationen","text":"Download Liste der Stationen von Pegelonline lesen Daten in DB speichern Benutzer informieren Kartenanzeige Tabelle der DB als Vektorlayer \u00f6ffnen Layer merken Tabellenanzeige pr\u00fcfen, ob Layer geladen ist QGIS-Tabellenfenster f\u00fcr Layer \u00f6ffnen","title":"Stationen"},{"location":"ch03/pluginentwurf.html#aktuelle-pegelstande","text":"Download aktuelle Messwerte aller Stationen von Pegelonline lesen Daten in DB speichern Benutzer informieren Kartenanzeige Abfrage auf DB (Join Stationen, Messwerte) als Vektorlayer \u00f6ffnen Layer merken und Renderer/Symbology einsetzen Signal/Slot f\u00fcr den Layer einrichten, selektierte Objekte merken Tabellenanzeige pr\u00fcfen, ob Layer geladen ist QGIS-Tabellenfenster f\u00fcr Layer \u00f6ffnen","title":"aktuelle Pegelst\u00e4nde"},{"location":"ch03/pluginentwurf.html#pegelverlauf","text":"ComboBox enth\u00e4lt die Namen der selektierten Stationen aus dem Pegellayer Nutzer w\u00e4hlt hier genau eine Station aus Diagrammanzeige Ausgew\u00e4hlte Station ermitteln Daten (png) von Pegelonline herunterladen Diagramm im Plugin anzeigen Daten des Verlaufs speichern Ausgew\u00e4hlte Station ermitteln json-Daten von Pegelonline lesen heruntergeladene Daten als Datei (csv) speichern Denkbare Zusatzfunktionen Zoom auf eine Auswahl Auswahl-Button im Dockwidget Anzeige einer Basiskarte (Fluss-SHP, OSM-WMS-Anzeige)","title":"Pegelverlauf"},{"location":"ch03/pluginentwurf.html#elemente-des-gui-und-namen-festlegen","text":"PushButton Beschriftung Name der Funktion f\u00fcr Signal/Slot pbStationsLoad Load Stations doStationsLoad pbStationsMap Show Map doStationsMap pbStationsTable Show Table doStationsTable pbCurrentLoad Load Levels doCurrentLoad pbCurrentMap Show Map doCurrentMap pbCurrentTable Show Table doCurrentTable cboxTimelineSelect ohne Beschriftung ohne Funktion pbTimelinePNG Show Timeline doTimelinePNG pbTimelineExport Export Values doTimelineExport","title":"Elemente des GUI und Namen festlegen"},{"location":"ch03/pluginentwurf.html#dateien-des-plugin-builders","text":"Zentral f\u00fcr die Entwicklung des Plugin ist das Modul, dessen Namen wir im Pluginbuilder angegeben haben: z.B. pegel_online.py. Innerhalb dieses Modules wird unser Plugin in QGIS registriert, au\u00dferdem stellt es die Methode run() zur Verf\u00fcgung, mit der unser Dockwidget in QGIS angezeigt wird. Innerhalb dieser Methode binden wir unsere Signal/Slot-Funktionen ein: def run(self): \"\"\"Run method that loads and starts the plugin\"\"\" if not self.pluginIsActive: self.pluginIsActive = True #print \"** STARTING PegelOnline\" # dockwidget may not exist if: # first run of plugin # removed on close (see self.onClosePlugin method) if self.dockwidget == None: # Create the dockwidget (after translation) and keep reference self.dockwidget = PegelOnlineDockWidget() # connect to provide cleanup on closing of dockwidget self.dockwidget.closingPlugin.connect(self.onClosePlugin) # show the dockwidget # TODO: fix to allow choice of dock location self.iface.addDockWidget(Qt.RightDockWidgetArea, self.dockwidget) self.dockwidget.show() und unsere Funktionen k\u00f6nnen auf diese Weise eingebunden werden: # connect to provide cleanup on closing of dockwidget self.dockwidget.closingPlugin.connect(self.onClosePlugin) # ## here we go self.makeEvents() # show the dockwidget #... def makeEvents(self): self.dockwidget.myButton.clicked.connect(self.doSomething) # ... def doSomething(self): pass def doSomethingElse(self): pass","title":"Dateien des Plugin-Builders"},{"location":"ch03/pluginentwurf.html#klassenobjektorientierter-entwurf","text":"Der grunds\u00e4tzliche Umgang mit den Daten von Pegel-Online liegt ja bereits vor. Die Daten werden heruntergeladen, bis auf die Grafiken als json-Strukturen, wir \u00fcberf\u00fchren die Daten in eine Python Datenstruktur und geben sie in Form einer Tabelle ( List of Tuples ) aus. Diese Daten k\u00f6nnen dann in einer Datenbank, auch mit GIS-tauglichen r\u00e4umlichen Objekten, abgelegt und auch wieder gelesen werden (letzteres werden wir allerdings QGIS \u00fcberlassen). Wir sollten nun f\u00fcr die einzelnen Operationen Begriffe finden, die sie treffend beschreiben und voneinander abgrenzen. Eine Datenbank muss mit der Anwendung verbunden (open-DB) und wieder geschlossen werden (close-DB). Dabei sollte \u00fcberpr\u00fcft werden, ob diese Datenbank existiert oder eine neue angelegt werden soll! Eine DB-Tabelle muss mit ihren Spalten und Datentypen zu den abgefragten Daten passen, eine Attributliste ist hier n\u00f6tig! Darauf basierend werden Tabellen erstellt und Daten strukturiert! Eine Tabelle mit Geomtrie-Attribut erfordert eine andere Herangehensweise, als eine \"normale\" Tabelle","title":"Klassen/Objektorientierter Entwurf"},{"location":"ch03/pluginentwurf.html#klassen-anlegen","text":"Vier Klassen (als Vorschlag): Modul database mit class PoDB -> Zugriff auf SQLite-Datenbank Modul stations mit class PoStations -> Lesen/Anzeigen der Stationen Modul currentw mit class PoCurrentW -> Lesen/Anzeigen der aktuellen Wasserst\u00e4nde Modul timeline mit class PoTimeline -> Lesen der Wasserst\u00e4nde der letzten x Tage Wir ordnen grob Eigenschaften und Methoden zu, danach entscheiden wir, welche Spezialisierungen brauchen wir -> abzuleitende Klassen welche Verallgemeinerungen erkennen wir -> (abstrakte) Klassen Bei den Methoden versuchen wir, bereits vorhandene Funktionen zu verwenden und testen vorgesehene Methoden aus. Entwickeln Sie ihre eigenen Module f\u00fcr die Klassen, welche die Funktionalit\u00e4t bestm\u00f6glich abbilden. Diskutieren Sie untereinander m\u00f6gliche L\u00f6sungen! Auch Schemazeichnungen k\u00f6nnen helfen! Schreiben Sie den Code zun\u00e4chst mit Platzhaltern und \u00fcberlegen Sie, welche Eigenschaften und Methoden in welcher Klasse am besten untergebracht werden k\u00f6nnen!","title":"Klassen anlegen"},{"location":"ch03/pluginentwurf.html#module-importieren-und-objekte-erzeugen","text":"Wir importieren unsere Klassen aus den vier Modulen am Anfang von pegel_online.py. In __init__ legen wir vier Variablen als Eigenschaften an, In run(), unterhalb des Aufrufs instanzieren wir die entsprechenden Objekte in init(): # initialize plugin directory self.plugin_dir = os.path.dirname(__file__) ### HERE WE GO self.dbname = os.path.join(self.plugin_dir, \"stations.sqlite\") self.db = None self.stations = None self.currentw = None self.timeline = None Wir legen den Namen der Datenbank und des Speicherortes fest, dieser sollte im Plugin-Verzeichnis liegen. in run() # connect Signals and Slots: self.makeEvents() # initialize PoObjects: self.db = PoDB(self.dbname, self.iface) self.stations = PoStations(self.db, self.iface) self.currentw = PoCurrentW(self.db, self.iface, self.dockwidget) self.timeline = PoTimeline(self.iface, self.dockwidget) wir \u00fcbergeben bei der Objekterzeugung self.db, zum Zugriff auf die Datenbank self.iface, um Zugriff auf QGIS zu haben self.dockwidget, um Zugriff auf das gui des Plugins zu haben Eine gute Idee ist es, das Modul pegel_online.py nicht zu umfangreich werden zu lassen, da es sonst zu \u00fcn\u00fcbersichtlich wird. Alle do-Funktionen sollen daher die Verarbeitung den spezialisierten Klassen(Objekten \u00fcberlassen). Beispiel: doStationsLoad() ruft eine Methode download() des Objekts self.stations auf. innerhalb der Methode laden wir die json-Daten herunter und speichern diese als Taellendaten in der Datenbank wie die Aufgaben zwischen dem Datenbank-Modul und dem Stationen-Modul verteilt werden, sollte gut \u00fcberlegt werden. Eine sehr \u00e4hnliche Funktionsweise trifft ja auch auf die Pegelst\u00e4nde zu!","title":"Module importieren und Objekte erzeugen"},{"location":"ch03/plugintester.html","text":"Plugin-Tester Eine Python-Anwendung, die die Verwendung von QGIS-Plugins simuliert . Im Zentrum steht eine simple standalone QGIS Anwendung in Python mit den wichtigsten Obejketn und Funktionen, um eigene Plugins in der Python IDE testen und debuggenzu k\u00f6nnen. Am besten funktioniert es, eine eigene Klasse aus QgsPluginTester abezuleiten, um die Methode prepare() zu \u00fcberladen und auf die eigenen Anforderungen hin zu testen. Auf diese Weise k\u00f6nnen beispielsweise Layer geladen werden oder was das Plugin sonst realistischer Weise von QGIS ben\u00f6tigt. Die Verarbeitung erfolgt in dann drei Schritten in main() eine Instanz der Klasse erzeugen Import eines Plugins Aufruf von registerPlugin() und run() Fenster des Plugin-Testers mit geladenem Plugin Der Quellcode rund um QgsPluginTester Benutzte Quellen f\u00fcr das Modul: gis.stackexchange: Writing automated tests for qgis plugins Blog von snorfalorpagus: Writing unit tests for qgis python plugins Testcode f\u00fcr das Plugin Open eQuarter Standalone PyQGIS Scripts im Cookbook Diskussion auf gis.stackexchange zu Standalone PyQGIS Applications #------------------------------------------------------------------------------- # Name: Qgis-PluginTester # Purpose: Mimics a QGIS-Application for degugging python plugins # # Author: muellea # # Created: 22.06.2017 # Copyright: (c) muellea 2017 # Licence: free #------------------------------------------------------------------------------- from qgis.core import * from qgis.gui import * from PyQt4 import QtCore, QtGui, QtTest import os import sys # https://gis.stackexchange.com/questions/71206/writing-automated-tests-for-qgis-plugins/71226#71226 # https://snorfalorpagus.net/blog/2014/01/04/writing-unit-tests-for-qgis-python-plugins/ # ## Mimic IFACE ## # class MyInterface(object): \"\"\"mimics clas QgisInterface for iface\"\"\" def __init__(self, win, canvas): self.win = win self.canvas = canvas self.legendinterface = MyLegendInterface() def __getattr__(self, *args, **kwargs): def dummy(*args, **kwargs): return self return dummy def __iter__(self): return self def next(self): raise StopIteration def layers(self): # simulate iface.legendInterface().layers() return QgsMapLayerRegistry.instance().mapLayers().values() def mainWindow(self): return self.win def mapCanvas(self): # self.canvas.setLayerSet(QgsMapLayerRegistry.instance().mapLayers().values()) return self.canvas def legendInterface(self): return self.legendinterface class MyLegendInterface(object): \"\"\"mimics QgsLegendInterface class for iface.legendInterface()\"\"\" def __init__(self): pass def __getattr__(self, *args, **kwargs): def dummy(*args, **kwargs): return self return dummy def currentLayer(self): return QgsMapLayerRegistry.instance().mapLayers().values()[0] def layers(self): return QgsMapLayerRegistry.instance().mapLayers().values() # https://github.com/UdK-VPT/Open_eQuarter/blob/master/mole/tests/qgis_models.py class MyMapCanvas(object): \"\"\"mimics QgsMapCanvas class for iface.mapCanvas()\"\"\" def __init__(self): self.layer_set = [] def __getattr__(self, *args, **kwargs): def dummy(*args, **kwargs): return self return dummy def layers(self): return self.layer_set def layer(self, index): layer = self.layer_set[index].layer() return layer def setLayerSet(self, layer_set): self.layer_set = layer_set def layerCount(self): return len(self.layer_set) # https://www.tutorialspoint.com/pyqt/pyqt_qtoolbar_widget.htm class SimpleGUI(QtGui.QMainWindow): \"\"\"simple gui with a toolbar to register a plugin and call its action(s)\"\"\" def __init__(self, parent=None): super(SimpleGUI, self).__init__(parent) self.initUI(parent) self.plugin = None def initUI(self, parent): layout = QtGui.QVBoxLayout() self.tbPlugin = self.addToolBar(\"Plugins\") self.setLayout(layout) self.setGeometry(300, 300, 290, 150) self.setWindowTitle('Start the Plugin!') self.show() def registerPlugin(self, plgin): self.plugin = plgin self.plugin.initGui() # ## make the plugin callable ## # self.tbPlugin.addAction(self.plugin.action) def setAction(self, action): self.tbPlugin.addAction(action) class QgsPluginTester(object): \"\"\"simple QGIS standalone application to test and debug plugins. Subclassing allows to use method prepare() to load data, etc. Import a plugin, call registerPlugin() and then run(): class MyTest(QgsPluginTester): def __init__(self, argv=[]): super(MyTest, self).__init__(argv) # insert code you need to run before plugin is loaded def prepare(self): # ... def main(argv): tester = MyTest(argv) import myPluginModul tester.registerPlugin(myPluginModul) tester.run() \"\"\" def __init__(self, argv=[]): # standalone app self.app = QtGui.QApplication(argv) self.qgis_prefix = os.path.realpath(os.environ[\"QGIS_PREFIX_PATH\"]) QgsApplication.setPrefixPath(self.qgis_prefix, True) QgsApplication.initQgis() QCoreApplication.setOrganizationName('QGIS') QCoreApplication.setApplicationName('QGIS2') # MainWindow gui with toolbar self.mainW = SimpleGUI() # mimics for qgis objects self.canvas = MyMapCanvas() self.iface = MyInterface(self.mainW, self.canvas) # register at runtime self.plugin = None def registerPlugin(self, plugin_modul): \"\"\"register a plugin by calling classFactory(), initGui() and add actions to MainWindow's toolbar\"\"\" self.plugin = plugin_modul.classFactory(self.iface) self.plugin.initGui() try: self.mainW.setAction(self.plugin.action) except AttributeError: for action in self.plugin.actions: self.mainW.setAction(action) def run(self): \"\"\"run the app's event loop, calls prepare() for data initialisation\"\"\" self.prepare() # use prepare to load some data or what else your plugin needs self.app.exec_() QgsApplication.exitQgis() # ## PREPARE ## # # prepare the application, so it has data needed for the plugin def prepare(self): pass download Das Modul verwendet magische Methoden und Argumente f\u00fcr die implementierten Qgis-Klassen, n\u00e4mlich die Methode __getattr__() mit den Argumenten *args und **kwargs . Damit k\u00f6nnen dem Objekt beliebige Methoden mit beligigen Argumenten \u00fcbergeben werden. __getattr__ bietet die M\u00f6glichkeit, Eigenschaften und Methoden einer Objekts zu erfragen, die nicht im Code definiert wurden, sondern zur Laufzeit hinzugef\u00fcgt wurden. Implementiert man __getattr__ wie hier, werden alle Namen als Methode akzeptiert und immer das aktuelle Objekte zur\u00fcckgegeben. Dies f\u00fchrt dazu, dass auch Verkettungen von Methoden m\u00f6glich sind, z.B. iface.opa().oma(), das zur\u00fcckgebene self ist immer wieder das iface-Objekt. Hierzu eine Diskussion auf stackoverflow. *args erlaubt es, einer Funktion (oder Methode) beliebig viele Argumente zu \u00fcbergeben. Die Argumente haben dann jedoch keinen Namen, sondern k\u00f6nnen wie eine Liste abgearbeitet werden. **kwargs erlaubt es, beliebige benannte Argumente zu \u00fcbergeben. Die Argumente haben einen Namen und einen Wert und k\u00f6nnen wie ein dictionary behandelt werden. Erl\u00e4uterung auf pythontipps.com. Alle anderen in der Klasse definierten Methoden und Eigenschaften sind von der Regel ausgenommen, sodass f\u00fcr Plugins wichtige Elemente, insbesondere Methoden, die wirkliche Daten zur\u00fcckgeben, implementiert werden k\u00f6nnen. Weiter unten sind die Objekte mit solchen Methoden nochmals aufgef\u00fchrt. Anwendung des Moduls f\u00fcr das Plugin ListLayers Hier wurde die Klasse MyTest von QgsPluginTester abgeleitet. __init__ ist erforderlich, um das Objekt korrekt zu initialisieren, wir rufen hier lediglich super auf. prepare wurde \u00fcberladen, um aus einem Verzeichnis einige Shapefiles als QGIS-Layer zu laden. main folgt den Schritten Plugin importieren - registrieren - App starten from qgsPluginTester import * # ## use this to overwrite prepare() ## # class MyTest(QgsPluginTester): def __init__(self, argv=[]): super(MyTest, self).__init__(argv) # https://snorfalorpagus.net/blog/2014/01/04/writing-unit-tests-for-qgis-python-plugins/ def prepare(self): # read in some shapefiles and register as Layers import glob search_dir = r\"C:\\temp\\data\" for lyr in glob.glob(os.path.join(search_dir, \"*.shp\")): layer = QgsVectorLayer(lyr, os.path.basename(lyr).split(\".\")[0], 'ogr') if layer.isValid(): QgsMapLayerRegistry.instance().addMapLayer(layer) else: print \"Layer %s failed to load!\"%lyr # important if plugin uses iface.mapCanvas() self.canvas.setLayerSet(QgsMapLayerRegistry.instance().mapLayers().values()) print \"I'm prepared!\" # ## MAIN ## # def main(argv): tester = MyTest(argv) # ## TESTING a QGIS PLUGIN ## # import ListLayers tester.registerPlugin(ListLayers) tester.run() if __name__ == '__main__': main(sys.argv) download Das Modul wurde mit einigen Plugins getestet, die s\u00e4mtlich lauff\u00e4hig waren und so in PyScripter mittels Debugging untersucht werden konnten. Da es sich nicht um ein vollst\u00e4ndiges QGIS handelt - es ist sehr weit davon entfernt - k\u00f6nnen auch nicht alle Funktionen, die in einem Plugin benutzt werden, tats\u00e4chlich auf fehlerfreie Ausf\u00fchrung hin getestet werden. Die meisten Objekte und Methoden f\u00fchren gar keinen Code aus, erzeugen aber auch keine Fehler... Wird zwingend ein solches Ergebnis einer Methode ben\u00f6tigt, dann muss die entsprechende Klasse erg\u00e4nzt werden. Objekte und Methoden iface: mainWindow(): gibt ein g\u00fcltiges QT-Hauptfenster zur\u00fcck mapCanvas(): simuliert einen MapCanvas, angelegt als Dummy legendInterface(): simuliert QgsLegendInterface, angelegt als Dummy mapCanvas: layers(): gibt die Layer zur\u00fcck, die beispielsweise \u00fcber prepare geladen wurden, benutzt QgsMapLayerRegistry.instance().mapLayers().values() setLayerSet(): nimmt eine Liste mit QgsMapLayern entgegen und ersetzt zuvor vohandene Layer layerCount(): Anzahl der Layer wird geladen layer(index): Zugriff einen einzelnen Layer \u00fcber dessen Index legendInterface: currentLayer(): gibt stets den ersten Layer zur\u00fcck layers(): wie mapCanvas.layers()","title":"Plugin-Tester"},{"location":"ch03/plugintester.html#plugin-tester","text":"Eine Python-Anwendung, die die Verwendung von QGIS-Plugins simuliert . Im Zentrum steht eine simple standalone QGIS Anwendung in Python mit den wichtigsten Obejketn und Funktionen, um eigene Plugins in der Python IDE testen und debuggenzu k\u00f6nnen. Am besten funktioniert es, eine eigene Klasse aus QgsPluginTester abezuleiten, um die Methode prepare() zu \u00fcberladen und auf die eigenen Anforderungen hin zu testen. Auf diese Weise k\u00f6nnen beispielsweise Layer geladen werden oder was das Plugin sonst realistischer Weise von QGIS ben\u00f6tigt. Die Verarbeitung erfolgt in dann drei Schritten in main() eine Instanz der Klasse erzeugen Import eines Plugins Aufruf von registerPlugin() und run() Fenster des Plugin-Testers mit geladenem Plugin","title":"Plugin-Tester"},{"location":"ch03/plugintester.html#der-quellcode-rund-um-qgsplugintester","text":"Benutzte Quellen f\u00fcr das Modul: gis.stackexchange: Writing automated tests for qgis plugins Blog von snorfalorpagus: Writing unit tests for qgis python plugins Testcode f\u00fcr das Plugin Open eQuarter Standalone PyQGIS Scripts im Cookbook Diskussion auf gis.stackexchange zu Standalone PyQGIS Applications #------------------------------------------------------------------------------- # Name: Qgis-PluginTester # Purpose: Mimics a QGIS-Application for degugging python plugins # # Author: muellea # # Created: 22.06.2017 # Copyright: (c) muellea 2017 # Licence: free #------------------------------------------------------------------------------- from qgis.core import * from qgis.gui import * from PyQt4 import QtCore, QtGui, QtTest import os import sys # https://gis.stackexchange.com/questions/71206/writing-automated-tests-for-qgis-plugins/71226#71226 # https://snorfalorpagus.net/blog/2014/01/04/writing-unit-tests-for-qgis-python-plugins/ # ## Mimic IFACE ## # class MyInterface(object): \"\"\"mimics clas QgisInterface for iface\"\"\" def __init__(self, win, canvas): self.win = win self.canvas = canvas self.legendinterface = MyLegendInterface() def __getattr__(self, *args, **kwargs): def dummy(*args, **kwargs): return self return dummy def __iter__(self): return self def next(self): raise StopIteration def layers(self): # simulate iface.legendInterface().layers() return QgsMapLayerRegistry.instance().mapLayers().values() def mainWindow(self): return self.win def mapCanvas(self): # self.canvas.setLayerSet(QgsMapLayerRegistry.instance().mapLayers().values()) return self.canvas def legendInterface(self): return self.legendinterface class MyLegendInterface(object): \"\"\"mimics QgsLegendInterface class for iface.legendInterface()\"\"\" def __init__(self): pass def __getattr__(self, *args, **kwargs): def dummy(*args, **kwargs): return self return dummy def currentLayer(self): return QgsMapLayerRegistry.instance().mapLayers().values()[0] def layers(self): return QgsMapLayerRegistry.instance().mapLayers().values() # https://github.com/UdK-VPT/Open_eQuarter/blob/master/mole/tests/qgis_models.py class MyMapCanvas(object): \"\"\"mimics QgsMapCanvas class for iface.mapCanvas()\"\"\" def __init__(self): self.layer_set = [] def __getattr__(self, *args, **kwargs): def dummy(*args, **kwargs): return self return dummy def layers(self): return self.layer_set def layer(self, index): layer = self.layer_set[index].layer() return layer def setLayerSet(self, layer_set): self.layer_set = layer_set def layerCount(self): return len(self.layer_set) # https://www.tutorialspoint.com/pyqt/pyqt_qtoolbar_widget.htm class SimpleGUI(QtGui.QMainWindow): \"\"\"simple gui with a toolbar to register a plugin and call its action(s)\"\"\" def __init__(self, parent=None): super(SimpleGUI, self).__init__(parent) self.initUI(parent) self.plugin = None def initUI(self, parent): layout = QtGui.QVBoxLayout() self.tbPlugin = self.addToolBar(\"Plugins\") self.setLayout(layout) self.setGeometry(300, 300, 290, 150) self.setWindowTitle('Start the Plugin!') self.show() def registerPlugin(self, plgin): self.plugin = plgin self.plugin.initGui() # ## make the plugin callable ## # self.tbPlugin.addAction(self.plugin.action) def setAction(self, action): self.tbPlugin.addAction(action) class QgsPluginTester(object): \"\"\"simple QGIS standalone application to test and debug plugins. Subclassing allows to use method prepare() to load data, etc. Import a plugin, call registerPlugin() and then run(): class MyTest(QgsPluginTester): def __init__(self, argv=[]): super(MyTest, self).__init__(argv) # insert code you need to run before plugin is loaded def prepare(self): # ... def main(argv): tester = MyTest(argv) import myPluginModul tester.registerPlugin(myPluginModul) tester.run() \"\"\" def __init__(self, argv=[]): # standalone app self.app = QtGui.QApplication(argv) self.qgis_prefix = os.path.realpath(os.environ[\"QGIS_PREFIX_PATH\"]) QgsApplication.setPrefixPath(self.qgis_prefix, True) QgsApplication.initQgis() QCoreApplication.setOrganizationName('QGIS') QCoreApplication.setApplicationName('QGIS2') # MainWindow gui with toolbar self.mainW = SimpleGUI() # mimics for qgis objects self.canvas = MyMapCanvas() self.iface = MyInterface(self.mainW, self.canvas) # register at runtime self.plugin = None def registerPlugin(self, plugin_modul): \"\"\"register a plugin by calling classFactory(), initGui() and add actions to MainWindow's toolbar\"\"\" self.plugin = plugin_modul.classFactory(self.iface) self.plugin.initGui() try: self.mainW.setAction(self.plugin.action) except AttributeError: for action in self.plugin.actions: self.mainW.setAction(action) def run(self): \"\"\"run the app's event loop, calls prepare() for data initialisation\"\"\" self.prepare() # use prepare to load some data or what else your plugin needs self.app.exec_() QgsApplication.exitQgis() # ## PREPARE ## # # prepare the application, so it has data needed for the plugin def prepare(self): pass download Das Modul verwendet magische Methoden und Argumente f\u00fcr die implementierten Qgis-Klassen, n\u00e4mlich die Methode __getattr__() mit den Argumenten *args und **kwargs . Damit k\u00f6nnen dem Objekt beliebige Methoden mit beligigen Argumenten \u00fcbergeben werden. __getattr__ bietet die M\u00f6glichkeit, Eigenschaften und Methoden einer Objekts zu erfragen, die nicht im Code definiert wurden, sondern zur Laufzeit hinzugef\u00fcgt wurden. Implementiert man __getattr__ wie hier, werden alle Namen als Methode akzeptiert und immer das aktuelle Objekte zur\u00fcckgegeben. Dies f\u00fchrt dazu, dass auch Verkettungen von Methoden m\u00f6glich sind, z.B. iface.opa().oma(), das zur\u00fcckgebene self ist immer wieder das iface-Objekt. Hierzu eine Diskussion auf stackoverflow. *args erlaubt es, einer Funktion (oder Methode) beliebig viele Argumente zu \u00fcbergeben. Die Argumente haben dann jedoch keinen Namen, sondern k\u00f6nnen wie eine Liste abgearbeitet werden. **kwargs erlaubt es, beliebige benannte Argumente zu \u00fcbergeben. Die Argumente haben einen Namen und einen Wert und k\u00f6nnen wie ein dictionary behandelt werden. Erl\u00e4uterung auf pythontipps.com. Alle anderen in der Klasse definierten Methoden und Eigenschaften sind von der Regel ausgenommen, sodass f\u00fcr Plugins wichtige Elemente, insbesondere Methoden, die wirkliche Daten zur\u00fcckgeben, implementiert werden k\u00f6nnen. Weiter unten sind die Objekte mit solchen Methoden nochmals aufgef\u00fchrt.","title":"Der Quellcode rund um QgsPluginTester"},{"location":"ch03/plugintester.html#anwendung-des-moduls-fur-das-plugin-listlayers","text":"Hier wurde die Klasse MyTest von QgsPluginTester abgeleitet. __init__ ist erforderlich, um das Objekt korrekt zu initialisieren, wir rufen hier lediglich super auf. prepare wurde \u00fcberladen, um aus einem Verzeichnis einige Shapefiles als QGIS-Layer zu laden. main folgt den Schritten Plugin importieren - registrieren - App starten from qgsPluginTester import * # ## use this to overwrite prepare() ## # class MyTest(QgsPluginTester): def __init__(self, argv=[]): super(MyTest, self).__init__(argv) # https://snorfalorpagus.net/blog/2014/01/04/writing-unit-tests-for-qgis-python-plugins/ def prepare(self): # read in some shapefiles and register as Layers import glob search_dir = r\"C:\\temp\\data\" for lyr in glob.glob(os.path.join(search_dir, \"*.shp\")): layer = QgsVectorLayer(lyr, os.path.basename(lyr).split(\".\")[0], 'ogr') if layer.isValid(): QgsMapLayerRegistry.instance().addMapLayer(layer) else: print \"Layer %s failed to load!\"%lyr # important if plugin uses iface.mapCanvas() self.canvas.setLayerSet(QgsMapLayerRegistry.instance().mapLayers().values()) print \"I'm prepared!\" # ## MAIN ## # def main(argv): tester = MyTest(argv) # ## TESTING a QGIS PLUGIN ## # import ListLayers tester.registerPlugin(ListLayers) tester.run() if __name__ == '__main__': main(sys.argv) download Das Modul wurde mit einigen Plugins getestet, die s\u00e4mtlich lauff\u00e4hig waren und so in PyScripter mittels Debugging untersucht werden konnten. Da es sich nicht um ein vollst\u00e4ndiges QGIS handelt - es ist sehr weit davon entfernt - k\u00f6nnen auch nicht alle Funktionen, die in einem Plugin benutzt werden, tats\u00e4chlich auf fehlerfreie Ausf\u00fchrung hin getestet werden. Die meisten Objekte und Methoden f\u00fchren gar keinen Code aus, erzeugen aber auch keine Fehler... Wird zwingend ein solches Ergebnis einer Methode ben\u00f6tigt, dann muss die entsprechende Klasse erg\u00e4nzt werden.","title":"Anwendung des Moduls f\u00fcr das Plugin ListLayers"},{"location":"ch03/plugintester.html#objekte-und-methoden","text":"iface: mainWindow(): gibt ein g\u00fcltiges QT-Hauptfenster zur\u00fcck mapCanvas(): simuliert einen MapCanvas, angelegt als Dummy legendInterface(): simuliert QgsLegendInterface, angelegt als Dummy mapCanvas: layers(): gibt die Layer zur\u00fcck, die beispielsweise \u00fcber prepare geladen wurden, benutzt QgsMapLayerRegistry.instance().mapLayers().values() setLayerSet(): nimmt eine Liste mit QgsMapLayern entgegen und ersetzt zuvor vohandene Layer layerCount(): Anzahl der Layer wird geladen layer(index): Zugriff einen einzelnen Layer \u00fcber dessen Index legendInterface: currentLayer(): gibt stets den ersten Layer zur\u00fcck layers(): wie mapCanvas.layers()","title":"Objekte und Methoden"},{"location":"ch03/pyscripterplugin.html","text":"Einrichtung von PyScripter PyScripter ben\u00f6tig einige Umgebungsvariablen, um auf die Python-Module des QGIS zugreifen zu k\u00f6nnen, da sich diese in der OSGEO4W-Installation nicht unter dem Standardpfad befinden. F\u00fcr den GIS-Stick gelten folgende Ma\u00dfnahmen, um mit PyScripter QGIS-Plugins schreiben zu k\u00f6nnen: ini-Dateien anpassen: dies sind Batchfiles, die innerhalb der QGIS-Umgebung bei jedem Programmstart ausgef\u00fchrt werden (z.B. in der OSGeo4W-Shell) ini-Dateien finden wir im OSGEO4W-Verzeichnis unter etc/ini die Datei python.bat enth\u00e4lt die notwendigen Einstellungen f\u00fcr die Verwendung mit der LTR-Version von QGIS: SET QGIS_PREFIX_PATH=%OSGEO4W_ROOT:\\=/%/apps/qgis-ltr SET PYTHONPATH=%OSGEO4W_ROOT%\\apps\\qgis-ltr\\python SET PYTHONHOME=%OSGEO4W_ROOT%\\apps\\Python27 SET PATH=%PATH%;%OSGEO4W_ROOT%\\apps\\Python27\\Scripts;%OSGEO4W_ROOT%\\apps\\qgis-ltr\\bin Erl\u00e4uterung: QGIS_PREFIX_PATH legt fest, unter welchem Pfad QGIS installiert wurde. PYTHONPATH enth\u00e4lt Pfade zu alternativen Orten, an denen python mit import nach Modulen sucht PYTHONHOME verweist auf das Installationsverzeichnis von python. Der EIntrag ist wichtig, wenn es mehrere Pythonversionen gibt oder die Pythonversion nicht im Rechner registriert ist (bei OSGEO4W wird, im Gegensatz zu ArcGIS, python nicht registriert) PyScripter startet gleichfalls mit einem Batchfile und muss die Einstellungen \u00fcbernehmen und beibehalten wichtig ist, dass der Pythonpath nicht \u00fcberschrieben, sondern erg\u00e4nzt wird ( SET PYTHONPATH=%PYTHONPATH%;%PYSC_DIR%;... ) set PYSC_DIR=%~dp0 for %%F in (\"%OSGEO4W_ROOT%\\etc\\ini\\*.bat\") do call \"%%F\" SET PYTHONPATH=%PYTHONPATH%;%PYSC_DIR%;%PYSC_DIR%\\lib;%OSGEO4W_ROOT%\\apps\\python27;%OSGEO4W_ROOT%\\apps\\python27\\lib;%OSGEO4W_ROOT%\\bin; SET PATH=%PYSC_DIR%;%PATH% start \"PyScripter\" %PYSC_DIR%\\PyScripter.exe --python27 --pythondllpath=%OSGEO4W_ROOT%\\bin Test: Importieren Sie im PyScripter in einem Script die Module qgis.core und qgis.gui.","title":"Einrichtung von PyScripter"},{"location":"ch03/pyscripterplugin.html#einrichtung-von-pyscripter","text":"PyScripter ben\u00f6tig einige Umgebungsvariablen, um auf die Python-Module des QGIS zugreifen zu k\u00f6nnen, da sich diese in der OSGEO4W-Installation nicht unter dem Standardpfad befinden. F\u00fcr den GIS-Stick gelten folgende Ma\u00dfnahmen, um mit PyScripter QGIS-Plugins schreiben zu k\u00f6nnen: ini-Dateien anpassen: dies sind Batchfiles, die innerhalb der QGIS-Umgebung bei jedem Programmstart ausgef\u00fchrt werden (z.B. in der OSGeo4W-Shell) ini-Dateien finden wir im OSGEO4W-Verzeichnis unter etc/ini die Datei python.bat enth\u00e4lt die notwendigen Einstellungen f\u00fcr die Verwendung mit der LTR-Version von QGIS: SET QGIS_PREFIX_PATH=%OSGEO4W_ROOT:\\=/%/apps/qgis-ltr SET PYTHONPATH=%OSGEO4W_ROOT%\\apps\\qgis-ltr\\python SET PYTHONHOME=%OSGEO4W_ROOT%\\apps\\Python27 SET PATH=%PATH%;%OSGEO4W_ROOT%\\apps\\Python27\\Scripts;%OSGEO4W_ROOT%\\apps\\qgis-ltr\\bin Erl\u00e4uterung: QGIS_PREFIX_PATH legt fest, unter welchem Pfad QGIS installiert wurde. PYTHONPATH enth\u00e4lt Pfade zu alternativen Orten, an denen python mit import nach Modulen sucht PYTHONHOME verweist auf das Installationsverzeichnis von python. Der EIntrag ist wichtig, wenn es mehrere Pythonversionen gibt oder die Pythonversion nicht im Rechner registriert ist (bei OSGEO4W wird, im Gegensatz zu ArcGIS, python nicht registriert) PyScripter startet gleichfalls mit einem Batchfile und muss die Einstellungen \u00fcbernehmen und beibehalten wichtig ist, dass der Pythonpath nicht \u00fcberschrieben, sondern erg\u00e4nzt wird ( SET PYTHONPATH=%PYTHONPATH%;%PYSC_DIR%;... ) set PYSC_DIR=%~dp0 for %%F in (\"%OSGEO4W_ROOT%\\etc\\ini\\*.bat\") do call \"%%F\" SET PYTHONPATH=%PYTHONPATH%;%PYSC_DIR%;%PYSC_DIR%\\lib;%OSGEO4W_ROOT%\\apps\\python27;%OSGEO4W_ROOT%\\apps\\python27\\lib;%OSGEO4W_ROOT%\\bin; SET PATH=%PYSC_DIR%;%PATH% start \"PyScripter\" %PYSC_DIR%\\PyScripter.exe --python27 --pythondllpath=%OSGEO4W_ROOT%\\bin Test: Importieren Sie im PyScripter in einem Script die Module qgis.core und qgis.gui.","title":"Einrichtung von PyScripter"},{"location":"ch03/qgisplugin.html","text":"QGIS-Plugins Grundlagen Innerhalb von QGIS k\u00f6nnen Plugins benutzt werden, die erweiterte Funktionen in die Benutzeroberfl\u00e4che integrieren. Diese Plugins werden \u00fcblicherweise von einem Repositorium heruntergeladen und installiert. Zust\u00e4ndig hierf\u00fcr ist der Dialog Erweiterungen ( Plugins in der engl. Version) aus dem Men\u00fc desselben Namens (Men\u00fc->Erweiterungen->Erweiterungen verwalten und installieren). In QGIS k\u00f6nnen Plugins in verschiedener Form auftreten: als Dialogfenster (Formular), das sich \u00fcber der Anwendung \u00f6ffnet als Andockfenster (Panel), das sich in den Bereichen der Benutzeroberf\u00e4che eingf\u00fcgt zur Installation von Processing-Scripten, die in der Processing-Toolbox auftauchen Dialogfenster und Andockfenster werden \u00fcber ein Icon in einer Funktionleiste (Toolbar) aktiviert oder tauchen als Eintrag in einem Men\u00fc auf. Auch Mischformen k\u00f6nnen entwickelt werden. Um ein eigenes Plugin zu schreiben, m\u00fcssen wir die Plugin-Schnittstelle beachten und implementieren den Installationspfad f\u00fcr PlugIns kennen einen Code entwickeln, der in QGIS ausgef\u00fchrt werden kann... Bevor wir soweit sind, installieren wir nutzt einige Helferlein und schauen uns ein Beispiel an, um den Aufbau eines Plugins zu analysieren. Helfer-Plugins Um die Erstellung und Programmierung von Plugins zu erleichtern, installieren wir zwei Helfer-Plugins: Plugin Builder 3 : Erstellt das Grundger\u00fcst eines Plugins, mit allen erfoderlichen Dateien Plugin Reloader : Erm\u00f6glicht ein erneutes Einlesen des Plugins, z.B. nach \u00c4nderunen im Code, ohne QGIS jeweils neu starten zu m\u00fcssen Ein weiteres Helfer-Plugin kann bei der Fehlersuche sinnvoll sein: FirstAid f\u00e4ngt Python-Fehler in QGIS ab und bietet teilweise Funktionen eines Debuggers. Beispiel-Plugin Quick WKT Aus dem Repository installieren wir ein einfaches Plugin mit minimalem Code: Quick WKT Das Plugin verf\u00fcgt \u00fcber einen Dialog, um eine Texteingabe im Format WKT (Well-Known-Text) als Layer in QGIS anzuzeigen. Nach der Installation l\u00e4sst sich das Plugin \u00fcber die Werkzeugleiste \"Erweiterungen\" mit dem entsprechendem Icon aufrufen. Wir wollen den Python-Code analysieren, um herauszufinden, wie der Aufruf funktioniert. Alle heruntergeladenen Anwendungen werden in einem Verzeichnis ~/.qgis3/python/plugins bzw. ~/QGIS/QGIS3 gespeichert. Hierbei entspricht die Tilde (~) dem Benutzerverzeichnis, auf dem GIS-Stick ist dies der Ordner \"Home\", unter Windows h\u00e4ufig C:\\Users\\benutzername\\AppData\\Roaming unter Linux /home/benutzername In dem Verzeichnis plugins befindet sich dann ein Ordner QuickWKT mit diesen Dateien ud Unterordnern: __pycache__ icons __init__.py metadata.txt QuickWKT.py QuickWKTDialog.py Readme.rst resources.qrc Ui_QuickWkt.ui metadata.txt ist eine Pflichtdatei, es enth\u00e4lt eine Beschreibung des Plugins. __init__.py Mit __init__.py wird der Verzeichnisinhalt f\u00fcr den Python-Interpreter zu einem Package. Es kann in Python \u00fcber den Ordnernamen QuickWkt importiert werden. Die init-Datei wird dann als erstes gelesen und ausgef\u00fchrt. Diesen Mechanismus nutzt QGIS zum einbetten des Plugins: Es f\u00fcgt den Plugin-Pfad als Ort mit Python-Modulen dem Python-Interpreter hinzu und importiert automatisch alle Plugin-Packages. Beim Start von QGIS wird also die init-Datei jedes Moduls ausgef\u00fchrt! Zwingende Voraussetzung f\u00fcr ein QGIS-Plugin ist die Funktion 'classFactory()'. Sie bildet die Schnittstelle zum QGIS, das das iface-Objekt als Parameter \u00fcbergibt. def classFactory(iface): from .QuickWKT import QuickWKT return QuickWKT(iface) Die zentrale Klasse des Plugins wird hier importiert und eine Objekt-Instanz erstellt, die an QGIS zur\u00fcckgegeben wird. Diese Klasse enth\u00e4lt dann den Code, um das Plugin die Oberfl\u00e4che von Qgis, als Icon oder Men\u00fceintrag, zu integrieren. QuickWKT.py enth\u00e4lt die gleichnamige Klasse, die von __init__.py importiert und instanziiert wurde. Diese Klasse \u00fcbernimmt das iface-Objekt als Eigenschaft und definiert die Methode initGUI() . Diese wird von QGIS aufgerufen, um so die Verbindung zum Aufruf der GUI des Plugins zu erm\u00f6glichen. es wird ein QAction-Objekt erstellt und mit der run-Methode des Formulars verbunden hierbei wird ein Icon aus dem Unterordner icons eingelesen das QAction-Objekt wird in eine Toolbar und in das Plugin-Men\u00fc eingebaut. Ebenso gibt es eine Funktion zum Abmelden des Plugins aus QGIS: unload() entfernt schlicht die Aufrufm\u00f6glichkeiten f\u00fcr das Plugin, sodass es nicht mehr gestartet werden kann. In dieser Klasse finden wir auch die run-Methode, hier hei\u00dft sie quickwkt() . Die Methode zeigt den Dialog an, wenn der Benutzer das QAction als Klick auf das Icon oder im Men\u00fc ausl\u00f6st. Au\u00dferdem wertet sie aus, welche Eingaben im Dialog gemacht wurden und versucht einen Layer aus dem WKT-Textfeld zu erzeugen. resources.py die \u00dcbersetzung der XML-Datei resource.qrc, in der Icons und andere Medienelemente aufgef\u00fchrt sein k\u00f6nnen. Das Icon f\u00fcr das QAction-Objekt ist hier angegeben, die recource-Datei enth\u00e4lt den Dateinamen und einen relativen Pfad innerhalb QGIS-Plugin-Pfads. Allerdings ist in diesem Fall die resources.qrc nicht \u00fcbersetzt worden und wird wohl innerhalb des Plugins nicht verwendet. Wir w\u00fcrden sonst einen Import von resources in QuickWKT.py finden. Ui_QuickWKT.ui meist mit dem QtDesigner erstellte XML-Datei, welche die Benutzeroberfl\u00e4che beschreibt. Der Name ist frei w\u00e4hlbar, oft finden wir auch pluginname_dialog oder etwas \u00e4hnliches. Das Modul QuickWKTDialog importiert diese ui-Datei. QuickWKTDialog.py Hier wird die Logik des Dialogs festgelegt. Einmal aufgerufen, zeigt er die Widgets an, die in der ui-Datei Ui_QuickWKT.ui aufgef\u00fchrt sind. F\u00fcr diese enth\u00e4lt die Klasse die Signal-Slot-Angaben und Methoden. Der Dialog enth\u00e4lt z.B. eine ComboBox, die mit Werten gef\u00fcllt und mit der Methode on_exampleComboBox_currentIndexChanged verbunden wird. Die vorhandene Button-Leiste hat bereits vordefinierte Signal-Slots f\u00fcr Clear,OK und Cancel, die in der ui-Datei enthalten sind. Textfeld und CheckBox haben keinen verbundenen Signal-Slot. Lebenszyklus des Plugins untersuchen Mit ein paar wenigen print-Anweisungen wollen wir sehen, welche Methoden aus welchem Modul, wann aufgerufen werden. Wir beginnen mit __init__.py und dem Aufruf von classFactory, nehmen uns dann nacheinander alle Intialisierungsmethoden vor sowie die Stellen im Code, wo \"etwas passiert\" , z.B. in den Signal-Slot-Methoden. Wir \u00f6ffnen die QGIS-Python-Console, um die Ausgaben sehen zu k\u00f6nnen und benutzen den Plugin-Reloader, um das Plugin erneut einzulesen. Ein eigenes Plugin erstellen Um zu sehen, wie wir ein eigenes Plugin entwickeln k\u00f6nnen, wollen wir einen Dialog erstellen, der die Datenquellen (Pfade) aller geladenen Layer anzeigt. Unser Plugin soll daher ListLayers hei\u00dfen. Vorgehensweise: Um die n\u00f6tigen Dateien zu erhalten, nutzen wir den Plugin-Builder In die vom Plugin-Builder erstellte ui-Datei f\u00fcgen wir mit dem QtDesigner ein Der QGIS-Plugin Builder Das Modul integriert sich in die QGIS-Oberfl\u00e4che als Icon (Hammer) bzw. unter dem Men\u00fc Erweiterungen->Plugin Builder. Beim Start des Plugin \u00f6ffnet sich ein Dialog mit Formular. Wir folgen den Anweisungen und w\u00e4hlen als Template \"Tool button with dialog\". Fenster des PluginBuilder mit Pflichtfeldern Wir f\u00fcllen aus: ClassName: wird in den Code \u00fcbernommen und wird zu: class ListLayers(): Plugin-Name: Kann frei gew\u00e4hlt werden, z.B. List Layers Modulname: sollte dem Klassennamen entsprechen, wird zu listlayers.py Versionsangaben belassen wir ... Author/Company und Email address kann ihre Angaben beinhalten Weiter gehts: About: Kurzbeschreibung des Plugins N\u00e4chster Schritt: Template: Wir w\u00e4hlen Tool button mit Dialog Mit Menu kann festgelegt werden, in welchem Men\u00fc das Plugin in QGIS aufgerufen werden kann. Weiter: Angaben zu erweiterten Dateien und Tools zur Pluginentwicklung: diesmal abw\u00e4hlen Noch ein Schritt: Angaben zu bug tracker und code repository f\u00fcllen wir mit Platzhaltern letzter Schritt Wir w\u00e4hlen den Ausgabeordner und best\u00e4tigen mit \"Generate\" vom Plugin Builder erzeugte Dateien Wie wir sehen, legt der Plugin-Builder mehr Dateien an, als wir es von unseren ersten Beispielen kennen. Alle Angaben zu der Ausgabe des Plugin-Builder finden wir in der Dokumentation . Die dort erw\u00e4hnten Programme make und pb_tool verwenden wir zun\u00e4chst nicht!","title":"QGIS-Plugins"},{"location":"ch03/qgisplugin.html#qgis-plugins","text":"","title":"QGIS-Plugins"},{"location":"ch03/qgisplugin.html#grundlagen","text":"Innerhalb von QGIS k\u00f6nnen Plugins benutzt werden, die erweiterte Funktionen in die Benutzeroberfl\u00e4che integrieren. Diese Plugins werden \u00fcblicherweise von einem Repositorium heruntergeladen und installiert. Zust\u00e4ndig hierf\u00fcr ist der Dialog Erweiterungen ( Plugins in der engl. Version) aus dem Men\u00fc desselben Namens (Men\u00fc->Erweiterungen->Erweiterungen verwalten und installieren). In QGIS k\u00f6nnen Plugins in verschiedener Form auftreten: als Dialogfenster (Formular), das sich \u00fcber der Anwendung \u00f6ffnet als Andockfenster (Panel), das sich in den Bereichen der Benutzeroberf\u00e4che eingf\u00fcgt zur Installation von Processing-Scripten, die in der Processing-Toolbox auftauchen Dialogfenster und Andockfenster werden \u00fcber ein Icon in einer Funktionleiste (Toolbar) aktiviert oder tauchen als Eintrag in einem Men\u00fc auf. Auch Mischformen k\u00f6nnen entwickelt werden. Um ein eigenes Plugin zu schreiben, m\u00fcssen wir die Plugin-Schnittstelle beachten und implementieren den Installationspfad f\u00fcr PlugIns kennen einen Code entwickeln, der in QGIS ausgef\u00fchrt werden kann... Bevor wir soweit sind, installieren wir nutzt einige Helferlein und schauen uns ein Beispiel an, um den Aufbau eines Plugins zu analysieren.","title":"Grundlagen"},{"location":"ch03/qgisplugin.html#helfer-plugins","text":"Um die Erstellung und Programmierung von Plugins zu erleichtern, installieren wir zwei Helfer-Plugins: Plugin Builder 3 : Erstellt das Grundger\u00fcst eines Plugins, mit allen erfoderlichen Dateien Plugin Reloader : Erm\u00f6glicht ein erneutes Einlesen des Plugins, z.B. nach \u00c4nderunen im Code, ohne QGIS jeweils neu starten zu m\u00fcssen Ein weiteres Helfer-Plugin kann bei der Fehlersuche sinnvoll sein: FirstAid f\u00e4ngt Python-Fehler in QGIS ab und bietet teilweise Funktionen eines Debuggers.","title":"Helfer-Plugins"},{"location":"ch03/qgisplugin.html#beispiel-plugin-quick-wkt","text":"Aus dem Repository installieren wir ein einfaches Plugin mit minimalem Code: Quick WKT Das Plugin verf\u00fcgt \u00fcber einen Dialog, um eine Texteingabe im Format WKT (Well-Known-Text) als Layer in QGIS anzuzeigen. Nach der Installation l\u00e4sst sich das Plugin \u00fcber die Werkzeugleiste \"Erweiterungen\" mit dem entsprechendem Icon aufrufen. Wir wollen den Python-Code analysieren, um herauszufinden, wie der Aufruf funktioniert. Alle heruntergeladenen Anwendungen werden in einem Verzeichnis ~/.qgis3/python/plugins bzw. ~/QGIS/QGIS3 gespeichert. Hierbei entspricht die Tilde (~) dem Benutzerverzeichnis, auf dem GIS-Stick ist dies der Ordner \"Home\", unter Windows h\u00e4ufig C:\\Users\\benutzername\\AppData\\Roaming unter Linux /home/benutzername In dem Verzeichnis plugins befindet sich dann ein Ordner QuickWKT mit diesen Dateien ud Unterordnern: __pycache__ icons __init__.py metadata.txt QuickWKT.py QuickWKTDialog.py Readme.rst resources.qrc Ui_QuickWkt.ui metadata.txt ist eine Pflichtdatei, es enth\u00e4lt eine Beschreibung des Plugins. __init__.py Mit __init__.py wird der Verzeichnisinhalt f\u00fcr den Python-Interpreter zu einem Package. Es kann in Python \u00fcber den Ordnernamen QuickWkt importiert werden. Die init-Datei wird dann als erstes gelesen und ausgef\u00fchrt. Diesen Mechanismus nutzt QGIS zum einbetten des Plugins: Es f\u00fcgt den Plugin-Pfad als Ort mit Python-Modulen dem Python-Interpreter hinzu und importiert automatisch alle Plugin-Packages. Beim Start von QGIS wird also die init-Datei jedes Moduls ausgef\u00fchrt! Zwingende Voraussetzung f\u00fcr ein QGIS-Plugin ist die Funktion 'classFactory()'. Sie bildet die Schnittstelle zum QGIS, das das iface-Objekt als Parameter \u00fcbergibt. def classFactory(iface): from .QuickWKT import QuickWKT return QuickWKT(iface) Die zentrale Klasse des Plugins wird hier importiert und eine Objekt-Instanz erstellt, die an QGIS zur\u00fcckgegeben wird. Diese Klasse enth\u00e4lt dann den Code, um das Plugin die Oberfl\u00e4che von Qgis, als Icon oder Men\u00fceintrag, zu integrieren. QuickWKT.py enth\u00e4lt die gleichnamige Klasse, die von __init__.py importiert und instanziiert wurde. Diese Klasse \u00fcbernimmt das iface-Objekt als Eigenschaft und definiert die Methode initGUI() . Diese wird von QGIS aufgerufen, um so die Verbindung zum Aufruf der GUI des Plugins zu erm\u00f6glichen. es wird ein QAction-Objekt erstellt und mit der run-Methode des Formulars verbunden hierbei wird ein Icon aus dem Unterordner icons eingelesen das QAction-Objekt wird in eine Toolbar und in das Plugin-Men\u00fc eingebaut. Ebenso gibt es eine Funktion zum Abmelden des Plugins aus QGIS: unload() entfernt schlicht die Aufrufm\u00f6glichkeiten f\u00fcr das Plugin, sodass es nicht mehr gestartet werden kann. In dieser Klasse finden wir auch die run-Methode, hier hei\u00dft sie quickwkt() . Die Methode zeigt den Dialog an, wenn der Benutzer das QAction als Klick auf das Icon oder im Men\u00fc ausl\u00f6st. Au\u00dferdem wertet sie aus, welche Eingaben im Dialog gemacht wurden und versucht einen Layer aus dem WKT-Textfeld zu erzeugen. resources.py die \u00dcbersetzung der XML-Datei resource.qrc, in der Icons und andere Medienelemente aufgef\u00fchrt sein k\u00f6nnen. Das Icon f\u00fcr das QAction-Objekt ist hier angegeben, die recource-Datei enth\u00e4lt den Dateinamen und einen relativen Pfad innerhalb QGIS-Plugin-Pfads. Allerdings ist in diesem Fall die resources.qrc nicht \u00fcbersetzt worden und wird wohl innerhalb des Plugins nicht verwendet. Wir w\u00fcrden sonst einen Import von resources in QuickWKT.py finden. Ui_QuickWKT.ui meist mit dem QtDesigner erstellte XML-Datei, welche die Benutzeroberfl\u00e4che beschreibt. Der Name ist frei w\u00e4hlbar, oft finden wir auch pluginname_dialog oder etwas \u00e4hnliches. Das Modul QuickWKTDialog importiert diese ui-Datei. QuickWKTDialog.py Hier wird die Logik des Dialogs festgelegt. Einmal aufgerufen, zeigt er die Widgets an, die in der ui-Datei Ui_QuickWKT.ui aufgef\u00fchrt sind. F\u00fcr diese enth\u00e4lt die Klasse die Signal-Slot-Angaben und Methoden. Der Dialog enth\u00e4lt z.B. eine ComboBox, die mit Werten gef\u00fcllt und mit der Methode on_exampleComboBox_currentIndexChanged verbunden wird. Die vorhandene Button-Leiste hat bereits vordefinierte Signal-Slots f\u00fcr Clear,OK und Cancel, die in der ui-Datei enthalten sind. Textfeld und CheckBox haben keinen verbundenen Signal-Slot.","title":"Beispiel-Plugin Quick WKT"},{"location":"ch03/qgisplugin.html#lebenszyklus-des-plugins-untersuchen","text":"Mit ein paar wenigen print-Anweisungen wollen wir sehen, welche Methoden aus welchem Modul, wann aufgerufen werden. Wir beginnen mit __init__.py und dem Aufruf von classFactory, nehmen uns dann nacheinander alle Intialisierungsmethoden vor sowie die Stellen im Code, wo \"etwas passiert\" , z.B. in den Signal-Slot-Methoden. Wir \u00f6ffnen die QGIS-Python-Console, um die Ausgaben sehen zu k\u00f6nnen und benutzen den Plugin-Reloader, um das Plugin erneut einzulesen.","title":"Lebenszyklus des Plugins untersuchen"},{"location":"ch03/qgisplugin.html#ein-eigenes-plugin-erstellen","text":"Um zu sehen, wie wir ein eigenes Plugin entwickeln k\u00f6nnen, wollen wir einen Dialog erstellen, der die Datenquellen (Pfade) aller geladenen Layer anzeigt. Unser Plugin soll daher ListLayers hei\u00dfen. Vorgehensweise: Um die n\u00f6tigen Dateien zu erhalten, nutzen wir den Plugin-Builder In die vom Plugin-Builder erstellte ui-Datei f\u00fcgen wir mit dem QtDesigner ein","title":"Ein eigenes Plugin erstellen"},{"location":"ch03/qgisplugin.html#der-qgis-plugin-builder","text":"Das Modul integriert sich in die QGIS-Oberfl\u00e4che als Icon (Hammer) bzw. unter dem Men\u00fc Erweiterungen->Plugin Builder. Beim Start des Plugin \u00f6ffnet sich ein Dialog mit Formular. Wir folgen den Anweisungen und w\u00e4hlen als Template \"Tool button with dialog\". Fenster des PluginBuilder mit Pflichtfeldern Wir f\u00fcllen aus: ClassName: wird in den Code \u00fcbernommen und wird zu: class ListLayers(): Plugin-Name: Kann frei gew\u00e4hlt werden, z.B. List Layers Modulname: sollte dem Klassennamen entsprechen, wird zu listlayers.py Versionsangaben belassen wir ... Author/Company und Email address kann ihre Angaben beinhalten Weiter gehts: About: Kurzbeschreibung des Plugins N\u00e4chster Schritt: Template: Wir w\u00e4hlen Tool button mit Dialog Mit Menu kann festgelegt werden, in welchem Men\u00fc das Plugin in QGIS aufgerufen werden kann. Weiter: Angaben zu erweiterten Dateien und Tools zur Pluginentwicklung: diesmal abw\u00e4hlen Noch ein Schritt: Angaben zu bug tracker und code repository f\u00fcllen wir mit Platzhaltern letzter Schritt Wir w\u00e4hlen den Ausgabeordner und best\u00e4tigen mit \"Generate\" vom Plugin Builder erzeugte Dateien Wie wir sehen, legt der Plugin-Builder mehr Dateien an, als wir es von unseren ersten Beispielen kennen. Alle Angaben zu der Ausgabe des Plugin-Builder finden wir in der Dokumentation . Die dort erw\u00e4hnten Programme make und pb_tool verwenden wir zun\u00e4chst nicht!","title":"Der QGIS-Plugin Builder"},{"location":"skulpt/numpy/Readme.html","text":"","title":"Readme"}]}