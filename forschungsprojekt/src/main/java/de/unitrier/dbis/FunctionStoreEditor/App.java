/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package de.unitrier.dbis.FunctionStoreEditor;

import com.google.gson.Gson;
import com.google.gson.stream.JsonReader;
import de.unitrier.dbis.FunctionStoreEditor.URLStuff.APIURL;
import org.apache.jena.rdf.model.Model;
import org.apache.jena.rdf.model.ModelFactory;
import org.apache.jena.riot.Lang;
import org.apache.jena.riot.RDFDataMgr;
import org.apache.jena.update.UpdateAction;

import java.io.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Objects;

public class App {
	public static void main(String[] args) throws IOException {
		File folder = new File("stores");
		File[] files = folder.listFiles();
		HashMap<String, APIURL> urlMap = getURLHash("URLS.json");
		String destination = "/home/aaron/uni/forschungsprojekt/stores/new/";

		assert files != null;
		for (File file : files) {
			if (file.isDirectory()) {
				continue;
			}
			System.out.println("======= " + file.getName() + " =======");
			int count = 0;

			FunctionGetter functionGetter = new FunctionGetter(file.getAbsolutePath());
			FunctionDefinition[] functionDefinitions = functionGetter.getFunctions();
			functionGetter.close();

			System.out.println("Creating store with individual functions");
			String updateQuery = individualQuery(functionDefinitions, urlMap);
			insertStore(file, destination + "single/", updateQuery);
			System.out.println("Finished");

			System.out.println("Creating store with grouped functions");
			updateQuery = groupedQuery(functionDefinitions, urlMap);
			insertStore(file, destination + "grouped/", updateQuery);
			System.out.println("Finished");
		}


	}

	public static String individualQuery(FunctionDefinition[] functionDefinitions, HashMap<String, APIURL> urlMap) {
		String query = "PREFIX fs:<http://localhost/functionsstore#>\n" +
				"PREFIX rdf:<http://www.w3.org/1999/02/22-rdf-syntax-ns#>\n" +
				"INSERT {\n";

		for (FunctionDefinition funcDef : functionDefinitions) {
			String[] parts = funcDef.source.split("_");

			APIURL url = urlMap.get((parts[0].replace("http://localhost/f/", "") + parts[2]).toLowerCase());

			if (Objects.isNull(url)) {
				query += funcDef.insertIndividual("http://url.wasnt.resolved");
				query += "\t<http://url.wasnt.resolved> fs:requiresKey \"false\" .\n";
				//System.out.println("Problematic type: " + parts[0] + "_" + parts[2] + "_" + parts[3]);
			} else if (!query.contains(url.getUrl())) {
				query += funcDef.insertIndividual(url.getCleanUrl());
				query += url.toInsert();
			}
		}

		query += "}\n" +
				"WHERE {}";

		return query;
	}

	public static String groupedQuery(FunctionDefinition[] functionDefinitions, HashMap<String, APIURL> urlMap) {
		String query = "PREFIX fs:<http://localhost/functionsstore#>\n" +
				"PREFIX rdf:<http://www.w3.org/1999/02/22-rdf-syntax-ns#>\n" +
				"INSERT {\n";

		HashMap<String, ArrayList<FunctionDefinition>> funcMap = new HashMap<>();

		for (FunctionDefinition funcDef : functionDefinitions) {
			if (funcMap.containsKey(funcDef.getPreCondition())) {
				funcMap.get(funcDef.getPreCondition()).add(funcDef);
			} else {
				ArrayList<FunctionDefinition> newlist = new ArrayList<>();
				newlist.add(funcDef);
				funcMap.put(funcDef.getPreCondition(), newlist);
			}
		}

		for (String key : funcMap.keySet()) {

			ArrayList<FunctionDefinition> list = funcMap.get(key);

			String[] parts = list.get(0).source.split("_");
			String urlKey = (parts[0].replace("http://localhost/f/", "") + parts[2]).toLowerCase();
			APIURL url = urlMap.get(urlKey);

			if (Objects.isNull(url)) {
				query += list.get(0).insertGrouped("http://url.wasnt.resolved");
				for (FunctionDefinition funcDef : funcMap.get(key)) {
				query += funcDef.insertPost("http://url.wasnt.resolved");
			}
				//System.out.println("Problematic type: " + parts[0] + "_" + parts[2] + "_" + parts[3]);
			} else if (!query.contains(url.getUrl())) {
				query += list.get(0).insertGrouped(url.getCleanUrl());
				query += url.toInsert();
				for (FunctionDefinition funcDef : funcMap.get(key)) {
				query += funcDef.insertPost(urlMap.get(urlKey).getCleanUrl());
			}
			}


		}

		query += "}\n" +
				"WHERE {}";

		return query;
	}


	public static HashMap<String, APIURL> getURLHash(String fileName) throws FileNotFoundException {
		Gson gson = new Gson();
		File urlfile = new File(fileName);
		JsonReader reader = new JsonReader(new FileReader(urlfile));
		APIURL[] apiurls = gson.fromJson(reader, APIURL[].class);

		HashMap<String, APIURL> urlMap = new HashMap<>();

		for (APIURL apiurl : apiurls) {
			urlMap.put(apiurl.getLabel().toLowerCase(), apiurl);
			System.out.println(apiurl.getLabel());
		}

		return urlMap;
	}

	// Creates file and inserts function store with the query
	public static void insertStore(File file, String destination, String updateQuery) throws IOException {
		File newFile = initFile(destination, file.getName());

		Model model = ModelFactory.createDefaultModel();
		model.read(destination + file.getName());
		UpdateAction.parseExecute(updateQuery, model);


		FileOutputStream outputStream = new FileOutputStream(newFile);
		RDFDataMgr.write(outputStream, model, Lang.TTL);
		outputStream.close();
		model.close();
	}

	// Creates new files to fill with the new function stores
	public static File initFile(String destination, String fileName) throws IOException {
		File newFile = new File(destination + fileName);
		if (newFile.exists()) {
			newFile.delete();
		}
		newFile.createNewFile();
		System.out.println("New file created");

		System.out.println("Adding prefix to file");
		BufferedWriter writer = new BufferedWriter(new FileWriter(newFile));
		writer.write("@prefix fs:    <http://localhost/functionsstore#> .");
		writer.write("@prefix rdf:    <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .");
		writer.close();

		return newFile;
	}
}